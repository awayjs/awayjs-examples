/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*

	 AWD3 file loading example in AwayJS

	 Demonstrates:

	 How to use the Loader object to load an embedded internal awd model.

	 Code by Rob Bateman
	 rob@infiniteturtles.co.uk
	 http://www.infiniteturtles.co.uk

	 This code is distributed under the MIT License

	 Copyright (c) The Away Foundation http://www.theawayfoundation.org

	 Permission is hereby granted, free of charge, to any person obtaining a copy
	 of this software and associated documentation files (the “Software”), to deal
	 in the Software without restriction, including without limitation the rights
	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 copies of the Software, and to permit persons to whom the Software is
	 furnished to do so, subject to the following conditions:

	 The above copyright notice and this permission notice shall be included in
	 all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 THE SOFTWARE.

	 */
	"use strict";
	var AssetEvent_1 = __webpack_require__(1);
	var LoaderEvent_1 = __webpack_require__(3);
	var AssetLibrary_1 = __webpack_require__(4);
	var URLRequest_1 = __webpack_require__(25);
	var OrthographicProjection_1 = __webpack_require__(26);
	var RequestAnimationFrame_1 = __webpack_require__(38);
	var Geometry_1 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"awayjs-display/lib/base/Geometry\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var View_1 = __webpack_require__(40);
	var Sprite_1 = __webpack_require__(73);
	var HoverController_1 = __webpack_require__(85);
	var Loader_1 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"awayjs-display/lib/display/Loader\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var DefaultRenderer_1 = __webpack_require__(88);
	var AWDParser_1 = __webpack_require__(185);
	var MovieClip_1 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"awayjs-player/lib/display/MovieClip\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var CoordinateSystem_1 = __webpack_require__(67);
	var PerspectiveProjection_1 = __webpack_require__(66);
	var Camera_1 = __webpack_require__(64);
	var Font_1 = __webpack_require__(287);
	var AWD3FontViewer = (function () {
	    /**
	     * Constructor
	     */
	    function AWD3FontViewer() {
	        this._time = 0;
	        this.init();
	    }
	    /**
	     * Global initialise function
	     */
	    AWD3FontViewer.prototype.init = function () {
	        this.initEngine();
	        this.initObjects();
	        this.initListeners();
	    };
	    /**
	     * Initialise the engine
	     */
	    AWD3FontViewer.prototype.initEngine = function () {
	        //create the view
	        this._view = new View_1.default(new DefaultRenderer_1.default());
	        //this._view.renderer.renderableSorter = new RenderableNullSort();
	        this._view.backgroundColor = 0xffffff;
	        this._stage_width = 550;
	        this._stage_height = 400;
	        this._isperspective = true;
	        this._projection = new PerspectiveProjection_1.default();
	        this._projection.coordinateSystem = CoordinateSystem_1.default.RIGHT_HANDED;
	        this._projection.focalLength = 1000;
	        this._projection.preserveFocalLength = true;
	        this._projection.originX = 0.5;
	        this._projection.originY = 0.5;
	        this._camera_perspective = new Camera_1.default();
	        this._camera_perspective.projection = this._projection;
	        //this._projection.far = 500000;
	        this._hoverControl = new HoverController_1.default(this._camera_perspective, null, 180, 0, 1000);
	        this._ortho_projection = new OrthographicProjection_1.default(500);
	        this._ortho_projection.coordinateSystem = CoordinateSystem_1.default.RIGHT_HANDED;
	        this._ortho_projection.far = 500000;
	        this._ortho_projection.near = 0.1;
	        this._ortho_projection.originX = 0.5;
	        this._ortho_projection.originY = 0.5;
	        this._camera_ortho = new Camera_1.default();
	        this._camera_ortho.projection = this._ortho_projection;
	        this._view.camera = this._camera_perspective;
	        this._camera_ortho.x = 0;
	        this._camera_ortho.y = 0;
	        this._camera_ortho.scaleY = -1;
	        this._camera_ortho.z = 0;
	    };
	    /**
	     * Initialise the scene objects
	     */
	    AWD3FontViewer.prototype.initObjects = function () {
	        var _this = this;
	        AssetLibrary_1.default.enableParser(AWDParser_1.default);
	        //kickoff asset loading
	        var loader = new Loader_1.default();
	        loader.addEventListener(AssetEvent_1.default.ASSET_COMPLETE, function (event) { return _this.onAssetComplete(event); });
	        loader.addEventListener(LoaderEvent_1.default.LOAD_COMPLETE, function (event) { return _this.onRessourceComplete(event); });
	        loader.load(new URLRequest_1.default("assets/AWD3/Fonttable_test.awd"));
	    };
	    /**
	     * Initialise the listeners
	     */
	    AWD3FontViewer.prototype.initListeners = function () {
	        var _this = this;
	        window.onresize = function (event) { return _this.onResize(event); };
	        document.onkeydown = function (event) { return _this.onKeyDown(event); };
	        document.onmousedown = function (event) { return _this.onMouseDown(event); };
	        document.onmouseup = function (event) { return _this.onMouseUp(event); };
	        document.onmousemove = function (event) { return _this.onMouseMove(event); };
	        document.onmousewheel = function (event) { return _this.onMouseWheel(event); };
	        this.onResize();
	        this._timer = new RequestAnimationFrame_1.default(this.onEnterFrame, this);
	        this._timer.start();
	    };
	    /**
	     * loader listener for asset complete events
	     */
	    AWD3FontViewer.prototype.onAssetComplete = function (event) {
	        if (event.asset.isAsset(Font_1.default)) {
	            console.log("Font finished!!! ");
	            var thisfont = event.asset;
	            var thisfonttable = thisfont.get_font_table("RegularStyle");
	            var font_chars = thisfonttable.get_font_chars();
	            var charcnt_sqr = Math.sqrt(font_chars.length);
	            var font_em_size = thisfonttable.get_font_em_size() / 100;
	            var position_x = -(charcnt_sqr / 2) * font_em_size;
	            var position_y = -(charcnt_sqr / 2) * font_em_size;
	            var k = 0;
	            var pos_x = position_x;
	            var pos_y = position_y;
	            for (var i = 0; i < font_chars.length; i++) {
	                var newsprite = new Sprite_1.default(new Geometry_1.default());
	                if (k >= charcnt_sqr) {
	                    k = 0;
	                    pos_x = position_x;
	                    pos_y += font_em_size;
	                }
	                k++;
	                var thischar = font_chars[i];
	                if (thischar != null) {
	                    var thisGeom = thischar.subgeom;
	                    if (thisGeom != null) {
	                        newsprite.geometry.addSubGeometry(thisGeom);
	                    }
	                }
	                //thischar.applyTransformation(transMatrix);
	                pos_x += font_em_size;
	                newsprite.x = pos_x;
	                newsprite.y = pos_y;
	                newsprite.scaleX = newsprite.scaleY = newsprite.scaleZ = 0.01;
	                //console.log("Font x = ", newsprite.x, "Font y = ", newsprite.y);
	                this._view.scene.addChild(newsprite);
	            }
	        }
	        if (event.asset.isAsset(MovieClip_1.default)) {
	        }
	    };
	    /**
	     * loader listener for asset complete events
	     */
	    AWD3FontViewer.prototype.onRessourceComplete = function (event) {
	        if (this._rootTimeLine) {
	        }
	    };
	    /**
	     * Render loop
	     */
	    AWD3FontViewer.prototype.onEnterFrame = function (dt) {
	        this._time += dt;
	        //update camera controler
	        // this._cameraController.update();
	        if (this._rootTimeLine != undefined) {
	            //console.log("RENDER = ");
	            this._rootTimeLine.update(dt);
	        }
	        //console.log("RENDER = ");
	        //update view
	        this._view.render();
	    };
	    AWD3FontViewer.prototype.onKeyDown = function (event) {
	        console.log("keycode = " + event.keyCode);
	        if (event.keyCode == 80) {
	            this._isperspective = true;
	            this._view.camera = this._camera_perspective;
	        }
	        if (event.keyCode == 79) {
	            this._isperspective = false;
	            this._view.camera = this._camera_ortho;
	        }
	        if (event.keyCode == 81) {
	            if (this._isperspective) {
	                this._hoverControl.distance += 5;
	            }
	            else {
	                this._ortho_projection.projectionHeight += 5;
	            }
	        }
	        else if (event.keyCode == 87) {
	            if (this._isperspective) {
	                this._hoverControl.distance -= 5;
	            }
	            else {
	                this._ortho_projection.projectionHeight -= 5;
	            }
	        }
	        if (event.keyCode == 65) {
	            if (this._isperspective) {
	                this._hoverControl.distance += 50;
	            }
	            else {
	                this._ortho_projection.projectionHeight += 50;
	            }
	        }
	        else if (event.keyCode == 83) {
	            if (this._isperspective) {
	                this._hoverControl.distance -= 50;
	            }
	            else {
	                this._ortho_projection.projectionHeight -= 50;
	            }
	        }
	    };
	    AWD3FontViewer.prototype.onMouseDown = function (event) {
	        this._lastPanAngle = this._hoverControl.panAngle;
	        this._lastTiltAngle = this._hoverControl.tiltAngle;
	        this._lastMouseX = event.clientX;
	        this._lastMouseY = event.clientY;
	        this._move = true;
	    };
	    AWD3FontViewer.prototype.onMouseUp = function (event) {
	        this._move = false;
	    };
	    AWD3FontViewer.prototype.onMouseMove = function (event) {
	        if (this._move) {
	            if (this._isperspective) {
	                this._hoverControl.panAngle = 0.3 * (event.clientX - this._lastMouseX) + this._lastPanAngle;
	                this._hoverControl.tiltAngle = -0.3 * (event.clientY - this._lastMouseY) + this._lastTiltAngle;
	            }
	            else {
	                if (event.clientX > (this._lastMouseX + 10))
	                    this._camera_ortho.x -= 10;
	                else if (event.clientX > this._lastMouseX)
	                    this._camera_ortho.x--;
	                else if (event.clientX < (this._lastMouseX - 10))
	                    this._camera_ortho.x += 10;
	                else if (event.clientX < this._lastMouseX)
	                    this._camera_ortho.x++;
	                if (event.clientY > (this._lastMouseY + 10))
	                    this._camera_ortho.y -= 10;
	                else if (event.clientY > this._lastMouseY)
	                    this._camera_ortho.y--;
	                else if (event.clientY < (this._lastMouseY - 10))
	                    this._camera_ortho.y += 10;
	                else if (event.clientY < this._lastMouseY)
	                    this._camera_ortho.y++;
	                this._lastMouseX = event.clientX;
	                this._lastMouseY = event.clientY;
	            }
	        }
	    };
	    AWD3FontViewer.prototype.onMouseWheel = function (event) {
	        if (this._isperspective) {
	            this._hoverControl.distance -= event.wheelDelta * 5;
	            if (this._hoverControl.distance < 100) {
	                this._hoverControl.distance = 100;
	            }
	        }
	        else {
	            this._ortho_projection.projectionHeight -= event.wheelDelta * 5;
	            if (this._ortho_projection.projectionHeight < 5) {
	                this._ortho_projection.projectionHeight = 5;
	            }
	        }
	    };
	    AWD3FontViewer.prototype.onResize = function (event) {
	        if (event === void 0) { event = null; }
	        this._view.y = 0;
	        this._view.x = 0;
	        this._view.width = window.innerWidth;
	        this._view.height = window.innerHeight;
	    };
	    return AWD3FontViewer;
	}());
	window.onload = function () {
	    new AWD3FontViewer();
	};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * @class away.events.AssetEvent
	 */
	var AssetEvent = (function (_super) {
	    __extends(AssetEvent, _super);
	    /**
	     *
	     */
	    function AssetEvent(type, asset, prevName) {
	        if (prevName === void 0) { prevName = null; }
	        _super.call(this, type);
	        this._asset = asset;
	        this._prevName = prevName || this._asset.name;
	    }
	    Object.defineProperty(AssetEvent.prototype, "asset", {
	        /**
	         *
	         */
	        get: function () {
	            return this._asset;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetEvent.prototype, "prevName", {
	        /**
	         *
	         */
	        get: function () {
	            return this._prevName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AssetEvent.prototype.clone = function () {
	        return new AssetEvent(this.type, this._asset, this._prevName);
	    };
	    /**
	     * Dispatched when the content of an asset is invalidated
	     */
	    AssetEvent.INVALIDATE = "invalidate";
	    /**
	     * Dispatched when an asset is diposed
	     */
	    AssetEvent.DISPOSE = "dispose";
	    /**
	     * Dispatched when an asset is cleared
	     */
	    AssetEvent.CLEAR = "clear";
	    /**
	     *
	     */
	    AssetEvent.RENAME = 'rename';
	    /**
	     *
	     */
	    AssetEvent.ENTER_FRAME = 'enterFrame';
	    /**
	     *
	     */
	    AssetEvent.EXIT_FRAME = 'exitFrame';
	    /**
	     *
	     */
	    AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
	    /**
	     * Dispatched when the loading of an asset and all of its dependencies is complete.
	     */
	    AssetEvent.ASSET_COMPLETE = "assetComplete";
	    /**
	     *
	     */
	    AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
	    return AssetEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AssetEvent;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	var EventBase = (function () {
	    function EventBase(type) {
	        /**
	         * Type of event
	         * @property type
	         * @type String
	         */
	        this.type = undefined;
	        /**
	         * Reference to target object
	         * @property target
	         * @type Object
	         */
	        this.target = undefined;
	        this.type = type;
	    }
	    /**
	     * Clones the current event.
	     * @return An exact duplicate of the current event.
	     */
	    EventBase.prototype.clone = function () {
	        return new EventBase(this.type);
	    };
	    return EventBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EventBase;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var LoaderEvent = (function (_super) {
	    __extends(LoaderEvent, _super);
	    /**
	     * Create a new LoaderEvent object.
	     *
	     * @param type The event type.
	     * @param url The url of the loaded resource.
	     * @param assets The assets of the loaded resource.
	     */
	    function LoaderEvent(type, url, content, assets) {
	        if (url === void 0) { url = null; }
	        if (content === void 0) { content = null; }
	        if (assets === void 0) { assets = null; }
	        _super.call(this, type);
	        this._url = url;
	        this._content = content;
	        this._assets = assets;
	    }
	    Object.defineProperty(LoaderEvent.prototype, "content", {
	        /**
	         * The content returned if the resource has been loaded inside a <code>Loader</code> object.
	         */
	        get: function () {
	            return this._content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderEvent.prototype, "url", {
	        /**
	         * The url of the loaded resource.
	         */
	        get: function () {
	            return this._url;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderEvent.prototype, "assets", {
	        /**
	         * The error string on loadError.
	         */
	        get: function () {
	            return this._assets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the current event.
	     * @return An exact duplicate of the current event.
	     */
	    LoaderEvent.prototype.clone = function () {
	        return new LoaderEvent(this.type, this._url, this._content, this._assets);
	    };
	    /**
	     * Dispatched when the loading of a session and all of its dependencies is complete.
	     */
	    LoaderEvent.LOAD_COMPLETE = "loadComplete";
	    return LoaderEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LoaderEvent;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AssetLibraryBundle_1 = __webpack_require__(5);
	var Loader_1 = __webpack_require__(7);
	/**
	 * AssetLibrary enforces a singleton pattern and is not intended to be instanced.
	 * It's purpose is to allow access to the default library bundle through a set of static shortcut methods.
	 * If you are interested in creating multiple library bundles, please use the <code>getBundle()</code> method.
	 */
	var AssetLibrary = (function () {
	    /**
	     * Creates a new <code>AssetLibrary</code> object.
	     *
	     */
	    function AssetLibrary() {
	    }
	    //*/
	    /**
	     * Returns an AssetLibrary bundle instance. If no key is given, returns the default bundle (which is
	     * similar to using the AssetLibraryBundle as a singleton). To keep several separated library bundles,
	     * pass a string key to this method to define which bundle should be returned. This is
	     * referred to as using the AssetLibraryBundle as a multiton.
	     *
	     * @param key Defines which multiton instance should be returned.
	     * @return An instance of the asset library
	     */
	    AssetLibrary.getBundle = function (key) {
	        if (key === void 0) { key = 'default'; }
	        return AssetLibraryBundle_1.default.getInstance(key);
	    };
	    /**
	     *
	     */
	    AssetLibrary.enableParser = function (parserClass) {
	        Loader_1.default.enableParser(parserClass);
	    };
	    /**
	     *
	     */
	    AssetLibrary.enableParsers = function (parserClasses) {
	        Loader_1.default.enableParsers(parserClasses);
	    };
	    Object.defineProperty(AssetLibrary, "conflictStrategy", {
	        /**
	         * Short-hand for conflictStrategy property on default asset library bundle.
	         *
	         * @see AssetLibraryBundle.conflictStrategy
	         */
	        get: function () {
	            return AssetLibrary.getBundle().conflictStrategy;
	        },
	        set: function (val) {
	            AssetLibrary.getBundle().conflictStrategy = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibrary, "conflictPrecedence", {
	        /**
	         * Short-hand for conflictPrecedence property on default asset library bundle.
	         *
	         * @see AssetLibraryBundle.conflictPrecedence
	         */
	        get: function () {
	            return AssetLibrary.getBundle().conflictPrecedence;
	        },
	        set: function (val) {
	            AssetLibrary.getBundle().conflictPrecedence = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Short-hand for createIterator() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.createIterator()
	     */
	    AssetLibrary.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
	        if (namespaceFilter === void 0) { namespaceFilter = null; }
	        if (filterFunc === void 0) { filterFunc = null; }
	        return AssetLibrary.getBundle().createIterator(assetTypeFilter, namespaceFilter, filterFunc);
	    };
	    /**
	     * Short-hand for load() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.load()
	     */
	    AssetLibrary.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        AssetLibrary.getBundle().load(req, context, ns, parser);
	    };
	    /**
	     * Short-hand for loadData() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.loadData()
	     */
	    AssetLibrary.loadData = function (data, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        AssetLibrary.getBundle().loadData(data, context, ns, parser);
	    };
	    AssetLibrary.stopLoad = function () {
	        AssetLibrary.getBundle().stopAllLoaders();
	    };
	    AssetLibrary.getLoader = function () {
	        return AssetLibrary.getBundle().getLoader();
	    };
	    /**
	     * Short-hand for getAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.getAsset()
	     */
	    AssetLibrary.getAsset = function (name, ns) {
	        if (ns === void 0) { ns = null; }
	        return AssetLibrary.getBundle().getAsset(name, ns);
	    };
	    /**
	     * Short-hand for getAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.getAsset()
	     */
	    AssetLibrary.getAllAssets = function () {
	        return AssetLibrary.getBundle().getAllAssets();
	    };
	    /**
	     * Short-hand for addEventListener() method on default asset library bundle.
	     */
	    AssetLibrary.addEventListener = function (type, listener) {
	        AssetLibrary.getBundle().addEventListener(type, listener);
	    };
	    /**
	     * Short-hand for removeEventListener() method on default asset library bundle.
	     */
	    AssetLibrary.removeEventListener = function (type, listener) {
	        AssetLibrary.getBundle().removeEventListener(type, listener);
	    };
	    /**
	     * Short-hand for hasEventListener() method on default asset library bundle.

	     public static hasEventListener(type:string):boolean
	     {
	        return AssetLibrary.getBundle().hasEventListener(type);
	    }

	     public static willTrigger(type:string):boolean
	     {
	        return getBundle().willTrigger(type);
	    }
	     */
	    /**
	     * Short-hand for addAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.addAsset()
	     */
	    AssetLibrary.addAsset = function (asset) {
	        AssetLibrary.getBundle().addAsset(asset);
	    };
	    /**
	     * Short-hand for removeAsset() method on default asset library bundle.
	     *
	     * @param asset The asset which should be removed from the library.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAsset()
	     */
	    AssetLibrary.removeAsset = function (asset, dispose) {
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeAsset(asset, dispose);
	    };
	    /**
	     * Short-hand for removeAssetByName() method on default asset library bundle.
	     *
	     * @param name The name of the asset to be removed.
	     * @param ns The namespace to which the desired asset belongs.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAssetByName()
	     */
	    AssetLibrary.removeAssetByName = function (name, ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        return AssetLibrary.getBundle().removeAssetByName(name, ns, dispose);
	    };
	    /**
	     * Short-hand for removeAllAssets() method on default asset library bundle.
	     *
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAllAssets()
	     */
	    AssetLibrary.removeAllAssets = function (dispose) {
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeAllAssets(dispose);
	    };
	    /**
	     * Short-hand for removeNamespaceAssets() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.removeNamespaceAssets()
	     */
	    AssetLibrary.removeNamespaceAssets = function (ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeNamespaceAssets(ns, dispose);
	    };
	    return AssetLibrary;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AssetLibrary;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetLibraryIterator_1 = __webpack_require__(6);
	var Loader_1 = __webpack_require__(7);
	var ConflictPrecedence_1 = __webpack_require__(16);
	var ConflictStrategy_1 = __webpack_require__(17);
	var AssetBase_1 = __webpack_require__(24);
	var ErrorBase_1 = __webpack_require__(21);
	var AssetEvent_1 = __webpack_require__(1);
	var URLLoaderEvent_1 = __webpack_require__(13);
	var LoaderEvent_1 = __webpack_require__(3);
	var EventDispatcher_1 = __webpack_require__(12);
	var ParserEvent_1 = __webpack_require__(14);
	/**
	 * AssetLibraryBundle enforces a multiton pattern and is not intended to be instanced directly.
	 * Its purpose is to create a container for 3D data management, both before and after parsing.
	 * If you are interested in creating multiple library bundles, please use the <code>getInstance()</code> method.
	 */
	var AssetLibraryBundle = (function (_super) {
	    __extends(AssetLibraryBundle, _super);
	    /**
	     * Creates a new <code>AssetLibraryBundle</code> object.
	     *
	     * @param me A multiton enforcer for the AssetLibraryBundle ensuring it cannnot be instanced.
	     */
	    function AssetLibraryBundle() {
	        var _this = this;
	        _super.call(this);
	        this._loaderSessionsGarbage = new Array();
	        this._assets = new Array(); //new Vector.<IAsset>;
	        this._assetDictionary = new Object();
	        this._loaderSessions = new Array();
	        this.conflictStrategy = ConflictStrategy_1.default.IGNORE.create();
	        this.conflictPrecedence = ConflictPrecedence_1.default.FAVOR_NEW;
	        this._onAssetRenameDelegate = function (event) { return _this.onAssetRename(event); };
	        this._onAssetConflictResolvedDelegate = function (event) { return _this.onAssetConflictResolved(event); };
	        this._onResourceCompleteDelegate = function (event) { return _this.onResourceComplete(event); };
	        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
	        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
	        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
	        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
	    }
	    /**
	     * Returns an AssetLibraryBundle instance. If no key is given, returns the default bundle instance (which is
	     * similar to using the AssetLibraryBundle as a singleton.) To keep several separated library bundles,
	     * pass a string key to this method to define which bundle should be returned. This is
	     * referred to as using the AssetLibrary as a multiton.
	     *
	     * @param key Defines which multiton instance should be returned.
	     * @return An instance of the asset library
	     */
	    AssetLibraryBundle.getInstance = function (key) {
	        if (key === void 0) { key = 'default'; }
	        if (!key)
	            key = 'default';
	        if (!AssetLibraryBundle._iInstances.hasOwnProperty(key))
	            AssetLibraryBundle._iInstances[key] = new AssetLibraryBundle();
	        return AssetLibraryBundle._iInstances[key];
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.enableParser = function (parserClass) {
	        Loader_1.default.enableParser(parserClass);
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.enableParsers = function (parserClasses) {
	        Loader_1.default.enableParsers(parserClasses);
	    };
	    Object.defineProperty(AssetLibraryBundle.prototype, "conflictStrategy", {
	        /**
	         * Defines which strategy should be used for resolving naming conflicts, when two library
	         * assets are given the same name. By default, <code>ConflictStrategy.APPEND_NUM_SUFFIX</code>
	         * is used which means that a numeric suffix is appended to one of the assets. The
	         * <code>conflictPrecedence</code> property defines which of the two conflicting assets will
	         * be renamed.
	         *
	         * @see naming.ConflictStrategy
	         * @see AssetLibrary.conflictPrecedence
	         */
	        get: function () {
	            return this._strategy;
	        },
	        set: function (val) {
	            if (!val)
	                throw new ErrorBase_1.default('namingStrategy must not be null. To ignore naming, use AssetLibrary.IGNORE');
	            this._strategy = val.create();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibraryBundle.prototype, "conflictPrecedence", {
	        /**
	         * Defines which asset should have precedence when resolving a naming conflict between
	         * two assets of which one has just been renamed by the user or by a parser. By default
	         * <code>ConflictPrecedence.FAVOR_NEW</code> is used, meaning that the newly renamed
	         * asset will keep it's new name while the older asset gets renamed to not conflict.
	         *
	         * This property is ignored for conflict strategies that do not actually rename an
	         * asset automatically, such as ConflictStrategy.IGNORE and ConflictStrategy.THROW_ERROR.
	         *
	         * @see away.library.ConflictPrecedence
	         * @see away.library.ConflictStrategy
	         */
	        get: function () {
	            return this._strategyPreference;
	        },
	        set: function (val) {
	            this._strategyPreference = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an AssetLibraryIterator instance that can be used to iterate over the assets
	     * in this asset library instance. The iterator can filter assets on asset type and/or
	     * namespace. A "null" filter value means no filter of that type is used.
	     *
	     * @param assetTypeFilter Asset type to filter on (from the AssetType enum class.) Use
	     * null to not filter on asset type.
	     * @param namespaceFilter Namespace to filter on. Use null to not filter on namespace.
	     * @param filterFunc Callback function to use when deciding whether an asset should be
	     * included in the iteration or not. This needs to be a function that takes a single
	     * parameter of type IAsset and returns a boolean where true means it should be included.
	     *
	     * @see away.library.AssetType
	     */
	    AssetLibraryBundle.prototype.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
	        if (namespaceFilter === void 0) { namespaceFilter = null; }
	        if (filterFunc === void 0) { filterFunc = null; }
	        return new AssetLibraryIterator_1.default(this._assets, assetTypeFilter, namespaceFilter, filterFunc);
	    };
	    /**
	     * Loads a file and (optionally) all of its dependencies.
	     *
	     * @param req The URLRequest object containing the URL of the file to be loaded.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     * @return A handle to the retrieved resource.
	     */
	    AssetLibraryBundle.prototype.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this.getLoader().load(req, context, ns, parser);
	    };
	    /**
	     * Loads a resource from existing data in memory.
	     *
	     * @param data The data object containing all resource information.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     * @return A handle to the retrieved resource.
	     */
	    AssetLibraryBundle.prototype.loadData = function (data, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this.getLoader().loadData(data, '', context, ns, parser);
	    };
	    AssetLibraryBundle.prototype.getLoader = function () {
	        var loader = new Loader_1.default();
	        this._loaderSessions.push(loader);
	        loader.addEventListener(LoaderEvent_1.default.LOAD_COMPLETE, this._onResourceCompleteDelegate);
	        loader.addEventListener(AssetEvent_1.default.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        loader.addEventListener(AssetEvent_1.default.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        // Error are handled separately (see documentation for addErrorHandler)
	        loader._iAddErrorHandler(this._onLoadErrorDelegate);
	        loader._iAddParseErrorHandler(this._onParseErrorDelegate);
	        return loader;
	    };
	    AssetLibraryBundle.prototype.disposeLoader = function (loader) {
	        var _this = this;
	        var index = this._loaderSessions.indexOf(loader);
	        this._loaderSessions.splice(index, 1);
	        // Add loader to a garbage array - for a collection sweep and kill
	        this._loaderSessionsGarbage.push(loader);
	        this._gcTimeoutIID = setTimeout(function () { _this.loaderSessionGC(); }, 100);
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.getAsset = function (name, ns) {
	        if (ns === void 0) { ns = null; }
	        if (this._assetDictDirty)
	            this.rehashAssetDict();
	        if (ns == null)
	            ns = AssetBase_1.default.DEFAULT_NAMESPACE;
	        if (!this._assetDictionary.hasOwnProperty(ns))
	            return null;
	        return this._assetDictionary[ns][name];
	    };
	    AssetLibraryBundle.prototype.getAllAssets = function () {
	        return this._assets;
	    };
	    /**
	     * Adds an asset to the asset library, first making sure that it's name is unique
	     * using the method defined by the <code>conflictStrategy</code> and
	     * <code>conflictPrecedence</code> properties.
	     */
	    AssetLibraryBundle.prototype.addAsset = function (asset) {
	        var ns;
	        var old;
	        // Bail if asset has already been added.
	        if (this._assets.indexOf(asset) >= 0)
	            return;
	        old = this.getAsset(asset.name, asset.assetNamespace);
	        ns = asset.assetNamespace || AssetBase_1.default.DEFAULT_NAMESPACE;
	        if (old != null)
	            this._strategy.resolveConflict(asset, old, this._assetDictionary[ns], this._strategyPreference);
	        //create unique-id (for now this is used in AwayBuilder only
	        //asset.id = IDUtil.createUID();
	        // Add it
	        this._assets.push(asset);
	        if (!this._assetDictionary.hasOwnProperty(ns))
	            this._assetDictionary[ns] = new Object();
	        this._assetDictionary[ns][asset.name] = asset;
	        asset.addEventListener(AssetEvent_1.default.RENAME, this._onAssetRenameDelegate);
	        asset.addEventListener(AssetEvent_1.default.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
	    };
	    /**
	     * Removes an asset from the library, and optionally disposes that asset by calling
	     * it's disposeAsset() method (which for most assets is implemented as a default
	     * version of that type's dispose() method.
	     *
	     * @param asset The asset which should be removed from this library.
	     * @param dispose Defines whether the assets should also be disposed.
	     */
	    AssetLibraryBundle.prototype.removeAsset = function (asset, dispose) {
	        if (dispose === void 0) { dispose = true; }
	        var idx;
	        this.removeAssetFromDict(asset);
	        asset.removeEventListener(AssetEvent_1.default.RENAME, this._onAssetRenameDelegate);
	        asset.removeEventListener(AssetEvent_1.default.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
	        idx = this._assets.indexOf(asset);
	        if (idx >= 0)
	            this._assets.splice(idx, 1);
	        if (dispose)
	            asset.dispose();
	    };
	    /**
	     * Removes an asset which is specified using name and namespace.
	     *
	     * @param name The name of the asset to be removed.
	     * @param ns The namespace to which the desired asset belongs.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see away.library.AssetLibrary.removeAsset()
	     */
	    AssetLibraryBundle.prototype.removeAssetByName = function (name, ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        var asset = this.getAsset(name, ns);
	        if (asset)
	            this.removeAsset(asset, dispose);
	        return asset;
	    };
	    /**
	     * Removes all assets from the asset library, optionally disposing them as they
	     * are removed.
	     *
	     * @param dispose Defines whether the assets should also be disposed.
	     */
	    AssetLibraryBundle.prototype.removeAllAssets = function (dispose) {
	        if (dispose === void 0) { dispose = true; }
	        if (dispose) {
	            var asset;
	            var len = this._assets.length;
	            for (var c = 0; c < len; c++) {
	                asset = this._assets[c];
	                asset.dispose();
	            }
	        }
	        this._assets.length = 0;
	        this.rehashAssetDict();
	    };
	    /**
	     * Removes all assets belonging to a particular namespace (null for default)
	     * from the asset library, and optionall disposes them by calling their
	     * disposeAsset() method.
	     *
	     * @param ns The namespace from which all assets should be removed.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see away.library.AssetLibrary.removeAsset()
	     */
	    AssetLibraryBundle.prototype.removeNamespaceAssets = function (ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        var idx = 0;
	        var asset;
	        var old_assets;
	        // Empty the assets vector after having stored a copy of it.
	        // The copy will be filled with all assets which weren't removed.
	        old_assets = this._assets.concat();
	        this._assets.length = 0;
	        if (ns == null)
	            ns = AssetBase_1.default.DEFAULT_NAMESPACE;
	        var len = old_assets.length;
	        for (var d = 0; d < len; d++) {
	            asset = old_assets[d];
	            // Remove from dict if in the supplied namespace. If not,
	            // transfer over to the new vector.
	            if (asset.assetNamespace == ns) {
	                if (dispose)
	                    asset.dispose();
	                // Remove asset from dictionary, but don't try to auto-remove
	                // the namespace, which will trigger an unnecessarily expensive
	                // test that is not needed since we know that the namespace
	                // will be empty when loop finishes.
	                this.removeAssetFromDict(asset, false);
	            }
	            else {
	                this._assets[idx++] = asset;
	            }
	        }
	        /*
	         for each (asset in old_assets) {
	         // Remove from dict if in the supplied namespace. If not,
	         // transfer over to the new vector.
	         if (asset.assetNamespace == ns) {
	         if (dispose)
	         asset.dispose();

	         // Remove asset from dictionary, but don't try to auto-remove
	         // the namespace, which will trigger an unnecessarily expensive
	         // test that is not needed since we know that the namespace
	         // will be empty when loop finishes.
	         removeAssetFromDict(asset, false);
	         } else
	         _assets[idx++] = asset;

	         }
	         */
	        // Remove empty namespace
	        if (this._assetDictionary.hasOwnProperty(ns))
	            delete this._assetDictionary[ns];
	    };
	    AssetLibraryBundle.prototype.removeAssetFromDict = function (asset, autoRemoveEmptyNamespace) {
	        if (autoRemoveEmptyNamespace === void 0) { autoRemoveEmptyNamespace = true; }
	        if (this._assetDictDirty)
	            this.rehashAssetDict();
	        if (this._assetDictionary.hasOwnProperty(asset.assetNamespace)) {
	            if (this._assetDictionary[asset.assetNamespace].hasOwnProperty(asset.name))
	                delete this._assetDictionary[asset.assetNamespace][asset.name];
	            if (autoRemoveEmptyNamespace) {
	                var key;
	                var empty = true;
	                for (key in this._assetDictionary[asset.assetNamespace]) {
	                    empty = false;
	                    break;
	                }
	                if (empty)
	                    delete this._assetDictionary[asset.assetNamespace];
	            }
	        }
	    };
	    AssetLibraryBundle.prototype.stopAllLoaders = function () {
	        var len = this._loaderSessions.length;
	        for (var i = 0; i < len; i++)
	            this.killloaderSession(this._loaderSessions[i]);
	        this._loaderSessions = new Array();
	    };
	    AssetLibraryBundle.prototype.rehashAssetDict = function () {
	        var asset;
	        this._assetDictionary = {};
	        var len = this._assets.length;
	        for (var c = 0; c < len; c++) {
	            asset = this._assets[c];
	            if (!this._assetDictionary.hasOwnProperty(asset.assetNamespace))
	                this._assetDictionary[asset.assetNamespace] = {};
	            this._assetDictionary[asset.assetNamespace][asset.name] = asset;
	        }
	        this._assetDictDirty = false;
	    };
	    /**
	     * Called when a an error occurs during loading.
	     */
	    AssetLibraryBundle.prototype.onLoadError = function (event) {
	        if (this.hasEventListener(URLLoaderEvent_1.default.LOAD_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    /**
	     * Called when a an error occurs during parsing.
	     */
	    AssetLibraryBundle.prototype.onParseError = function (event) {
	        if (this.hasEventListener(ParserEvent_1.default.PARSE_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    AssetLibraryBundle.prototype.onAssetComplete = function (event) {
	        // Only add asset to library the first time.
	        if (event.type == AssetEvent_1.default.ASSET_COMPLETE)
	            this.addAsset(event.asset);
	        this.dispatchEvent(event);
	    };
	    AssetLibraryBundle.prototype.onTextureSizeError = function (event) {
	        this.dispatchEvent(event);
	    };
	    /**
	     * Called when the resource and all of its dependencies was retrieved.
	     */
	    AssetLibraryBundle.prototype.onResourceComplete = function (event) {
	        var loader = event.target;
	        this.dispatchEvent(event);
	        this.disposeLoader(loader);
	    };
	    AssetLibraryBundle.prototype.loaderSessionGC = function () {
	        var loader;
	        while (this._loaderSessionsGarbage.length > 0) {
	            loader = this._loaderSessionsGarbage.pop();
	            this.killloaderSession(loader);
	        }
	        clearTimeout(this._gcTimeoutIID);
	        this._gcTimeoutIID = null;
	    };
	    AssetLibraryBundle.prototype.killloaderSession = function (loader) {
	        loader.removeEventListener(LoaderEvent_1.default.LOAD_COMPLETE, this._onResourceCompleteDelegate);
	        loader.removeEventListener(AssetEvent_1.default.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        loader.removeEventListener(AssetEvent_1.default.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        loader.stop();
	    };
	    AssetLibraryBundle.prototype.onAssetRename = function (event) {
	        var asset = event.target; // TODO: was ev.currentTarget - watch this var
	        var old = this.getAsset(asset.assetNamespace, asset.name);
	        if (old != null) {
	            this._strategy.resolveConflict(asset, old, this._assetDictionary[asset.assetNamespace], this._strategyPreference);
	        }
	        else {
	            var dict = this._assetDictionary[event.asset.assetNamespace];
	            if (dict == null)
	                return;
	            dict[event.prevName] = null;
	            dict[event.asset.name] = event.asset;
	        }
	    };
	    AssetLibraryBundle.prototype.onAssetConflictResolved = function (event) {
	        this.dispatchEvent(event.clone());
	    };
	    AssetLibraryBundle._iInstances = new Object();
	    return AssetLibraryBundle;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AssetLibraryBundle;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	var AssetLibraryIterator = (function () {
	    function AssetLibraryIterator(assets, assetTypeFilter, namespaceFilter, filterFunc) {
	        this._assets = assets;
	        this.filter(assetTypeFilter, namespaceFilter, filterFunc);
	    }
	    Object.defineProperty(AssetLibraryIterator.prototype, "currentAsset", {
	        get: function () {
	            // Return current, or null if no current
	            return (this._idx < this._filtered.length) ? this._filtered[this._idx] : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibraryIterator.prototype, "numAssets", {
	        get: function () {
	            return this._filtered.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AssetLibraryIterator.prototype.next = function () {
	        var next = null;
	        if (this._idx < this._filtered.length)
	            next = this._filtered[this._idx];
	        this._idx++;
	        return next;
	    };
	    AssetLibraryIterator.prototype.reset = function () {
	        this._idx = 0;
	    };
	    AssetLibraryIterator.prototype.setIndex = function (index) {
	        this._idx = index;
	    };
	    AssetLibraryIterator.prototype.filter = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter || namespaceFilter) {
	            var idx;
	            var asset;
	            idx = 0;
	            this._filtered = new Array(); //new Vector.<IAsset>;
	            var l = this._assets.length;
	            for (var c = 0; c < l; c++) {
	                asset = this._assets[c];
	                // Skip this assets if filtering on type and this is wrong type
	                if (assetTypeFilter && asset.assetType != assetTypeFilter)
	                    continue;
	                // Skip this asset if filtering on namespace and this is wrong namespace
	                if (namespaceFilter && asset.assetNamespace != namespaceFilter)
	                    continue;
	                // Skip this asset if a filter func has been provided and it returns false
	                if (filterFunc != null && !filterFunc(asset))
	                    continue;
	                this._filtered[idx++] = asset;
	            }
	        }
	        else {
	            this._filtered = this._assets;
	        }
	    };
	    return AssetLibraryIterator;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AssetLibraryIterator;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoader_1 = __webpack_require__(8);
	var URLLoaderDataFormat_1 = __webpack_require__(9);
	var AssetEvent_1 = __webpack_require__(1);
	var EventDispatcher_1 = __webpack_require__(12);
	var URLLoaderEvent_1 = __webpack_require__(13);
	var LoaderEvent_1 = __webpack_require__(3);
	var ParserEvent_1 = __webpack_require__(14);
	var ResourceDependency_1 = __webpack_require__(15);
	/**
	 * Dispatched when any asset finishes parsing. Also see specific events for each
	 * individual asset type (meshes, materials et c.)
	 *
	 * @eventType away.events.AssetEvent
	 */
	//[Event(name="assetComplete", type="away3d.events.AssetEvent")]
	/**
	 * Dispatched when a full resource (including dependencies) finishes loading.
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when a single dependency (which may be the main file of a resource)
	 * finishes loading.
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when an error occurs during loading. I
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="loadError", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when an error occurs during parsing.
	 *
	 * @eventType away.events.ParserEvent
	 */
	//[Event(name="parseError", type="away3d.events.ParserEvent")]
	/**
	 * Dispatched when an image asset dimensions are not a power of 2
	 *
	 * @eventType away.events.AssetEvent
	 */
	//[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
	/**
	 * Loader can load any file format that away.supports (or for which a third-party parser
	 * has been plugged in) and it's dependencies. Events are dispatched when assets are encountered
	 * and for when the resource (or it's dependencies) have been loaded.
	 *
	 * The Loader will not make assets available in any other way than through the dispatched
	 * events. To store assets and make them available at any point from any module in an application,
	 * use the AssetLibrary to load and manage assets.
	 *
	 * @see away.library.AssetLibrary
	 */
	var Loader = (function (_super) {
	    __extends(Loader, _super);
	    /**
	     * Create a new ResourceLoadSession object.
	     */
	    function Loader(materialMode) {
	        var _this = this;
	        if (materialMode === void 0) { materialMode = 0; }
	        _super.call(this);
	        this._materialMode = materialMode;
	        this._stack = new Array();
	        this._errorHandlers = new Array();
	        this._parseErrorHandlers = new Array();
	        this._onReadyForDependenciesDelegate = function (event) { return _this.onReadyForDependencies(event); };
	        this._onParseCompleteDelegate = function (event) { return _this.onParseComplete(event); };
	        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
	        this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
	        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
	        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
	        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
	    }
	    /**
	     * Enables a specific parser.
	     * When no specific parser is set for a loading/parsing opperation,
	     * loader3d can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parser The parser class to enable.
	     *
	     * @see away.parsers.Parsers
	     */
	    Loader.enableParser = function (parser) {
	        if (Loader._parsers.indexOf(parser) < 0)
	            Loader._parsers.push(parser);
	    };
	    /**
	     * Enables a list of parsers.
	     * When no specific parser is set for a loading/parsing opperation,
	     * Loader can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parsers A Vector of parser classes to enable.
	     * @see away.parsers.Parsers
	     */
	    Loader.enableParsers = function (parsers) {
	        for (var c = 0; c < parsers.length; c++)
	            Loader.enableParser(parsers[c]);
	    };
	    Object.defineProperty(Loader.prototype, "baseDependency", {
	        /**
	         * Returns the base dependency of the loader
	         */
	        get: function () {
	            return this._baseDependency;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Loader.prototype, "loaderInfo", {
	        /**
	         * Returns a LoaderInfo object corresponding to the object being loaded.
	         * LoaderInfo objects are shared between the Loader object and the loaded
	         * content object. The LoaderInfo object supplies loading progress
	         * information and statistics about the loaded file.
	         *
	         * <p>Events related to the load are dispatched by the LoaderInfo object
	         * referenced by the <code>contentLoaderInfo</code> property of the Loader
	         * object. The <code>contentLoaderInfo</code> property is set to a valid
	         * LoaderInfo object, even before the content is loaded, so that you can add
	         * event listeners to the object prior to the load.</p>
	         *
	         * <p>To detect uncaught errors that happen in a loaded SWF, use the
	         * <code>Loader.uncaughtErrorEvents</code> property, not the
	         * <code>Loader.contentLoaderInfo.uncaughtErrorEvents</code> property.</p>
	         */
	        get: function () {
	            return this._loaderInfo;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Loads a file and (optionally) all of its dependencies.
	     *
	     * @param req The URLRequest object containing the URL of the file to be loaded.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     */
	    Loader.prototype.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._uri = req.url = req.url.replace(/\\/g, "/");
	        this._context = context;
	        this._namespace = ns;
	        this._baseDependency = new ResourceDependency_1.default('', req, null, parser, null);
	        this.retrieveDependency(this._baseDependency);
	    };
	    /**
	     * Loads a resource from already loaded data.
	     *
	     * @param data The data object containing all resource information.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     */
	    Loader.prototype.loadData = function (data, id, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._uri = id;
	        this._context = context;
	        this._namespace = ns;
	        this._baseDependency = new ResourceDependency_1.default(id, null, data, parser, null);
	        this.retrieveDependency(this._baseDependency);
	    };
	    /**
	     * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the
	     * stack when complete and continues on the top set.
	     * @param parser The parser that will translate the data into a usable resource.
	     */
	    Loader.prototype.retrieveNext = function (parser) {
	        if (parser === void 0) { parser = null; }
	        if (this._currentDependency.dependencies.length) {
	            var next = this._currentDependency.dependencies.pop();
	            this._stack.push(this._currentDependency);
	            this.retrieveDependency(next);
	        }
	        else if (this._currentDependency.parser && this._currentDependency.parser.parsingPaused) {
	            this._currentDependency.parser._iResumeParsing();
	            this._stack.pop();
	        }
	        else if (this._stack.length) {
	            var prev = this._currentDependency;
	            this._currentDependency = this._stack.pop();
	            if (prev._iSuccess)
	                prev.resolve();
	            this.retrieveNext(parser);
	        }
	        else {
	            this.dispatchEvent(new LoaderEvent_1.default(LoaderEvent_1.default.LOAD_COMPLETE, this._uri, this._baseDependency.parser.content, this._baseDependency.assets));
	        }
	    };
	    /**
	     * Retrieves a single dependency.
	     * @param parser The parser that will translate the data into a usable resource.
	     */
	    Loader.prototype.retrieveDependency = function (dependency) {
	        var data;
	        if (this._context && this._context.materialMode != 0)
	            this._materialMode = this._context.materialMode;
	        this._currentDependency = dependency;
	        dependency._iLoader = new URLLoader_1.default();
	        this.addEventListeners(dependency._iLoader);
	        // Get already loaded (or mapped) data if available
	        data = dependency.data;
	        if (this._context && dependency.request && this._context._iHasDataForUrl(dependency.request.url))
	            data = this._context._iGetDataForUrl(dependency.request.url);
	        if (data) {
	            if (data.constructor === Function)
	                data = new data();
	            dependency._iSetData(data);
	            if (dependency.retrieveAsRawData) {
	                // No need to parse. The parent parser is expecting this
	                // to be raw data so it can be passed directly.
	                dependency.resolve();
	                // Move on to next dependency
	                this.retrieveNext();
	            }
	            else {
	                this.parseDependency(dependency);
	            }
	        }
	        else {
	            // Resolve URL and start loading
	            dependency.request.url = this.resolveDependencyUrl(dependency);
	            if (dependency.retrieveAsRawData) {
	                // Always use binary for raw data loading
	                dependency._iLoader.dataFormat = URLLoaderDataFormat_1.default.BINARY;
	            }
	            else {
	                if (!dependency.parser)
	                    dependency._iSetParser(this.getParserFromSuffix(dependency.request.url));
	                if (dependency.parser) {
	                    dependency._iLoader.dataFormat = dependency.parser.dataFormat;
	                }
	                else {
	                    // Always use BINARY for unknown file formats. The thorough
	                    // file type check will determine format after load, and if
	                    // binary, a text load will have broken the file data.
	                    dependency._iLoader.dataFormat = URLLoaderDataFormat_1.default.BINARY;
	                }
	            }
	            dependency._iLoader.load(dependency.request);
	        }
	    };
	    Loader.prototype.joinUrl = function (base, end) {
	        if (end.charAt(0) == '/' || end.charAt(0) == '\\')
	            end = end.substr(1);
	        if (end.charAt(0) == '.')
	            end = end.substr(2);
	        if (base.length == 0)
	            return end;
	        if (base.charAt(base.length - 1) == '/' || base.charAt(base.length - 1) == '\\')
	            base = base.substr(0, base.length - 1);
	        return base.concat('/', end);
	    };
	    Loader.prototype.resolveDependencyUrl = function (dependency) {
	        var scheme_re;
	        var base;
	        var url = dependency.request.url;
	        // Has the user re-mapped this URL?
	        if (this._context && this._context._iHasMappingForUrl(url))
	            return this._context._iGetRemappedUrl(url);
	        // This is the "base" dependency, i.e. the actual requested asset.
	        // We will not try to resolve this since the user can probably be
	        // thrusted to know this URL better than our automatic resolver. :)
	        if (url == this._uri)
	            return url;
	        // Absolute URL? Check if starts with slash or a URL
	        // scheme definition (e.g. ftp://, http://, file://)
	        scheme_re = new RegExp('/^[a-zA-Z]{3,4}:\/\//');
	        if (url.charAt(0) == '/') {
	            if (this._context && this._context.overrideAbsolutePaths)
	                return this.joinUrl(this._context.dependencyBaseUrl, url);
	            else
	                return url;
	        }
	        else if (scheme_re.test(url)) {
	            // If overriding full URLs, get rid of scheme (e.g. "http://")
	            // and replace with the dependencyBaseUrl defined by user.
	            if (this._context && this._context.overrideFullURLs) {
	                var noscheme_url = url.replace(scheme_re, ''); //url['replace'](scheme_re);
	                return this.joinUrl(this._context.dependencyBaseUrl, noscheme_url);
	            }
	        }
	        // Since not absolute, just get rid of base file name to find it's
	        // folder and then concatenate dynamic URL
	        if (this._context && this._context.dependencyBaseUrl) {
	            base = this._context.dependencyBaseUrl;
	            return this.joinUrl(base, url);
	        }
	        else {
	            base = this._uri.substring(0, this._uri.lastIndexOf('/') + 1);
	            return this.joinUrl(base, url);
	        }
	    };
	    Loader.prototype.retrieveParserDependencies = function () {
	        if (!this._currentDependency)
	            return;
	        var parserDependancies = this._currentDependency.parser.dependencies;
	        var i, len = parserDependancies.length;
	        for (i = 0; i < len; i++)
	            this._currentDependency.dependencies[i] = parserDependancies[i];
	        // Since more dependencies might be added eventually, empty this
	        // list so that the same dependency isn't retrieved more than once.
	        parserDependancies.length = 0;
	        this._stack.push(this._currentDependency);
	        this.retrieveNext();
	    };
	    Loader.prototype.resolveParserDependencies = function () {
	        this._currentDependency._iSuccess = true;
	        // Retrieve any last dependencies remaining on this parser, or
	        // if none exists, just move on.
	        if (this._currentDependency.parser && this._currentDependency.parser.dependencies.length && (!this._context || this._context.includeDependencies))
	            this.retrieveParserDependencies();
	        else
	            this.retrieveNext();
	    };
	    /**
	     * Called when a single dependency loading failed, and pushes further dependencies onto the stack.
	     * @param event
	     */
	    Loader.prototype.onLoadError = function (event) {
	        var handled;
	        var isDependency = (this._currentDependency != this._baseDependency);
	        var loader = event.urlLoader;
	        this.removeEventListeners(loader);
	        if (this.hasEventListener(URLLoaderEvent_1.default.LOAD_ERROR)) {
	            this.dispatchEvent(event);
	            handled = true;
	        }
	        else {
	            // TODO: Consider not doing this even when Loader does have it's own LOAD_ERROR listener
	            var i, len = this._errorHandlers.length;
	            for (i = 0; i < len; i++)
	                if (!handled)
	                    handled = this._errorHandlers[i](event);
	        }
	        if (handled) {
	            //if (isDependency && ! event.isDefaultPrevented()) {
	            if (isDependency) {
	                this._currentDependency.resolveFailure();
	                this.retrieveNext();
	            }
	            else {
	                // Either this was the base file (last left in the stack) or
	                // default behavior was prevented by the handlers, and hence
	                // there is nothing more to do than clean up and bail.
	                this.dispose();
	                return;
	            }
	        }
	        else {
	            // Error event was not handled by listeners directly on Loader or
	            // on any of the subscribed loaders (in the list of error handlers.)
	            throw new Error();
	        }
	    };
	    /**
	     * Called when a dependency parsing failed, and dispatches a <code>ParserEvent.PARSE_ERROR</code>
	     * @param event
	     */
	    Loader.prototype.onParseError = function (event) {
	        var handled;
	        var isDependency = (this._currentDependency != this._baseDependency);
	        var loader = event.target;
	        this.removeEventListeners(loader);
	        if (this.hasEventListener(ParserEvent_1.default.PARSE_ERROR)) {
	            this.dispatchEvent(event);
	            handled = true;
	        }
	        else {
	            // TODO: Consider not doing this even when Loader does
	            // have it's own LOAD_ERROR listener
	            var i, len = this._parseErrorHandlers.length;
	            for (i = 0; i < len; i++)
	                if (!handled)
	                    handled = this._parseErrorHandlers[i](event);
	        }
	        if (handled) {
	            this.retrieveNext();
	        }
	        else {
	            // Error event was not handled by listeners directly on Loader or
	            // on any of the subscribed loaders (in the list of error handlers.)
	            throw new Error(event.message);
	        }
	    };
	    Loader.prototype.onAssetComplete = function (event) {
	        // Add loaded asset to list of assets retrieved as part
	        // of the current dependency. This list will be inspected
	        // by the parent parser when dependency is resolved
	        if (this._currentDependency)
	            this._currentDependency.assets.push(event.asset);
	        event.asset.resetAssetPath(event.asset.name, this._namespace);
	        if (!this._currentDependency.suppresAssetEvents)
	            this.dispatchEvent(event);
	    };
	    Loader.prototype.onReadyForDependencies = function (event) {
	        var parser = event.target;
	        if (this._context && !this._context.includeDependencies)
	            parser._iResumeParsing();
	        else
	            this.retrieveParserDependencies();
	    };
	    /**
	     * Called when a single dependency was parsed, and pushes further dependencies onto the stack.
	     * @param event
	     */
	    Loader.prototype.onLoadComplete = function (event) {
	        var loader = event.urlLoader;
	        this.removeEventListeners(loader);
	        // Resolve this dependency
	        this._currentDependency._iSetData(loader.data);
	        if (this._currentDependency.retrieveAsRawData) {
	            // No need to parse this data, which should be returned as is
	            this.resolveParserDependencies();
	        }
	        else {
	            this.parseDependency(this._currentDependency);
	        }
	    };
	    /**
	     * Called when parsing is complete.
	     */
	    Loader.prototype.onParseComplete = function (event) {
	        var parser = event.target;
	        this.resolveParserDependencies(); //resolve in front of removing listeners to allow any remaining asset events to propagate
	        parser.removeEventListener(ParserEvent_1.default.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
	        parser.removeEventListener(ParserEvent_1.default.PARSE_COMPLETE, this._onParseCompleteDelegate);
	        parser.removeEventListener(ParserEvent_1.default.PARSE_ERROR, this._onParseErrorDelegate);
	        parser.removeEventListener(AssetEvent_1.default.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        parser.removeEventListener(AssetEvent_1.default.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	    };
	    /**
	     * Called when an image is too large or it's dimensions are not a power of 2
	     * @param event
	     */
	    Loader.prototype.onTextureSizeError = function (event) {
	        event.asset.name = this._currentDependency.resolveName(event.asset);
	        this.dispatchEvent(event);
	    };
	    Loader.prototype.addEventListeners = function (loader) {
	        loader.addEventListener(URLLoaderEvent_1.default.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        loader.addEventListener(URLLoaderEvent_1.default.LOAD_ERROR, this._onLoadErrorDelegate);
	    };
	    Loader.prototype.removeEventListeners = function (loader) {
	        loader.removeEventListener(URLLoaderEvent_1.default.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        loader.removeEventListener(URLLoaderEvent_1.default.LOAD_ERROR, this._onLoadErrorDelegate);
	    };
	    Loader.prototype.stop = function () {
	        this.dispose();
	    };
	    Loader.prototype.dispose = function () {
	        this._errorHandlers = null;
	        this._parseErrorHandlers = null;
	        this._context = null;
	        this._stack = null;
	        if (this._currentDependency && this._currentDependency._iLoader)
	            this.removeEventListeners(this._currentDependency._iLoader);
	        this._currentDependency = null;
	    };
	    /**
	     * @private
	     * This method is used by other loader classes (e.g. Loader3D and AssetLibraryBundle) to
	     * add error event listeners to the Loader instance. This system is used instead of
	     * the regular EventDispatcher system so that the AssetLibrary error handler can be sure
	     * that if hasEventListener() returns true, it's client code that's listening for the
	     * event. Secondly, functions added as error handler through this custom method are
	     * expected to return a boolean value indicating whether the event was handled (i.e.
	     * whether they in turn had any client code listening for the event.) If no handlers
	     * return true, the Loader knows that the event wasn't handled and will throw an RTE.
	     */
	    Loader.prototype._iAddParseErrorHandler = function (handler) {
	        if (this._parseErrorHandlers.indexOf(handler) < 0)
	            this._parseErrorHandlers.push(handler);
	    };
	    Loader.prototype._iAddErrorHandler = function (handler) {
	        if (this._errorHandlers.indexOf(handler) < 0)
	            this._errorHandlers.push(handler);
	    };
	    /**
	     * Guesses the parser to be used based on the file contents.
	     * @param data The data to be parsed.
	     * @param uri The url or id of the object to be parsed.
	     * @return An instance of the guessed parser.
	     */
	    Loader.prototype.getParserFromData = function (data) {
	        var len = Loader._parsers.length;
	        // go in reverse order to allow application override of default parser added in away.proper
	        for (var i = len - 1; i >= 0; i--)
	            if (Loader._parsers[i].supportsData(data))
	                return new Loader._parsers[i]();
	        return null;
	    };
	    /**
	     * Initiates parsing of the loaded dependency.
	     *
	     * @param The dependency to be parsed.
	     */
	    Loader.prototype.parseDependency = function (dependency) {
	        var parser = dependency.parser;
	        // If no parser has been defined, try to find one by letting
	        // all plugged in parsers inspect the actual data.
	        if (!parser)
	            dependency._iSetParser(parser = this.getParserFromData(dependency.data));
	        if (parser) {
	            parser.addEventListener(ParserEvent_1.default.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
	            parser.addEventListener(ParserEvent_1.default.PARSE_COMPLETE, this._onParseCompleteDelegate);
	            parser.addEventListener(ParserEvent_1.default.PARSE_ERROR, this._onParseErrorDelegate);
	            parser.addEventListener(AssetEvent_1.default.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	            parser.addEventListener(AssetEvent_1.default.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	            if (dependency.request && dependency.request.url)
	                parser._iFileName = dependency.request.url;
	            parser.materialMode = this._materialMode;
	            parser.parseAsync(dependency.data);
	        }
	        else {
	            var handled;
	            var message = "No parser defined. To enable all parsers for auto-detection, use Parsers.enableAllBundled()";
	            var event = new ParserEvent_1.default(ParserEvent_1.default.PARSE_ERROR, message);
	            if (this.hasEventListener(ParserEvent_1.default.PARSE_ERROR)) {
	                this.dispatchEvent(event);
	                handled = true;
	            }
	            else {
	                // TODO: Consider not doing this even when Loader does
	                // have it's own LOAD_ERROR listener
	                var i, len = this._parseErrorHandlers.length;
	                for (i = 0; i < len; i++)
	                    if (!handled)
	                        handled = this._parseErrorHandlers[i](event);
	            }
	            if (handled) {
	                this.retrieveNext();
	            }
	            else {
	                // Error event was not handled by listeners directly on Loader or
	                // on any of the subscribed loaders (in the list of error handlers.)
	                throw new Error(message);
	            }
	        }
	    };
	    /**
	     * Guesses the parser to be used based on the file extension.
	     * @return An instance of the guessed parser.
	     */
	    Loader.prototype.getParserFromSuffix = function (url) {
	        // Get rid of query string if any and extract extension
	        var base = (url.indexOf('?') > 0) ? url.split('?')[0] : url;
	        var fileExtension = base.substr(base.lastIndexOf('.') + 1).toLowerCase();
	        var len = Loader._parsers.length;
	        // go in reverse order to allow application override of default parser added in away.proper
	        for (var i = len - 1; i >= 0; i--) {
	            var parserClass = Loader._parsers[i];
	            if (parserClass.supportsType(fileExtension))
	                return new parserClass();
	        }
	        return null;
	    };
	    // Image parser only parser that is added by default, to save file size.
	    Loader._parsers = new Array();
	    return Loader;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Loader;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoaderDataFormat_1 = __webpack_require__(9);
	var URLRequestMethod_1 = __webpack_require__(10);
	var URLVariables_1 = __webpack_require__(11);
	var EventDispatcher_1 = __webpack_require__(12);
	var URLLoaderEvent_1 = __webpack_require__(13);
	/**
	 * The URLLoader is used to load a single file, as part of a resource.
	 *
	 * While URLLoader can be used directly, e.g. to create a third-party asset
	 * management system, it's recommended to use any of the classes Loader3D, Loader
	 * and AssetLibrary instead in most cases.
	 *
	 * @see Loader
	 * @see away.library.AssetLibrary
	 */
	var URLLoader = (function (_super) {
	    __extends(URLLoader, _super);
	    /**
	     * Creates a new URLLoader object.
	     */
	    function URLLoader() {
	        _super.call(this);
	        this._bytesLoaded = 0;
	        this._bytesTotal = 0;
	        this._dataFormat = URLLoaderDataFormat_1.default.TEXT;
	        this._loadError = false;
	    }
	    Object.defineProperty(URLLoader.prototype, "url", {
	        /**
	         *
	         */
	        get: function () {
	            return this._request ? this._request.url : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "data", {
	        /**
	         *
	         */
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "dataFormat", {
	        get: function () {
	            return this._dataFormat;
	        },
	        /**
	         *
	         * URLLoaderDataFormat.BINARY
	         * URLLoaderDataFormat.TEXT
	         * URLLoaderDataFormat.VARIABLES
	         *
	         * @param format
	         */
	        set: function (format) {
	            this._dataFormat = format;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._bytesLoaded;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "bytesTotal", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._bytesTotal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Load a resource from a file.
	     *
	     * @param request The URLRequest object containing the URL of the object to be loaded.
	     */
	    URLLoader.prototype.load = function (request) {
	        this._request = request;
	        this.initXHR();
	        if (request.method === URLRequestMethod_1.default.POST)
	            this.postRequest(request);
	        else
	            this.getRequest(request);
	    };
	    URLLoader.prototype.isSupported = function () {
	        return window != null;
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.close = function () {
	        this._XHR.abort();
	        this.disposeXHR();
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.dispose = function () {
	        if (this._XHR)
	            this._XHR.abort();
	        this.disposeXHR();
	    };
	    /**
	     *
	     * @param xhr
	     * @param responseType
	     */
	    URLLoader.prototype.setResponseType = function (xhr, responseType) {
	        switch (responseType) {
	            case URLLoaderDataFormat_1.default.ARRAY_BUFFER:
	            case URLLoaderDataFormat_1.default.BLOB:
	            case URLLoaderDataFormat_1.default.TEXT:
	                xhr.responseType = responseType;
	                break;
	            case URLLoaderDataFormat_1.default.VARIABLES:
	                xhr.responseType = URLLoaderDataFormat_1.default.TEXT;
	                break;
	            case URLLoaderDataFormat_1.default.BINARY:
	                xhr.responseType = '';
	                break;
	            default:
	        }
	    };
	    /**
	     *
	     * @param request {URLRequest}
	     */
	    URLLoader.prototype.getRequest = function (request) {
	        try {
	            this._XHR.open(request.method, request.url, request.async);
	            this.setResponseType(this._XHR, this._dataFormat);
	            this._XHR.send(); // No data to send
	        }
	        catch (e /* <XMLHttpRequestException> */) {
	            this.handleXmlHttpRequestException(e);
	        }
	    };
	    /**
	     *
	     * @param request {URLRequest}
	     */
	    URLLoader.prototype.postRequest = function (request) {
	        this._loadError = false;
	        this._XHR.open(request.method, request.url, request.async);
	        if (request.data != null) {
	            if (request.data instanceof URLVariables_1.default) {
	                var urlVars = request.data;
	                try {
	                    this._XHR.responseType = 'text';
	                    this._XHR.send(urlVars.formData);
	                }
	                catch (e /* <XMLHttpRequestException> */) {
	                    this.handleXmlHttpRequestException(e);
	                }
	            }
	            else {
	                this.setResponseType(this._XHR, this._dataFormat);
	                if (request.data)
	                    this._XHR.send(request.data); // TODO: Test
	                else
	                    this._XHR.send(); // no data to send
	            }
	        }
	        else {
	            this._XHR.send(); // No data to send
	        }
	    };
	    /**
	     *
	     * @param error {XMLHttpRequestException}
	     */
	    URLLoader.prototype.handleXmlHttpRequestException = function (error /* <XMLHttpRequestException> */) {
	        switch (error.code) {
	            /******************************************************************************************************************************************************************************************************
	             *
	             *  XMLHttpRequestException { message: "NETWORK_ERR: XMLHttpRequest Exception 101", name: "NETWORK_ERR", code: 101, stack: "Error: A network error occurred in synchronous req…",NETWORK_ERR: 101… }
	             *  code: 101 , message: "NETWORK_ERR: XMLHttpRequest Exception 101" ,  name: "NETWORK_ERR"
	             *
	             ******************************************************************************************************************************************************************************************************/
	            case 101:
	                // Note: onLoadError event throws IO_ERROR event - this case is already Covered
	                break;
	        }
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.initXHR = function () {
	        var _this = this;
	        if (!this._XHR) {
	            this._XHR = new XMLHttpRequest();
	            this._XHR.onloadstart = function (event) { return _this.onLoadStart(event); }; // loadstart	        - When the request starts.
	            this._XHR.onprogress = function (event) { return _this.onProgress(event); }; // progress	            - While loading and sending data.
	            this._XHR.onabort = function (event) { return _this.onAbort(event); }; // abort	            - When the request has been aborted, either by invoking the abort() method or navigating away from the page.
	            this._XHR.onerror = function (event) { return _this.onLoadError(event); }; // error	            - When the request has failed.
	            this._XHR.onload = function (event) { return _this.onLoadComplete(event); }; // load	                - When the request has successfully completed.
	            this._XHR.ontimeout = function (event) { return _this.onTimeOut(event); }; // timeout	            - When the author specified timeout has passed before the request could complete.
	            this._XHR.onloadend = function (event) { return _this.onLoadEnd(event); }; // loadend	            - When the request has completed, regardless of whether or not it was successful.
	            this._XHR.onreadystatechange = function (event) { return _this.onReadyStateChange(event); }; // onreadystatechange   - When XHR state changes
	        }
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.disposeXHR = function () {
	        if (this._XHR !== null) {
	            this._XHR.onloadstart = null;
	            this._XHR.onprogress = null;
	            this._XHR.onabort = null;
	            this._XHR.onerror = null;
	            this._XHR.onload = null;
	            this._XHR.ontimeout = null;
	            this._XHR.onloadend = null;
	            this._XHR = null;
	        }
	    };
	    /**
	     *
	     * @param source
	     */
	    URLLoader.prototype.decodeURLVariables = function (source) {
	        var result = new Object();
	        source = source.split("+").join(" ");
	        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
	        while (tokens = re.exec(source))
	            result[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
	        return result;
	    };
	    // XMLHttpRequest - Event Handlers
	    /**
	     * When XHR state changes
	     * @param event
	     */
	    URLLoader.prototype.onReadyStateChange = function (event) {
	        if (this._XHR.readyState == 4) {
	            this._status = this._XHR.status;
	            if (this._status == 404) {
	                this._loadError = true;
	                this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.LOAD_ERROR, this)));
	            }
	            this.dispatchEvent(this._statusEvent || (this._statusEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.HTTP_STATUS, this)));
	        }
	    };
	    /**
	     * When the request has completed, regardless of whether or not it was successful.
	     * @param event
	     */
	    URLLoader.prototype.onLoadEnd = function (event) {
	        if (this._loadError === true)
	            return;
	    };
	    /**
	     * When the author specified timeout has passed before the request could complete.
	     * @param event
	     */
	    URLLoader.prototype.onTimeOut = function (event) {
	        //TODO: Timeout not currently implemented ( also not part of AS3 API )
	    };
	    /**
	     * When the request has been aborted, either by invoking the abort() method or navigating away from the page.
	     * @param event
	     */
	    URLLoader.prototype.onAbort = function (event) {
	        // TODO: investigate whether this needs to be an IOError
	    };
	    /**
	     * While loading and sending data.
	     * @param event
	     */
	    URLLoader.prototype.onProgress = function (event) {
	        this._bytesTotal = event.total;
	        this._bytesLoaded = event.loaded;
	        this.dispatchEvent(this._progressEvent || (this._progressEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.LOAD_PROGRESS, this)));
	    };
	    /**
	     * When the request starts.
	     * @param event
	     */
	    URLLoader.prototype.onLoadStart = function (event) {
	        this.dispatchEvent(this._loadStartEvent || (this._loadStartEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.LOAD_START, this)));
	    };
	    /**
	     * When the request has successfully completed.
	     * @param event
	     */
	    URLLoader.prototype.onLoadComplete = function (event) {
	        if (this._loadError === true)
	            return;
	        switch (this._dataFormat) {
	            case URLLoaderDataFormat_1.default.TEXT:
	                this._data = this._XHR.responseText;
	                break;
	            case URLLoaderDataFormat_1.default.VARIABLES:
	                this._data = this.decodeURLVariables(this._XHR.responseText);
	                break;
	            case URLLoaderDataFormat_1.default.BLOB:
	            case URLLoaderDataFormat_1.default.ARRAY_BUFFER:
	            case URLLoaderDataFormat_1.default.BINARY:
	                this._data = this._XHR.response;
	                break;
	            default:
	                this._data = this._XHR.responseText;
	                break;
	        }
	        this.dispatchEvent(this._loadCompleteEvent || (this._loadCompleteEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.LOAD_COMPLETE, this)));
	    };
	    /**
	     * When the request has failed. ( due to network issues ).
	     * @param event
	     */
	    URLLoader.prototype.onLoadError = function (event) {
	        this._loadError = true;
	        this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent_1.default(URLLoaderEvent_1.default.LOAD_ERROR, this)));
	    };
	    return URLLoader;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLLoader;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	var URLLoaderDataFormat = (function () {
	    function URLLoaderDataFormat() {
	    }
	    /**
	     * TEXT
	     * @type {string}
	     */
	    URLLoaderDataFormat.TEXT = "text";
	    /**
	     * Variables / Value Pairs
	     * @type {string}
	     */
	    URLLoaderDataFormat.VARIABLES = "variables";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.BLOB = "blob";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.ARRAY_BUFFER = "arraybuffer";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.BINARY = "binary";
	    return URLLoaderDataFormat;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLLoaderDataFormat;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	var URLRequestMethod = (function () {
	    function URLRequestMethod() {
	    }
	    /**
	     *
	     * @type {string}
	     */
	    URLRequestMethod.POST = 'POST';
	    /**
	     *
	     * @type {string}
	     */
	    URLRequestMethod.GET = 'GET';
	    return URLRequestMethod;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLRequestMethod;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	var URLVariables = (function () {
	    /**
	     *
	     * @param source
	     */
	    function URLVariables(source) {
	        if (source === void 0) { source = null; }
	        this._variables = new Object();
	        if (source !== null)
	            this.decode(source);
	    }
	    /**
	     *
	     * @param source
	     */
	    URLVariables.prototype.decode = function (source) {
	        source = source.split("+").join(" ");
	        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
	        while (tokens = re.exec(source))
	            this._variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
	    };
	    /**
	     *
	     * @returns {string}
	     */
	    URLVariables.prototype.toString = function () {
	        return '';
	    };
	    Object.defineProperty(URLVariables.prototype, "variables", {
	        /**
	         *
	         * @returns {Object}
	         */
	        get: function () {
	            return this._variables;
	        },
	        /**
	         *
	         * @returns {Object}
	         */
	        set: function (obj) {
	            this._variables = obj;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLVariables.prototype, "formData", {
	        /**
	         *
	         * @returns {Object}
	         */
	        get: function () {
	            var fd = new FormData();
	            for (var s in this._variables)
	                fd.append(s, this._variables[s]);
	            return fd;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return URLVariables;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLVariables;


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Base class for dispatching events
	*
	* @class away.events.EventDispatcher
	*
	*/
	var EventDispatcher = (function () {
	    function EventDispatcher(target) {
	        if (target === void 0) { target = null; }
	        this.listenerObjects = new Array();
	        this.target = target || this;
	    }
	    /**
	     * Add an event listener
	     * @method addEventListener
	     * @param {String} Name of event to add a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.addEventListener = function (type, listener) {
	        var l = this.listenerObjects[type];
	        if (l === undefined)
	            l = this.listenerObjects[type] = new ListenerObject();
	        l.addEventListener(listener);
	    };
	    /**
	     * Remove an event listener
	     * @method removeEventListener
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.removeEventListener = function (type, listener) {
	        var l = this.listenerObjects[type];
	        if (l) {
	            l.removeEventListener(listener);
	            if (l.numListeners == 0)
	                delete this.listenerObjects[type];
	        }
	    };
	    /**
	     * Dispatch an event
	     * @method dispatchEvent
	     * @param {Event} Event to dispatch
	     */
	    EventDispatcher.prototype.dispatchEvent = function (event) {
	        var l = this.listenerObjects[event.type];
	        if (l) {
	            event.target = this.target;
	            l.dispatchEvent(event);
	        }
	    };
	    /**
	     * check if an object has an event listener assigned to it
	     * @method hasListener
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.hasEventListener = function (type, listener) {
	        if (this.listenerObjects[type] === undefined)
	            return false;
	        if (listener != null)
	            return this.listenerObjects[type].getEventListenerIndex(listener) !== -1;
	        return this.listenerObjects[type].numListeners > 0;
	    };
	    return EventDispatcher;
	}());
	var ListenerObject = (function () {
	    function ListenerObject() {
	        this.index = 0;
	        this.listeners = new Array();
	        this.numListeners = 0;
	    }
	    ListenerObject.prototype.addEventListener = function (listener) {
	        //check if listener already added
	        if (this.getEventListenerIndex(listener) !== -1)
	            return;
	        this.listeners.push(listener);
	        this.numListeners++;
	    };
	    ListenerObject.prototype.removeEventListener = function (listener) {
	        //check if listener exists
	        var index = this.getEventListenerIndex(listener);
	        if (index === -1)
	            return;
	        this.listeners.splice(index, 1);
	        if (index <= this.index)
	            this.index--;
	        this.numListeners--;
	    };
	    ListenerObject.prototype.dispatchEvent = function (event) {
	        var len = this.numListeners;
	        for (this.index = 0; this.index < len && this.index < this.numListeners; this.index++)
	            this.listeners[this.index](event);
	    };
	    /**
	     * get Event Listener Index in array. Returns -1 if no listener is added
	     * @method getEventListenerIndex
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    ListenerObject.prototype.getEventListenerIndex = function (listener) {
	        for (var index = 0; index < this.numListeners; index++)
	            if (listener == this.listeners[index])
	                return index;
	        return -1;
	    };
	    return ListenerObject;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EventDispatcher;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var URLLoaderEvent = (function (_super) {
	    __extends(URLLoaderEvent, _super);
	    function URLLoaderEvent(type, urlLoader) {
	        _super.call(this, type);
	        this._urlLoader = urlLoader;
	    }
	    Object.defineProperty(URLLoaderEvent.prototype, "urlLoader", {
	        /**
	         *
	         */
	        get: function () {
	            return this._urlLoader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    URLLoaderEvent.prototype.clone = function () {
	        return new URLLoaderEvent(this.type, this._urlLoader);
	    };
	    URLLoaderEvent.HTTP_STATUS = "httpStatus";
	    URLLoaderEvent.LOAD_ERROR = "loadError";
	    URLLoaderEvent.LOAD_PROGRESS = "loadProgress";
	    URLLoaderEvent.LOAD_START = "loadStart";
	    URLLoaderEvent.LOAD_COMPLETE = "loadComplete";
	    return URLLoaderEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLLoaderEvent;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var ParserEvent = (function (_super) {
	    __extends(ParserEvent, _super);
	    function ParserEvent(type, message) {
	        if (message === void 0) { message = ''; }
	        _super.call(this, type);
	        this._message = message;
	    }
	    Object.defineProperty(ParserEvent.prototype, "message", {
	        /**
	         * Additional human-readable message. Usually supplied for ParserEvent.PARSE_ERROR events.
	         */
	        get: function () {
	            return this._message;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParserEvent.prototype.clone = function () {
	        return new ParserEvent(this.type, this._message);
	    };
	    /**
	     * Dispatched when parsing of an asset completed.
	     */
	    ParserEvent.PARSE_COMPLETE = 'parseComplete';
	    /**
	     * Dispatched when an error occurs while parsing the data (e.g. because it's
	     * incorrectly formatted.)
	     */
	    ParserEvent.PARSE_ERROR = 'parseError';
	    /**
	     * Dispatched when a parser is ready to have dependencies retrieved and resolved.
	     * This is an internal event that should rarely (if ever) be listened for by
	     * external classes.
	     */
	    ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
	    return ParserEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ParserEvent;


/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ResourceDependency represents the data required to load, parse and resolve additional files ("dependencies")
	 * required by a parser, used by ResourceLoadSession.
	 *
	 */
	var ResourceDependency = (function () {
	    function ResourceDependency(id, request, data, parser, parentParser, retrieveAsRawData, suppressAssetEvents, sub_id) {
	        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
	        if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
	        if (sub_id === void 0) { sub_id = 0; }
	        this._id = id;
	        this._sub_id = sub_id;
	        this._request = request;
	        this._data = data;
	        this._parser = parser;
	        this._parentParser = parentParser;
	        this._retrieveAsRawData = retrieveAsRawData;
	        this._suppressAssetEvents = suppressAssetEvents;
	        this._assets = new Array();
	        this._dependencies = new Array();
	    }
	    Object.defineProperty(ResourceDependency.prototype, "id", {
	        /**
	         *
	         */
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "sub_id", {
	        get: function () {
	            return this._sub_id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "request", {
	        /**
	         *
	         */
	        get: function () {
	            return this._request;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "data", {
	        /**
	         * The data containing the dependency to be parsed, if the resource was already loaded.
	         */
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "parser", {
	        /**
	         *
	         */
	        get: function () {
	            return this._parser;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "parentParser", {
	        /**
	         * The parser which is dependent on this ResourceDependency object.
	         */
	        get: function () {
	            return this._parentParser;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
	        /**
	         *
	         */
	        get: function () {
	            return this._retrieveAsRawData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
	        /**
	         *
	         */
	        get: function () {
	            return this._suppressAssetEvents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "assets", {
	        /**
	         *
	         */
	        get: function () {
	            return this._assets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "dependencies", {
	        /**
	         *
	         */
	        get: function () {
	            return this._dependencies;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * Method to set data after having already created the dependency object, e.g. after load.
	     */
	    ResourceDependency.prototype._iSetData = function (data) {
	        this._data = data;
	    };
	    /**
	     * @private
	     *
	     */
	    ResourceDependency.prototype._iSetParser = function (parser) {
	        this._parser = parser;
	    };
	    /**
	     * Resolve the dependency when it's loaded with the parent parser. For example, a dependency containing an
	     * ImageResource would be assigned to a Mesh instance as a BitmapMaterial, a scene graph object would be added
	     * to its intended parent. The dependency should be a member of the dependencies property.
	     */
	    ResourceDependency.prototype.resolve = function () {
	        if (this._parentParser)
	            this._parentParser._iResolveDependency(this);
	    };
	    /**
	     * Resolve a dependency failure. For example, map loading failure from a 3d file
	     */
	    ResourceDependency.prototype.resolveFailure = function () {
	        if (this._parentParser)
	            this._parentParser._iResolveDependencyFailure(this);
	    };
	    /**
	     * Resolve the dependencies name
	     */
	    ResourceDependency.prototype.resolveName = function (asset) {
	        if (this._parentParser)
	            return this._parentParser._iResolveDependencyName(this, asset);
	        return asset.name;
	    };
	    return ResourceDependency;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ResourceDependency;


/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Enumaration class for precedence when resolving naming conflicts in the library.
	 *
	 * @see away.library.AssetLibrary.conflictPrecedence
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.naming.ConflictStrategy
	 */
	var ConflictPrecedence = (function () {
	    function ConflictPrecedence() {
	    }
	    /**
	     * Signals that in a conflict, the previous owner of the conflicting name
	     * should be favored (and keep it's name) and that the newly renamed asset
	     * is reverted to a non-conflicting name.
	     */
	    ConflictPrecedence.FAVOR_OLD = 'favorOld';
	    /**
	     * Signales that in a conflict, the newly renamed asset is favored (and keeps
	     * it's newly defined name) and that the previous owner of that name gets
	     * renamed to a non-conflicting name.
	     */
	    ConflictPrecedence.FAVOR_NEW = 'favorNew';
	    return ConflictPrecedence;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ConflictPrecedence;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ErrorConflictStrategy_1 = __webpack_require__(18);
	var IgnoreConflictStrategy_1 = __webpack_require__(22);
	var NumSuffixConflictStrategy_1 = __webpack_require__(23);
	/**
	 * Enumeration class for bundled conflict strategies. Set one of these values (or an
	 * instance of a self-defined sub-class of ConflictStrategyBase) to the conflictStrategy
	 * property on an AssetLibrary to define how that library resolves naming conflicts.
	 *
	 * The value of the <code>AssetLibrary.conflictPrecedence</code> property defines which
	 * of the conflicting assets will get to keep it's name, and which is renamed (if any.)
	 *
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.naming.ConflictStrategyBase
	 */
	var ConflictStrategy = (function () {
	    function ConflictStrategy(include) {
	        //TODO: find out why typescript d.ts files do not include this class
	    }
	    /**
	     * Specifies that in case of a naming conflict, one of the assets will be renamed and
	     * a numeric suffix appended to the base name.
	     */
	    ConflictStrategy.APPEND_NUM_SUFFIX = new NumSuffixConflictStrategy_1.default();
	    /**
	     * Specifies that naming conflicts should be ignored. This is not recommended in most
	     * cases, unless it can be 100% guaranteed that the application does not cause naming
	     * conflicts in the library (i.e. when an app-level system is in place to prevent this.)
	     */
	    ConflictStrategy.IGNORE = new IgnoreConflictStrategy_1.default();
	    /**
	     * Specifies that an error should be thrown if a naming conflict is discovered. Use this
	     * to be 100% sure that naming conflicts never occur unnoticed, and when it's undesirable
	     * to have the library automatically rename assets to avoid such conflicts.
	     */
	    ConflictStrategy.THROW_ERROR = new ErrorConflictStrategy_1.default();
	    return ConflictStrategy;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ConflictStrategy;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(19);
	var ErrorBase_1 = __webpack_require__(21);
	var ErrorConflictStrategy = (function (_super) {
	    __extends(ErrorConflictStrategy, _super);
	    function ErrorConflictStrategy() {
	        _super.call(this);
	    }
	    ErrorConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        throw new ErrorBase_1.default('Asset name collision while AssetLibrary.namingStrategy set to AssetLibrary.THROW_ERROR. Asset path: ' + changedAsset.assetFullPath);
	    };
	    ErrorConflictStrategy.prototype.create = function () {
	        return new ErrorConflictStrategy();
	    };
	    return ErrorConflictStrategy;
	}(ConflictStrategyBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ErrorConflictStrategy;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ConflictPrecedence_1 = __webpack_require__(16);
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetEvent_1 = __webpack_require__(1);
	/**
	 * Abstract base class for naming conflict resolution classes. Extend this to create a
	 * strategy class which the asset library can use to resolve asset naming conflicts, or
	 * use one of the bundled concrete strategy classes:
	 *
	 * <ul>
	 *   <li>IgnoreConflictStrategy (ConflictStrategy.IGNORE)</li>
	 *   <li>ErrorConflictStrategy (ConflictStrategy.THROW_ERROR)</li>
	 *   <li>NumSuffixConflictStrategy (ConflictStrategy.APPEND_NUM_SUFFIX)</li>
	 * </ul>
	 *
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.ConflictStrategy
	 * @see away.library.IgnoreConflictStrategy
	 * @see away.library.ErrorConflictStrategy
	 * @see away.library.NumSuffixConflictStrategy
	 */
	var ConflictStrategyBase = (function () {
	    function ConflictStrategyBase() {
	    }
	    /**
	     * Resolve a naming conflict between two assets. Must be implemented by concrete strategy
	     * classes.
	     */
	    ConflictStrategyBase.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Create instance of this conflict strategy. Used internally by the AssetLibrary to
	     * make sure the same strategy instance is not used in all AssetLibrary instances, which
	     * would break any state caching that happens inside the strategy class.
	     */
	    ConflictStrategyBase.prototype.create = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Provided as a convenience method for all conflict strategy classes, as a way to finalize
	     * the conflict resolution by applying the new names and dispatching the correct events.
	     */
	    ConflictStrategyBase.prototype._pUpdateNames = function (ns, nonConflictingName, oldAsset, newAsset, assetsDictionary, precedence) {
	        var loser_prev_name;
	        var winner;
	        var loser;
	        winner = (precedence === ConflictPrecedence_1.default.FAVOR_NEW) ? newAsset : oldAsset;
	        loser = (precedence === ConflictPrecedence_1.default.FAVOR_NEW) ? oldAsset : newAsset;
	        loser_prev_name = loser.name;
	        assetsDictionary[winner.name] = winner;
	        assetsDictionary[nonConflictingName] = loser;
	        loser.resetAssetPath(nonConflictingName, ns, false);
	        loser.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.ASSET_CONFLICT_RESOLVED, loser, loser_prev_name));
	    };
	    return ConflictStrategyBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ConflictStrategyBase;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	/**
	 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
	 * by a concrete subclass.
	 */
	var AbstractMethodError = (function (_super) {
	    __extends(AbstractMethodError, _super);
	    /**
	     * Create a new AbstractMethodError.
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function AbstractMethodError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "An abstract method was called! Either an instance of an abstract class was created, or an abstract method was not overridden by the subclass.", id);
	    }
	    return AbstractMethodError;
	}(ErrorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AbstractMethodError;


/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	var ErrorBase = (function () {
	    function ErrorBase(message, id, _name) {
	        if (message === void 0) { message = ''; }
	        if (id === void 0) { id = 0; }
	        if (_name === void 0) { _name = ''; }
	        this._errorID = 0; //Contains the reference number associated with the specific error message.
	        this._messsage = ''; //Contains the message associated with the Error object.
	        this._name = ''; // Contains the name of the Error object.
	        this._messsage = message;
	        this._name = name;
	        this._errorID = id;
	    }
	    Object.defineProperty(ErrorBase.prototype, "message", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._messsage;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._messsage = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ErrorBase.prototype, "name", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._name;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._name = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ErrorBase.prototype, "errorID", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._errorID;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ErrorBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ErrorBase;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(19);
	var IgnoreConflictStrategy = (function (_super) {
	    __extends(IgnoreConflictStrategy, _super);
	    function IgnoreConflictStrategy() {
	        _super.call(this);
	    }
	    IgnoreConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        // Do nothing, ignore the fact that there is a conflict.
	        return;
	    };
	    IgnoreConflictStrategy.prototype.create = function () {
	        return new IgnoreConflictStrategy();
	    };
	    return IgnoreConflictStrategy;
	}(ConflictStrategyBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = IgnoreConflictStrategy;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(19);
	var NumSuffixConflictStrategy = (function (_super) {
	    __extends(NumSuffixConflictStrategy, _super);
	    function NumSuffixConflictStrategy(separator) {
	        if (separator === void 0) { separator = '.'; }
	        _super.call(this);
	        this._separator = separator;
	        this._next_suffix = {};
	    }
	    NumSuffixConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        var orig;
	        var new_name;
	        var base;
	        var suffix;
	        orig = changedAsset.name;
	        if (orig.indexOf(this._separator) >= 0) {
	            // Name has an ocurrence of the separator, so get base name and suffix,
	            // unless suffix is non-numerical, in which case revert to zero and
	            // use entire name as base
	            base = orig.substring(0, orig.lastIndexOf(this._separator));
	            suffix = parseInt(orig.substring(base.length - 1));
	            if (isNaN(suffix)) {
	                base = orig;
	                suffix = 0;
	            }
	        }
	        else {
	            base = orig;
	            suffix = 0;
	        }
	        if (suffix == 0 && this._next_suffix.hasOwnProperty(base)) {
	            suffix = this._next_suffix[base];
	        }
	        // Find the first suffixed name that does
	        // not collide with other names.
	        do {
	            suffix++;
	            new_name = base.concat(this._separator, suffix.toString());
	        } while (assetsDictionary.hasOwnProperty(new_name));
	        this._next_suffix[base] = suffix;
	        this._pUpdateNames(oldAsset.assetNamespace, new_name, oldAsset, changedAsset, assetsDictionary, precedence);
	    };
	    NumSuffixConflictStrategy.prototype.create = function () {
	        return new NumSuffixConflictStrategy(this._separator);
	    };
	    return NumSuffixConflictStrategy;
	}(ConflictStrategyBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = NumSuffixConflictStrategy;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetEvent_1 = __webpack_require__(1);
	var EventDispatcher_1 = __webpack_require__(12);
	var AssetBase = (function (_super) {
	    __extends(AssetBase, _super);
	    function AssetBase(name) {
	        if (name === void 0) { name = null; }
	        _super.call(this);
	        this._id = AssetBase.ID_COUNT++;
	        if (name == null)
	            name = 'null';
	        this._name = name;
	        this._originalName = name;
	        this.updateFullPath();
	    }
	    Object.defineProperty(AssetBase.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            throw new AbstractMethodError_1.default();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "originalName", {
	        /**
	         * The original name used for this asset in the resource (e.g. file) in which
	         * it was found. This may not be the same as <code>name</code>, which may
	         * have changed due to of a name conflict.
	         */
	        get: function () {
	            return this._originalName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "id", {
	        /**
	         * A unique id for the asset, used to identify assets in an associative array
	         */
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "name", {
	        get: function () {
	            return this._name;
	        },
	        set: function (val) {
	            var prev;
	            prev = this._name;
	            this._name = val;
	            if (this._name == null)
	                this._name = 'null';
	            this.updateFullPath();
	            this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.RENAME, this, prev));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AssetBase.prototype.invalidate = function () {
	        this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.INVALIDATE, this));
	    };
	    /**
	     * @inheritDoc
	     */
	    AssetBase.prototype.dispose = function () {
	        this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.DISPOSE, this));
	    };
	    AssetBase.prototype.clear = function () {
	        this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this));
	    };
	    Object.defineProperty(AssetBase.prototype, "assetNamespace", {
	        get: function () {
	            return this._namespace;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "assetFullPath", {
	        get: function () {
	            return this._full_path;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AssetBase.prototype.assetPathEquals = function (name, ns) {
	        return (this._name == name && (!ns || this._namespace == ns));
	    };
	    AssetBase.prototype.isAsset = function (assetClass) {
	        return this.assetType == assetClass.assetType;
	    };
	    AssetBase.prototype.resetAssetPath = function (name, ns, overrideOriginal) {
	        if (ns === void 0) { ns = null; }
	        if (overrideOriginal === void 0) { overrideOriginal = true; }
	        this._name = name ? name : 'null';
	        this._namespace = ns ? ns : AssetBase.DEFAULT_NAMESPACE;
	        if (overrideOriginal)
	            this._originalName = this._name;
	        this.updateFullPath();
	    };
	    AssetBase.prototype.updateFullPath = function () {
	        this._full_path = [this._namespace, this._name];
	    };
	    AssetBase.ID_COUNT = 0;
	    AssetBase.DEFAULT_NAMESPACE = 'default';
	    return AssetBase;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AssetBase;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var URLRequestMethod_1 = __webpack_require__(10);
	var URLRequest = (function () {
	    /**

	     * @param url
	     */
	    function URLRequest(url) {
	        if (url === void 0) { url = null; }
	        /**
	         *
	         * away.net.URLRequestMethod.GET
	         * away.net.URLRequestMethod.POST
	         *
	         * @type {string}
	         */
	        this.method = URLRequestMethod_1.default.GET;
	        /**
	         * Use asynchronous XMLHttpRequest
	         * @type {boolean}
	         */
	        this.async = true;
	        this._url = url;
	    }
	    Object.defineProperty(URLRequest.prototype, "url", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._url;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._url = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * dispose
	     */
	    URLRequest.prototype.dispose = function () {
	        this.data = null;
	        this._url = null;
	    };
	    return URLRequest;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = URLRequest;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Vector3D_1 = __webpack_require__(30);
	var ProjectionBase_1 = __webpack_require__(34);
	var OrthographicProjection = (function (_super) {
	    __extends(OrthographicProjection, _super);
	    function OrthographicProjection(projectionHeight) {
	        if (projectionHeight === void 0) { projectionHeight = 500; }
	        _super.call(this);
	        this._projectionHeight = projectionHeight;
	    }
	    Object.defineProperty(OrthographicProjection.prototype, "projectionHeight", {
	        get: function () {
	            return this._projectionHeight;
	        },
	        set: function (value) {
	            if (value == this._projectionHeight) {
	                return;
	            }
	            this._projectionHeight = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    OrthographicProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.default(nX + this.matrix.rawData[12], -nY + this.matrix.rawData[13], sZ, 1.0);
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    OrthographicProjection.prototype.clone = function () {
	        var clone = new OrthographicProjection();
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone.projectionHeight = this._projectionHeight;
	        return clone;
	    };
	    //@override
	    OrthographicProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        this._yMax = this._projectionHeight * .5;
	        this._xMax = this._yMax * this._pAspectRatio;
	        var left;
	        var right;
	        var top;
	        var bottom;
	        if (this._pScissorRect.x == 0 && this._pScissorRect.y == 0 && this._pScissorRect.width == this._pViewPort.width && this._pScissorRect.height == this._pViewPort.height) {
	            // assume symmetric frustum
	            left = -this._xMax;
	            right = this._xMax;
	            top = -this._yMax;
	            bottom = this._yMax;
	            raw[0] = 2 / (this._projectionHeight * this._pAspectRatio);
	            raw[5] = 2 / this._projectionHeight;
	            raw[10] = 1 / (this._pFar - this._pNear);
	            raw[14] = this._pNear / (this._pNear - this._pFar);
	            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = raw[12] = raw[13] = 0;
	            raw[15] = 1;
	        }
	        else {
	            var xWidth = this._xMax * (this._pViewPort.width / this._pScissorRect.width);
	            var yHgt = this._yMax * (this._pViewPort.height / this._pScissorRect.height);
	            var center = this._xMax * (this._pScissorRect.x * 2 - this._pViewPort.width) / this._pScissorRect.width + this._xMax;
	            var middle = -this._yMax * (this._pScissorRect.y * 2 - this._pViewPort.height) / this._pScissorRect.height - this._yMax;
	            left = center - xWidth;
	            right = center + xWidth;
	            top = middle - yHgt;
	            bottom = middle + yHgt;
	            raw[0] = 2 * 1 / (right - left);
	            raw[5] = -2 * 1 / (top - bottom);
	            raw[10] = 1 / (this._pFar - this._pNear);
	            raw[12] = (right + left) / (right - left);
	            raw[13] = (bottom + top) / (bottom - top);
	            raw[14] = this._pNear / (this.near - this.far);
	            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	            raw[15] = 1;
	        }
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = left;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = right;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = top;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = bottom;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pMatrixInvalid = false;
	    };
	    return OrthographicProjection;
	}(ProjectionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OrthographicProjection;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3D_1 = __webpack_require__(28);
	var Vector3D_1 = __webpack_require__(30);
	/**
	 * away.geom.Matrix3DUtils provides additional Matrix3D functions.
	 */
	var Matrix3DUtils = (function () {
	    function Matrix3DUtils() {
	    }
	    /**
	     * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
	     *
	     * @param    quarternion    The quarterion object to convert.
	     */
	    Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
	        if (m === void 0) { m = null; }
	        var x = quarternion.x;
	        var y = quarternion.y;
	        var z = quarternion.z;
	        var w = quarternion.w;
	        var xx = x * x;
	        var xy = x * y;
	        var xz = x * z;
	        var xw = x * w;
	        var yy = y * y;
	        var yz = y * z;
	        var yw = y * w;
	        var zz = z * z;
	        var zw = z * w;
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        raw[0] = 1 - 2 * (yy + zz);
	        raw[1] = 2 * (xy + zw);
	        raw[2] = 2 * (xz - yw);
	        raw[4] = 2 * (xy - zw);
	        raw[5] = 1 - 2 * (xx + zz);
	        raw[6] = 2 * (yz + xw);
	        raw[8] = 2 * (xz + yw);
	        raw[9] = 2 * (yz - xw);
	        raw[10] = 1 - 2 * (xx + yy);
	        raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
	        raw[15] = 1;
	        if (m) {
	            m.copyRawDataFrom(raw);
	            return m;
	        }
	        else
	            return new Matrix3D_1.default(raw);
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the forward vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The forward vector
	     */
	    Matrix3DUtils.getForward = function (m, v) {
	        if (v === void 0) { v = null; }
	        if (v === null)
	            v = new Vector3D_1.default(0.0, 0.0, 0.0);
	        m.copyColumnTo(2, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the up vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The up vector
	     */
	    Matrix3DUtils.getUp = function (m, v) {
	        if (v === void 0) { v = null; }
	        if (v === null)
	            v = new Vector3D_1.default(0.0, 0.0, 0.0);
	        m.copyColumnTo(1, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the right vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The right vector
	     */
	    Matrix3DUtils.getRight = function (m, v) {
	        if (v === void 0) { v = null; }
	        //v ||= new Vector3D(0.0, 0.0, 0.0);
	        if (v === null) {
	            v = new Vector3D_1.default(0.0, 0.0, 0.0);
	        }
	        m.copyColumnTo(0, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
	     */
	    Matrix3DUtils.compare = function (m1, m2) {
	        var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
	        var r2 = m2.rawData;
	        m1.copyRawDataTo(r1);
	        for (var i = 0; i < 16; ++i) {
	            if (r1[i] != r2[i])
	                return false;
	        }
	        return true;
	    };
	    Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
	        var dirN;
	        var upN;
	        var lftN;
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        lftN = dir.crossProduct(up);
	        lftN.normalize();
	        upN = lftN.crossProduct(dir);
	        upN.normalize();
	        dirN = dir.clone();
	        dirN.normalize();
	        raw[0] = lftN.x;
	        raw[1] = upN.x;
	        raw[2] = -dirN.x;
	        raw[3] = 0.0;
	        raw[4] = lftN.y;
	        raw[5] = upN.y;
	        raw[6] = -dirN.y;
	        raw[7] = 0.0;
	        raw[8] = lftN.z;
	        raw[9] = upN.z;
	        raw[10] = -dirN.z;
	        raw[11] = 0.0;
	        raw[12] = -lftN.dotProduct(pos);
	        raw[13] = -upN.dotProduct(pos);
	        raw[14] = dirN.dotProduct(pos);
	        raw[15] = 1.0;
	        matrix.copyRawDataFrom(raw);
	    };
	    Matrix3DUtils.reflection = function (plane, target) {
	        if (target === void 0) { target = null; }
	        if (target === null)
	            target = new Matrix3D_1.default();
	        var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
	        var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
	        var ab2 = -2 * a * b;
	        var ac2 = -2 * a * c;
	        var bc2 = -2 * b * c;
	        // reflection matrix
	        rawData[0] = 1 - 2 * a * a;
	        rawData[4] = ab2;
	        rawData[8] = ac2;
	        rawData[12] = -2 * a * d;
	        rawData[1] = ab2;
	        rawData[5] = 1 - 2 * b * b;
	        rawData[9] = bc2;
	        rawData[13] = -2 * b * d;
	        rawData[2] = ac2;
	        rawData[6] = bc2;
	        rawData[10] = 1 - 2 * c * c;
	        rawData[14] = -2 * c * d;
	        rawData[3] = 0;
	        rawData[7] = 0;
	        rawData[11] = 0;
	        rawData[15] = 1;
	        target.copyRawDataFrom(rawData);
	        return target;
	    };
	    Matrix3DUtils.transformVector = function (matrix, vector, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.default();
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var d = raw[12];
	        var h = raw[13];
	        var l = raw[14];
	        var p = raw[15];
	        var x = vector.x;
	        var y = vector.y;
	        var z = vector.z;
	        result.x = a * x + b * y + c * z + d;
	        result.y = e * x + f * y + g * z + h;
	        result.z = i * x + j * y + k * z + l;
	        result.w = m * x + n * y + o * z + p;
	        return result;
	    };
	    Matrix3DUtils.deltaTransformVector = function (matrix, vector, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.default();
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var x = vector.x;
	        var y = vector.y;
	        var z = vector.z;
	        result.x = a * x + b * y + c * z;
	        result.y = e * x + f * y + g * z;
	        result.z = i * x + j * y + k * z;
	        result.w = m * x + n * y + o * z;
	        return result;
	    };
	    Matrix3DUtils.getTranslation = function (transform, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.default();
	        transform.copyColumnTo(3, result);
	        return result;
	    };
	    Matrix3DUtils.deltaTransformVectors = function (matrix, vin, vout) {
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var outIndex = 0;
	        var length = vin.length;
	        for (var index = 0; index < length; index += 3) {
	            var x = vin[index];
	            var y = vin[index + 1];
	            var z = vin[index + 2];
	            vout[outIndex++] = a * x + b * y + c * z;
	            vout[outIndex++] = e * x + f * y + g * z;
	            vout[outIndex++] = i * x + j * y + k * z;
	        }
	    };
	    /**
	     * A reference to a Vector to be used as a temporary raw data container, to prevent object creation.
	     */
	    Matrix3DUtils.RAW_DATA_CONTAINER = new Float32Array(16);
	    //public static RAW_DATA_CONTAINER:number[] = new Array<number>(16);
	    Matrix3DUtils.CALCULATION_MATRIX = new Matrix3D_1.default();
	    return Matrix3DUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Matrix3DUtils;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Box_1 = __webpack_require__(29);
	var MathConsts_1 = __webpack_require__(31);
	var Orientation3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(30);
	var ArgumentError_1 = __webpack_require__(33);
	var Matrix3D = (function () {
	    /**
	     * Creates a Matrix3D object.
	     */
	    function Matrix3D(v) {
	        if (v === void 0) { v = null; }
	        /**
	         * A Vector of 16 Numbers, where every four elements is a column of a 4x4 matrix.
	         *
	         * <p>An exception is thrown if the rawData property is set to a matrix that is not invertible. The Matrix3D
	         * object must be invertible. If a non-invertible matrix is needed, create a subclass of the Matrix3D object.</p>
	         */
	        this.rawData = new Float32Array(16);
	        this._position = new Vector3D_1.default();
	        this._positionDirty = true;
	        if (v != null && v.length == 16) {
	            this.copyRawDataFrom(v);
	        }
	        else {
	            this.identity();
	        }
	    }
	    /**
	     * Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
	     */
	    Matrix3D.prototype.append = function (lhs) {
	        var lrd = lhs.rawData;
	        var m111 = this.rawData[0];
	        var m112 = this.rawData[1];
	        var m113 = this.rawData[2];
	        var m114 = this.rawData[3];
	        var m121 = this.rawData[4];
	        var m122 = this.rawData[5];
	        var m123 = this.rawData[6];
	        var m124 = this.rawData[7];
	        var m131 = this.rawData[8];
	        var m132 = this.rawData[9];
	        var m133 = this.rawData[10];
	        var m134 = this.rawData[11];
	        var m141 = this.rawData[12];
	        var m142 = this.rawData[13];
	        var m143 = this.rawData[14];
	        var m144 = this.rawData[15];
	        var m211 = lrd[0];
	        var m212 = lrd[1];
	        var m213 = lrd[2];
	        var m214 = lrd[3];
	        var m221 = lrd[4];
	        var m222 = lrd[5];
	        var m223 = lrd[6];
	        var m224 = lrd[7];
	        var m231 = lrd[8];
	        var m232 = lrd[9];
	        var m233 = lrd[10];
	        var m234 = lrd[11];
	        var m241 = lrd[12];
	        var m242 = lrd[13];
	        var m243 = lrd[14];
	        var m244 = lrd[15];
	        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
	        this._positionDirty = true;
	    };
	    /**
	     * Appends an incremental rotation to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendRotation = function (degrees, axis) {
	        this.append(Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees));
	    };
	    /**
	     * Appends an incremental skew change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendSkew = function (xSkew, ySkew, zSkew) {
	        if (xSkew == 0 && ySkew == 0 && zSkew == 0)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = 1;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = xSkew;
	        raw[5] = 1;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = ySkew;
	        raw[9] = zSkew;
	        raw[10] = 1;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.append(Matrix3D.tempMatrix);
	    };
	    /**
	     * Appends an incremental scale change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
	        if (xScale == 1 && yScale == 1 && zScale == 1)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = xScale;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = yScale;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = zScale;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.append(Matrix3D.tempMatrix);
	    };
	    /**
	     * Appends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendTranslation = function (x, y, z) {
	        this.rawData[12] += x;
	        this.rawData[13] += y;
	        this.rawData[14] += z;
	        this._positionDirty = true;
	    };
	    /**
	     * Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.
	     */
	    Matrix3D.prototype.clone = function () {
	        return new Matrix3D(this.rawData);
	    };
	    /**
	     * Copies a Vector3D object into specific column of the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
	        switch (column) {
	            case 0:
	                this.rawData[0] = vector3D.x;
	                this.rawData[1] = vector3D.y;
	                this.rawData[2] = vector3D.z;
	                this.rawData[3] = vector3D.w;
	                break;
	            case 1:
	                this.rawData[4] = vector3D.x;
	                this.rawData[5] = vector3D.y;
	                this.rawData[6] = vector3D.z;
	                this.rawData[7] = vector3D.w;
	                break;
	            case 2:
	                this.rawData[8] = vector3D.x;
	                this.rawData[9] = vector3D.y;
	                this.rawData[10] = vector3D.z;
	                this.rawData[11] = vector3D.w;
	                break;
	            case 3:
	                this.rawData[12] = vector3D.x;
	                this.rawData[13] = vector3D.y;
	                this.rawData[14] = vector3D.z;
	                this.rawData[15] = vector3D.w;
	                break;
	            default:
	                throw new ArgumentError_1.default("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies specific column of the calling Matrix3D object into the Vector3D object.
	     */
	    Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
	        switch (column) {
	            case 0:
	                vector3D.x = this.rawData[0];
	                vector3D.y = this.rawData[1];
	                vector3D.z = this.rawData[2];
	                vector3D.w = this.rawData[3];
	                break;
	            case 1:
	                vector3D.x = this.rawData[4];
	                vector3D.y = this.rawData[5];
	                vector3D.z = this.rawData[6];
	                vector3D.w = this.rawData[7];
	                break;
	            case 2:
	                vector3D.x = this.rawData[8];
	                vector3D.y = this.rawData[9];
	                vector3D.z = this.rawData[10];
	                vector3D.w = this.rawData[11];
	                break;
	            case 3:
	                vector3D.x = this.rawData[12];
	                vector3D.y = this.rawData[13];
	                vector3D.z = this.rawData[14];
	                vector3D.w = this.rawData[15];
	                break;
	            default:
	                throw new ArgumentError_1.default("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies all of the matrix data from the source Matrix3D object into the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyFrom = function (source) {
	        var sourceRaw = source.rawData;
	        var len = sourceRaw.length;
	        for (var c = 0; c < len; c++)
	            this.rawData[c] = sourceRaw[c];
	    };
	    /**
	     * Copies this Matrix3D object into a destination Matrix3D object.
	     */
	    Matrix3D.prototype.copyTo = function (target) {
	        var targetRaw = target.rawData;
	        var len = this.rawData.length;
	        for (var c = 0; c < len; c++)
	            targetRaw[c] = this.rawData[c];
	    };
	    Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
	        if (index === void 0) { index = 0; }
	        if (transpose === void 0) { transpose = false; }
	        if (transpose)
	            this.transpose();
	        var len = vector.length - index;
	        for (var c = 0; c < len; c++)
	            this.rawData[c] = vector[c + index];
	        if (transpose)
	            this.transpose();
	    };
	    Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
	        if (index === void 0) { index = 0; }
	        if (transpose === void 0) { transpose = false; }
	        if (transpose)
	            this.transpose();
	        var len = this.rawData.length;
	        for (var c = 0; c < len; c++)
	            vector[c + index] = this.rawData[c];
	        if (transpose)
	            this.transpose();
	    };
	    /**
	     * Copies a Vector3D object into specific row of the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
	        switch (row) {
	            case 0:
	                this.rawData[0] = vector3D.x;
	                this.rawData[4] = vector3D.y;
	                this.rawData[8] = vector3D.z;
	                this.rawData[12] = vector3D.w;
	                break;
	            case 1:
	                this.rawData[1] = vector3D.x;
	                this.rawData[5] = vector3D.y;
	                this.rawData[9] = vector3D.z;
	                this.rawData[13] = vector3D.w;
	                break;
	            case 2:
	                this.rawData[2] = vector3D.x;
	                this.rawData[6] = vector3D.y;
	                this.rawData[10] = vector3D.z;
	                this.rawData[14] = vector3D.w;
	                break;
	            case 3:
	                this.rawData[3] = vector3D.x;
	                this.rawData[7] = vector3D.y;
	                this.rawData[11] = vector3D.z;
	                this.rawData[15] = vector3D.w;
	                break;
	            default:
	                throw new ArgumentError_1.default("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies specific row of the calling Matrix3D object into the Vector3D object.
	     */
	    Matrix3D.prototype.copyRowTo = function (row, vector3D) {
	        switch (row) {
	            case 0:
	                vector3D.x = this.rawData[0];
	                vector3D.y = this.rawData[4];
	                vector3D.z = this.rawData[8];
	                vector3D.w = this.rawData[12];
	                break;
	            case 1:
	                vector3D.x = this.rawData[1];
	                vector3D.y = this.rawData[5];
	                vector3D.z = this.rawData[9];
	                vector3D.w = this.rawData[13];
	                break;
	            case 2:
	                vector3D.x = this.rawData[2];
	                vector3D.y = this.rawData[6];
	                vector3D.z = this.rawData[10];
	                vector3D.w = this.rawData[14];
	                break;
	            case 3:
	                vector3D.x = this.rawData[3];
	                vector3D.y = this.rawData[7];
	                vector3D.z = this.rawData[11];
	                vector3D.w = this.rawData[15];
	                break;
	            default:
	                throw new ArgumentError_1.default("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.
	     */
	    Matrix3D.prototype.decompose = function (orientationStyle) {
	        if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
	        var q;
	        if (this._components == null)
	            this._components = [null, new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default()];
	        var colX = new Vector3D_1.default(this.rawData[0], this.rawData[1], this.rawData[2]);
	        var colY = new Vector3D_1.default(this.rawData[4], this.rawData[5], this.rawData[6]);
	        var colZ = new Vector3D_1.default(this.rawData[8], this.rawData[9], this.rawData[10]);
	        var scale = this._components[3];
	        var skew = this._components[2];
	        //compute X scale factor and normalise colX
	        scale.x = colX.length;
	        colX.scaleBy(1 / scale.x);
	        //compute XY shear factor and make colY orthogonal to colX
	        skew.x = colX.dotProduct(colY);
	        colY = Vector3D_1.default.combine(colY, colX, 1, -skew.x);
	        //compute Y scale factor and normalise colY
	        scale.y = colY.length;
	        colY.scaleBy(1 / scale.y);
	        skew.x /= scale.y;
	        //compute XZ and YZ shears and make colZ orthogonal to colX and colY
	        skew.y = colX.dotProduct(colZ);
	        colZ = Vector3D_1.default.combine(colZ, colX, 1, -skew.y);
	        skew.z = colY.dotProduct(colZ);
	        colZ = Vector3D_1.default.combine(colZ, colY, 1, -skew.z);
	        //compute Z scale and normalise colZ
	        scale.z = colZ.length;
	        colZ.scaleBy(1 / scale.z);
	        skew.y /= scale.z;
	        skew.z /= scale.z;
	        //at this point, the matrix (in cols) is orthonormal
	        //check for a coordinate system flip. If the determinant is -1, negate the z scaling factor
	        if (colX.dotProduct(colY.crossProduct(colZ)) < 0) {
	            scale.z = -scale.z;
	            colZ.x = -colZ.x;
	            colZ.y = -colZ.y;
	            colZ.z = -colZ.z;
	        }
	        var rot = this._components[1];
	        switch (orientationStyle) {
	            case Orientation3D_1.default.AXIS_ANGLE:
	                rot.w = Math.acos((colX.x + colY.y + colZ.z - 1) / 2);
	                var len = Math.sqrt((colY.z - colZ.y) * (colY.z - colZ.y) + (colZ.x - colX.z) * (colZ.x - colX.z) + (colX.y - colY.x) * (colX.y - colY.x));
	                rot.x = (colY.z - colZ.y) / len;
	                rot.y = (colZ.x - colX.z) / len;
	                rot.z = (colX.y - colY.x) / len;
	                break;
	            case Orientation3D_1.default.QUATERNION:
	                var tr = colX.x + colY.y + colZ.z;
	                if (tr > 0) {
	                    rot.w = Math.sqrt(1 + tr) / 2;
	                    rot.x = (colY.z - colZ.y) / (4 * rot.w);
	                    rot.y = (colZ.x - colX.z) / (4 * rot.w);
	                    rot.z = (colX.y - colY.x) / (4 * rot.w);
	                }
	                else if ((colX.x > colY.y) && (colX.x > colZ.z)) {
	                    rot.x = Math.sqrt(1 + colX.x - colY.y - colZ.z) / 2;
	                    rot.w = (colY.z - colZ.y) / (4 * rot.x);
	                    rot.y = (colX.y + colY.x) / (4 * rot.x);
	                    rot.z = (colZ.x + colX.z) / (4 * rot.x);
	                }
	                else if (colY.y > colZ.z) {
	                    rot.y = Math.sqrt(1 + colY.y - colX.x - colZ.z) / 2;
	                    rot.x = (colX.y + colY.x) / (4 * rot.y);
	                    rot.w = (colZ.x - colX.z) / (4 * rot.y);
	                    rot.z = (colY.z + colZ.y) / (4 * rot.y);
	                }
	                else {
	                    rot.z = Math.sqrt(1 + colZ.z - colX.x - colY.y) / 2;
	                    rot.x = (colZ.x + colX.z) / (4 * rot.z);
	                    rot.y = (colY.z + colZ.y) / (4 * rot.z);
	                    rot.w = (colX.y - colY.x) / (4 * rot.z);
	                }
	                break;
	            case Orientation3D_1.default.EULER_ANGLES:
	                rot.y = Math.asin(-colX.z);
	                //var cos:number = Math.cos(rot.y);
	                if (colX.z != 1 && colX.z != -1) {
	                    rot.x = Math.atan2(colY.z, colZ.z);
	                    rot.z = Math.atan2(colX.y, colX.x);
	                }
	                else {
	                    rot.z = 0;
	                    rot.x = Math.atan2(colY.x, colY.y);
	                }
	                break;
	        }
	        this._components[0] = this.position;
	        return this._components;
	    };
	    /**
	     * Uses the transformation matrix without its translation elements to transform a Vector3D object from one space
	     * coordinate to another.
	     */
	    Matrix3D.prototype.deltaTransformVector = function (v, t) {
	        if (t === void 0) { t = null; }
	        var x = v.x;
	        var y = v.y;
	        var z = v.z;
	        if (!t)
	            t = new Vector3D_1.default();
	        t.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8];
	        t.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9];
	        t.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10];
	        t.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11];
	        return t;
	    };
	    /**
	     * Converts the current matrix to an identity or unit matrix.
	     */
	    Matrix3D.prototype.identity = function () {
	        this.rawData[0] = 1;
	        this.rawData[1] = 0;
	        this.rawData[2] = 0;
	        this.rawData[3] = 0;
	        this.rawData[4] = 0;
	        this.rawData[5] = 1;
	        this.rawData[6] = 0;
	        this.rawData[7] = 0;
	        this.rawData[8] = 0;
	        this.rawData[9] = 0;
	        this.rawData[10] = 1;
	        this.rawData[11] = 0;
	        this.rawData[12] = 0;
	        this.rawData[13] = 0;
	        this.rawData[14] = 0;
	        this.rawData[15] = 1;
	        this._positionDirty = true;
	    };
	    /**
	     * [static] Interpolates the translation, rotation, and scale transformation of one matrix toward those of the target matrix.
	     */
	    Matrix3D.interpolate = function (thisMat, toMat, percent) {
	        var m = new Matrix3D();
	        for (var i = 0; i < 16; ++i)
	            m.rawData[i] = thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent;
	        return m;
	    };
	    /**
	     * Interpolates this matrix towards the translation, rotation, and scale transformations of the target matrix.
	     */
	    Matrix3D.prototype.interpolateTo = function (toMat, percent) {
	        for (var i = 0; i < 16; ++i)
	            this.rawData[i] = this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent;
	    };
	    /**
	     * Inverts the current matrix.
	     */
	    Matrix3D.prototype.invert = function () {
	        var d = this.determinant;
	        var invertable = Math.abs(d) > 0.00000000001;
	        if (invertable) {
	            d = 1 / d;
	            var m11 = this.rawData[0];
	            var m12 = this.rawData[1];
	            var m13 = this.rawData[2];
	            var m14 = this.rawData[3];
	            var m21 = this.rawData[4];
	            var m22 = this.rawData[5];
	            var m23 = this.rawData[6];
	            var m24 = this.rawData[7];
	            var m31 = this.rawData[8];
	            var m32 = this.rawData[9];
	            var m33 = this.rawData[10];
	            var m34 = this.rawData[11];
	            var m41 = this.rawData[12];
	            var m42 = this.rawData[13];
	            var m43 = this.rawData[14];
	            var m44 = this.rawData[15];
	            this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
	            this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
	            this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
	            this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
	            this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
	            this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
	            this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
	            this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
	            this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
	            this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
	            this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
	            this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
	            this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
	            this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
	            this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
	            this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
	        }
	        this._positionDirty = true;
	        return invertable;
	    };
	    /* TODO implement pointAt
	     public pointAt( pos:Vector3D, at:Vector3D = null, up:Vector3D = null )
	     {
	     }
	     */
	    /**
	     * Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
	     */
	    Matrix3D.prototype.prepend = function (rhs) {
	        var m111 = rhs.rawData[0];
	        var m112 = rhs.rawData[1];
	        var m113 = rhs.rawData[2];
	        var m114 = rhs.rawData[3];
	        var m121 = rhs.rawData[4];
	        var m122 = rhs.rawData[5];
	        var m123 = rhs.rawData[6];
	        var m124 = rhs.rawData[7];
	        var m131 = rhs.rawData[8];
	        var m132 = rhs.rawData[9];
	        var m133 = rhs.rawData[10];
	        var m134 = rhs.rawData[11];
	        var m141 = rhs.rawData[12];
	        var m142 = rhs.rawData[13];
	        var m143 = rhs.rawData[14];
	        var m144 = rhs.rawData[15];
	        var m211 = this.rawData[0];
	        var m212 = this.rawData[1];
	        var m213 = this.rawData[2];
	        var m214 = this.rawData[3];
	        var m221 = this.rawData[4];
	        var m222 = this.rawData[5];
	        var m223 = this.rawData[6];
	        var m224 = this.rawData[7];
	        var m231 = this.rawData[8];
	        var m232 = this.rawData[9];
	        var m233 = this.rawData[10];
	        var m234 = this.rawData[11];
	        var m241 = this.rawData[12];
	        var m242 = this.rawData[13];
	        var m243 = this.rawData[14];
	        var m244 = this.rawData[15];
	        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
	        this._positionDirty = true;
	    };
	    /**
	     * Prepends an incremental rotation to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependRotation = function (degrees, axis) {
	        var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);
	        /*
	         if ( pivot != null )
	         {
	         var p:Vector3D = pivot;
	         m.appendTranslation( p.x, p.y, p.z );
	         }
	         */
	        this.prepend(m);
	    };
	    /**
	     * Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
	        if (xScale == 1 && yScale == 1 && zScale == 1)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = xScale;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = yScale;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = zScale;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.prepend(Matrix3D.tempMatrix);
	    };
	    /**
	     * Prepends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependTranslation = function (x, y, z) {
	        var raw = Matrix3D.tempRawData;
	        raw[0] = 1;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = 1;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = 1;
	        raw[11] = 0;
	        raw[12] = x;
	        raw[13] = y;
	        raw[14] = z;
	        raw[15] = 1;
	        this.prepend(Matrix3D.tempMatrix);
	    };
	    // TODO orientationStyle
	    /**
	     * Sets the transformation matrix's translation, rotation, and scale settings.
	     */
	    Matrix3D.prototype.recompose = function (components) {
	        var pos = components[0] || this.position;
	        this.identity();
	        var scale = components[3];
	        if (scale && (scale.x != 1 || scale.y != 1 || scale.z != 1))
	            this.appendScale(scale.x, scale.y, scale.z);
	        var skew = components[2];
	        if (skew && (skew.x != 0 || skew.y != 0 || skew.z != 0))
	            this.appendSkew(skew.x, skew.y, skew.z);
	        var sin;
	        var cos;
	        var raw = Matrix3D.tempRawData;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 0;
	        var rotation = components[1];
	        if (rotation) {
	            var angle = -rotation.x;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = 1;
	                raw[1] = 0;
	                raw[2] = 0;
	                raw[3] = 0;
	                raw[4] = 0;
	                raw[5] = cos;
	                raw[6] = -sin;
	                raw[7] = 0;
	                raw[8] = 0;
	                raw[9] = sin;
	                raw[10] = cos;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	            angle = -rotation.y;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = cos;
	                raw[1] = 0;
	                raw[2] = sin;
	                raw[3] = 0;
	                raw[4] = 0;
	                raw[5] = 1;
	                raw[6] = 0;
	                raw[7] = 0;
	                raw[8] = -sin;
	                raw[9] = 0;
	                raw[10] = cos;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	            angle = -rotation.z;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = cos;
	                raw[1] = -sin;
	                raw[2] = 0;
	                raw[3] = 0;
	                raw[4] = sin;
	                raw[5] = cos;
	                raw[6] = 0;
	                raw[7] = 0;
	                raw[8] = 0;
	                raw[9] = 0;
	                raw[10] = 1;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	        }
	        this.rawData[12] = pos.x;
	        this.rawData[13] = pos.y;
	        this.rawData[14] = pos.z;
	        if (components[0])
	            this._positionDirty = true;
	        this.rawData[15] = 1;
	        return true;
	    };
	    Matrix3D.prototype.transformVector = function (v, t) {
	        if (t === void 0) { t = null; }
	        if (v == null)
	            return t || new Vector3D_1.default();
	        var x = v.x;
	        var y = v.y;
	        var z = v.z;
	        if (!t)
	            t = new Vector3D_1.default();
	        t.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
	        t.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
	        t.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
	        t.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15];
	        return t;
	    };
	    Matrix3D.prototype.transformBox = function (b, t) {
	        if (t === void 0) { t = null; }
	        if (b == null)
	            return t || new Box_1.default();
	        var minX, minY, minZ;
	        var maxX, maxY, maxZ;
	        maxX = b.width + (minX = b.x);
	        maxY = b.height + (minY = b.y);
	        maxZ = b.depth + (minZ = b.z);
	        if (!t)
	            t = new Box_1.default();
	        //TODO: take account of shear
	        t.width = maxX * this.rawData[0] + maxY * this.rawData[4] + maxZ * this.rawData[8] + this.rawData[12] - (t.x = minX * this.rawData[0] + minY * this.rawData[4] + minZ * this.rawData[8] + this.rawData[12]);
	        t.height = maxX * this.rawData[1] + maxY * this.rawData[5] + maxZ * this.rawData[9] + this.rawData[13] - (t.y = minX * this.rawData[1] + minY * this.rawData[5] + minZ * this.rawData[9] + this.rawData[13]);
	        t.depth = maxX * this.rawData[2] + maxY * this.rawData[6] + maxZ * this.rawData[10] + this.rawData[14] - (t.z = minX * this.rawData[2] + minY * this.rawData[6] + minZ * this.rawData[10] + this.rawData[14]);
	        return t;
	    };
	    /**
	     * Uses the transformation matrix to transform a Vector of Numbers from one coordinate space to another.
	     */
	    Matrix3D.prototype.transformVectors = function (vin, vout) {
	        var i = 0;
	        var x = 0, y = 0, z = 0;
	        while (i + 3 <= vin.length) {
	            x = vin[i];
	            y = vin[i + 1];
	            z = vin[i + 2];
	            vout[i] = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
	            vout[i + 1] = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
	            vout[i + 2] = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
	            i += 3;
	        }
	    };
	    /**
	     * Converts the current Matrix3D object to a matrix where the rows and columns are swapped.
	     */
	    Matrix3D.prototype.transpose = function () {
	        var raw = Matrix3D.tempRawData;
	        this.copyRawDataTo(raw);
	        this.rawData[1] = raw[4];
	        this.rawData[2] = raw[8];
	        this.rawData[3] = raw[12];
	        this.rawData[4] = raw[1];
	        this.rawData[6] = raw[9];
	        this.rawData[7] = raw[13];
	        this.rawData[8] = raw[2];
	        this.rawData[9] = raw[6];
	        this.rawData[11] = raw[14];
	        this.rawData[12] = raw[3];
	        this.rawData[13] = raw[7];
	        this.rawData[14] = raw[11];
	        this._positionDirty = true;
	    };
	    Matrix3D.getAxisRotation = function (x, y, z, degrees) {
	        // internal class use by rotations which have been tested
	        var m = new Matrix3D();
	        var rad = degrees * MathConsts_1.default.DEGREES_TO_RADIANS;
	        var c = Math.cos(rad);
	        var s = Math.sin(rad);
	        var t = 1 - c;
	        var tmp1, tmp2;
	        m.rawData[0] = c + x * x * t;
	        m.rawData[5] = c + y * y * t;
	        m.rawData[10] = c + z * z * t;
	        tmp1 = x * y * t;
	        tmp2 = z * s;
	        m.rawData[1] = tmp1 + tmp2;
	        m.rawData[4] = tmp1 - tmp2;
	        tmp1 = x * z * t;
	        tmp2 = y * s;
	        m.rawData[8] = tmp1 + tmp2;
	        m.rawData[2] = tmp1 - tmp2;
	        tmp1 = y * z * t;
	        tmp2 = x * s;
	        m.rawData[9] = tmp1 - tmp2;
	        m.rawData[6] = tmp1 + tmp2;
	        return m;
	    };
	    Object.defineProperty(Matrix3D.prototype, "determinant", {
	        /**
	         * [read-only] A Number that determines whether a matrix is invertible.
	         */
	        get: function () {
	            return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix3D.prototype, "position", {
	        /**
	         * A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object within the
	         * transformation's frame of reference.
	         */
	        get: function () {
	            if (this._positionDirty) {
	                this._positionDirty = false;
	                this._position.x = this.rawData[12];
	                this._position.y = this.rawData[13];
	                this._position.z = this.rawData[14];
	            }
	            return this._position;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Matrix3D.prototype.invalidatePosition = function () {
	        this._positionDirty = true;
	    };
	    Matrix3D.prototype.toFixed = function (decimalPlace) {
	        var magnitude = Math.pow(10, decimalPlace);
	        return "matrix3d(" + Math.round(this.rawData[0] * magnitude) / magnitude + "," + Math.round(this.rawData[1] * magnitude) / magnitude + "," + Math.round(this.rawData[2] * magnitude) / magnitude + "," + Math.round(this.rawData[3] * magnitude) / magnitude + "," + Math.round(this.rawData[4] * magnitude) / magnitude + "," + Math.round(this.rawData[5] * magnitude) / magnitude + "," + Math.round(this.rawData[6] * magnitude) / magnitude + "," + Math.round(this.rawData[7] * magnitude) / magnitude + "," + Math.round(this.rawData[8] * magnitude) / magnitude + "," + Math.round(this.rawData[9] * magnitude) / magnitude + "," + Math.round(this.rawData[10] * magnitude) / magnitude + "," + Math.round(this.rawData[11] * magnitude) / magnitude + "," + Math.round(this.rawData[12] * magnitude) / magnitude + "," + Math.round(this.rawData[13] * magnitude) / magnitude + "," + Math.round(this.rawData[14] * magnitude) / magnitude + "," + Math.round(this.rawData[15] * magnitude) / magnitude + ")";
	    };
	    Matrix3D.prototype.toString = function () {
	        return "matrix3d(" + Math.round(this.rawData[0] * 1000) / 1000 + "," + Math.round(this.rawData[1] * 1000) / 1000 + "," + Math.round(this.rawData[2] * 1000) / 1000 + "," + Math.round(this.rawData[3] * 1000) / 1000 + "," + Math.round(this.rawData[4] * 1000) / 1000 + "," + Math.round(this.rawData[5] * 1000) / 1000 + "," + Math.round(this.rawData[6] * 1000) / 1000 + "," + Math.round(this.rawData[7] * 1000) / 1000 + "," + Math.round(this.rawData[8] * 1000) / 1000 + "," + Math.round(this.rawData[9] * 1000) / 1000 + "," + Math.round(this.rawData[10] * 1000) / 1000 + "," + Math.round(this.rawData[11] * 1000) / 1000 + "," + Math.round(this.rawData[12] * 1000) / 1000 + "," + Math.round(this.rawData[13] * 1000) / 1000 + "," + Math.round(this.rawData[14] * 1000) / 1000 + "," + Math.round(this.rawData[15] * 1000) / 1000 + ")";
	    };
	    Matrix3D.tempMatrix = new Matrix3D();
	    Matrix3D.tempRawData = Matrix3D.tempMatrix.rawData;
	    return Matrix3D;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Matrix3D;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(30);
	/**
	 * A Box object is an area defined by its position, as indicated by its
	 * top-left-front corner point(<i>x</i>, <i>y</i>, <i>z</i>) and by its width,
	 * height and depth.
	 *
	 *
	 * <p>The <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	 * <code>height</code> <code>depth</code> properties of the Box class are
	 * independent of each other; changing the value of one property has no effect
	 * on the others. However, the <code>right</code>, <code>bottom</code> and
	 * <code>back</code> properties are integrally related to those six
	 * properties. For example, if you change the value of the <code>right</code>
	 * property, the value of the <code>width</code> property changes; if you
	 * change the <code>bottom</code> property, the value of the
	 * <code>height</code> property changes. </p>
	 *
	 * <p>The following methods and properties use Box objects:</p>
	 *
	 * <ul>
	 *   <li>The <code>bounds</code> property of the DisplayObject class</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Box()</code> constructor to create a
	 * Box object.</p>
	 *
	 * <p><b>Note:</b> The Box class does not define a cubic Shape
	 * display object.
	 */
	var Box = (function () {
	    /**
	     * Creates a new Box object with the top-left-front corner specified by the
	     * <code>x</code>, <code>y</code> and <code>z</code> parameters and with the
	     * specified <code>width</code>, <code>height</code> and <code>depth</code>
	     * parameters. If you call this public without parameters, a box with
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code> and <code>depth</code> properties set to 0 is created.
	     *
	     * @param x      The <i>x</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param y      The <i>y</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param z      The <i>z</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param width  The width of the box, in pixels.
	     * @param height The height of the box, in pixels.
	     * @param depth The depth of the box, in pixels.
	     */
	    function Box(x, y, z, width, height, depth) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (width === void 0) { width = 0; }
	        if (height === void 0) { height = 0; }
	        if (depth === void 0) { depth = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.width = width;
	        this.height = height;
	        this.depth = depth;
	    }
	    Object.defineProperty(Box.prototype, "back", {
	        /**
	         * The sum of the <code>z</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.z + this.depth;
	        },
	        set: function (val) {
	            this.depth = val - this.z;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "bottom", {
	        /**
	         * The sum of the <code>y</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.y + this.height;
	        },
	        set: function (val) {
	            this.height = val - this.y;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "bottomRightBack", {
	        /**
	         * The location of the Box object's bottom-right corner, determined by the
	         * values of the <code>right</code> and <code>bottom</code> properties.
	         */
	        get: function () {
	            if (this._bottomRightBack == null)
	                this._bottomRightBack = new Vector3D_1.default();
	            this._bottomRightBack.x = this.x + this.width;
	            this._bottomRightBack.y = this.y + this.height;
	            this._bottomRightBack.z = this.z + this.depth;
	            return this._bottomRightBack;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "front", {
	        /**
	         * The <i>z</i> coordinate of the top-left-front corner of the box. Changing
	         * the <code>front</code> property of a Box object has no effect on the
	         * <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code>
	         * properties. However it does affect the <code>depth</code> property,
	         * whereas changing the <code>z</code> value does <i>not</i> affect the
	         * <code>depth</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.z;
	        },
	        set: function (val) {
	            this.depth += this.z - val;
	            this.z = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "left", {
	        /**
	         * The <i>x</i> coordinate of the top-left corner of the box. Changing the
	         * <code>left</code> property of a Box object has no effect on the
	         * <code>y</code> and <code>height</code> properties. However it does affect
	         * the <code>width</code> property, whereas changing the <code>x</code> value
	         * does <i>not</i> affect the <code>width</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.x;
	        },
	        set: function (val) {
	            this.width += this.x - val;
	            this.x = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "right", {
	        /**
	         * The sum of the <code>x</code> and <code>width</code> properties.
	         */
	        get: function () {
	            return this.x + this.width;
	        },
	        set: function (val) {
	            this.width = val - this.x;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "size", {
	        /**
	         * The size of the Box object, expressed as a Vector3D object with the
	         * values of the <code>width</code>, <code>height</code> and
	         * <code>depth</code> properties.
	         */
	        get: function () {
	            if (this._size == null)
	                this._size = new Vector3D_1.default();
	            this._size.x = this.width;
	            this._size.y = this.height;
	            this._size.z = this.depth;
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "top", {
	        /**
	         * The <i>y</i> coordinate of the top-left-front corner of the box. Changing
	         * the <code>top</code> property of a Box object has no effect on the
	         * <code>x</code> and <code>width</code> properties. However it does affect
	         * the <code>height</code> property, whereas changing the <code>y</code>
	         * value does <i>not</i> affect the <code>height</code> property.
	         *
	         * <p>The value of the <code>top</code> property is equal to the value of the
	         * <code>y</code> property.</p>
	         */
	        get: function () {
	            return this.y;
	        },
	        set: function (val) {
	            this.height += (this.y - val);
	            this.y = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "topLeftFront", {
	        /**
	         * The location of the Box object's top-left-front corner, determined by the
	         * <i>x</i>, <i>y</i> and <i>z</i> coordinates of the point.
	         */
	        get: function () {
	            if (this._topLeftFront == null)
	                this._topLeftFront = new Vector3D_1.default();
	            this._topLeftFront.x = this.x;
	            this._topLeftFront.y = this.y;
	            this._topLeftFront.z = this.z;
	            return this._topLeftFront;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new Box object with the same values for the <code>x</code>,
	     * <code>y</code>, <code>z</code>, <code>width</code>, <code>height</code>
	     * and <code>depth</code> properties as the original Box object.
	     *
	     * @return A new Box object with the same values for the <code>x</code>,
	     *         <code>y</code>, <code>z</code>, <code>width</code>,
	     *         <code>height</code> and <code>depth</code> properties as the
	     *         original Box object.
	     */
	    Box.prototype.clone = function () {
	        return new Box(this.x, this.y, this.z, this.width, this.height, this.depth);
	    };
	    /**
	     * Determines whether the specified position is contained within the cubic
	     * region defined by this Box object.
	     *
	     * @param x The <i>x</i> coordinate(horizontal component) of the position.
	     * @param y The <i>y</i> coordinate(vertical component) of the position.
	     * @param z The <i>z</i> coordinate(longitudinal component) of the position.
	     * @return A value of <code>true</code> if the Box object contains the
	     *         specified position; otherwise <code>false</code>.
	     */
	    Box.prototype.contains = function (x, y, z) {
	        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y && this.z <= z && this.z + this.depth >= z);
	    };
	    /**
	     * Determines whether the specified position is contained within the cubic
	     * region defined by this Box object. This method is similar to the
	     * <code>Box.contains()</code> method, except that it takes a Vector3D
	     * object as a parameter.
	     *
	     * @param position The position, as represented by its <i>x</i>, <i>y</i> and
	     *                 <i>z</i> coordinates.
	     * @return A value of <code>true</code> if the Box object contains the
	     *         specified position; otherwise <code>false</code>.
	     */
	    Box.prototype.containsPoint = function (position) {
	        return (this.x <= position.x && this.x + this.width >= position.x && this.y <= position.y && this.y + this.height >= position.y && this.z <= position.z && this.z + this.depth >= position.z);
	    };
	    /**
	     * Determines whether the Box object specified by the <code>box</code>
	     * parameter is contained within this Box object. A Box object is said to
	     * contain another if the second Box object falls entirely within the
	     * boundaries of the first.
	     *
	     * @param box The Box object being checked.
	     * @return A value of <code>true</code> if the Box object that you specify
	     *         is contained by this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.containsBox = function (box) {
	        return (this.x <= box.x && this.x + this.width >= box.x + box.width && this.y <= box.y && this.y + this.height >= box.y + box.height && this.z <= box.z && this.z + this.depth >= box.z + box.depth);
	    };
	    /**
	     * Copies all of box data from the source Box object into the calling
	     * Box object.
	     *
	     * @param sourceBox The Box object from which to copy the data.
	     */
	    Box.prototype.copyFrom = function (sourceBox) {
	        this.x = sourceBox.x;
	        this.y = sourceBox.y;
	        this.z = sourceBox.z;
	        this.width = sourceBox.width;
	        this.height = sourceBox.height;
	        this.depth = sourceBox.depth;
	    };
	    /**
	     * Determines whether the object specified in the <code>toCompare</code>
	     * parameter is equal to this Box object. This method compares the
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code> and <code>depth</code> properties of an object against
	     * the same properties of this Box object.
	     *
	     * @param toCompare The box to compare to this Box object.
	     * @return A value of <code>true</code> if the object has exactly the same
	     *         values for the <code>x</code>, <code>y</code>, <code>z</code>,
	     *         <code>width</code>, <code>height</code> and <code>depth</code>
	     *         properties as this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && this.width == toCompare.width && this.height == toCompare.height && this.depth == toCompare.depth);
	    };
	    /**
	     * Increases the size of the Box object by the specified amounts, in
	     * pixels. The center point of the Box object stays the same, and its
	     * size increases to the left and right by the <code>dx</code> value, to
	     * the top and the bottom by the <code>dy</code> value, and to
	     * the front and the back by the <code>dz</code> value.
	     *
	     * @param dx The value to be added to the left and the right of the Box
	     *           object. The following equation is used to calculate the new
	     *           width and position of the box:
	     * @param dy The value to be added to the top and the bottom of the Box
	     *           object. The following equation is used to calculate the new
	     *           height and position of the box:
	     * @param dz The value to be added to the front and the back of the Box
	     *           object. The following equation is used to calculate the new
	     *           depth and position of the box:
	     */
	    Box.prototype.inflate = function (dx, dy, dz) {
	        this.x -= dx / 2;
	        this.y -= dy / 2;
	        this.z -= dz / 2;
	        this.width += dx / 2;
	        this.height += dy / 2;
	        this.depth += dz / 2;
	    };
	    /**
	     * Increases the size of the Box object. This method is similar to the
	     * <code>Box.inflate()</code> method except it takes a Vector3D object as
	     * a parameter.
	     *
	     * <p>The following two code examples give the same result:</p>
	     *
	     * @param delta The <code>x</code> property of this Vector3D object is used to
	     *              increase the horizontal dimension of the Box object.
	     *              The <code>y</code> property is used to increase the vertical
	     *              dimension of the Box object.
	     *              The <code>z</code> property is used to increase the
	     *              longitudinal dimension of the Box object.
	     */
	    Box.prototype.inflatePoint = function (delta) {
	        this.x -= delta.x / 2;
	        this.y -= delta.y / 2;
	        this.z -= delta.z / 2;
	        this.width += delta.x / 2;
	        this.height += delta.y / 2;
	        this.depth += delta.z / 2;
	    };
	    /**
	     * If the Box object specified in the <code>toIntersect</code> parameter
	     * intersects with this Box object, returns the area of intersection
	     * as a Box object. If the boxes do not intersect, this method returns an
	     * empty Box object with its properties set to 0.
	     *
	     * @param toIntersect The Box object to compare against to see if it
	     *                    intersects with this Box object.
	     * @return A Box object that equals the area of intersection. If the
	     *         boxes do not intersect, this method returns an empty Box
	     *         object; that is, a box with its <code>x</code>, <code>y</code>,
	     *         <code>z</code>, <code>width</code>,  <code>height</code>, and
	     *         <code>depth</code> properties set to 0.
	     */
	    Box.prototype.intersection = function (toIntersect) {
	        if (this.intersects(toIntersect)) {
	            var i = new Box();
	            if (this.x > toIntersect.x) {
	                i.x = this.x;
	                i.width = toIntersect.x - this.x + toIntersect.width;
	                if (i.width > this.width)
	                    i.width = this.width;
	            }
	            else {
	                i.x = toIntersect.x;
	                i.width = this.x - toIntersect.x + this.width;
	                if (i.width > toIntersect.width)
	                    i.width = toIntersect.width;
	            }
	            if (this.y > toIntersect.y) {
	                i.y = this.y;
	                i.height = toIntersect.y - this.y + toIntersect.height;
	                if (i.height > this.height)
	                    i.height = this.height;
	            }
	            else {
	                i.y = toIntersect.y;
	                i.height = this.y - toIntersect.y + this.height;
	                if (i.height > toIntersect.height)
	                    i.height = toIntersect.height;
	            }
	            if (this.z > toIntersect.z) {
	                i.z = this.z;
	                i.depth = toIntersect.z - this.z + toIntersect.depth;
	                if (i.depth > this.depth)
	                    i.depth = this.depth;
	            }
	            else {
	                i.z = toIntersect.z;
	                i.depth = this.z - toIntersect.z + this.depth;
	                if (i.depth > toIntersect.depth)
	                    i.depth = toIntersect.depth;
	            }
	            return i;
	        }
	        return new Box();
	    };
	    /**
	     * Determines whether the object specified in the <code>toIntersect</code>
	     * parameter intersects with this Box object. This method checks the
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code>, and <code>depth</code> properties of the specified
	     * Box object to see if it intersects with this Box object.
	     *
	     * @param toIntersect The Box object to compare against this Box object.
	     * @return A value of <code>true</code> if the specified object intersects
	     *         with this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.intersects = function (toIntersect) {
	        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height && this.z + this.depth > toIntersect.z && this.z < toIntersect.z + toIntersect.depth);
	    };
	    Box.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this.containsPoint(position))
	            return 0;
	        var halfExtentsX = this.width / 2;
	        var halfExtentsY = this.height / 2;
	        var halfExtentsZ = this.depth / 2;
	        var centerX = this.x + halfExtentsX;
	        var centerY = this.y + halfExtentsY;
	        var centerZ = this.z + halfExtentsZ;
	        var px = position.x - centerX;
	        var py = position.y - centerY;
	        var pz = position.z - centerZ;
	        var vx = direction.x;
	        var vy = direction.y;
	        var vz = direction.z;
	        var ix;
	        var iy;
	        var iz;
	        var rayEntryDistance;
	        // ray-plane tests
	        var intersects;
	        if (vx < 0) {
	            rayEntryDistance = (halfExtentsX - px) / vx;
	            if (rayEntryDistance > 0) {
	                iy = py + rayEntryDistance * vy;
	                iz = pz + rayEntryDistance * vz;
	                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 1;
	                    targetNormal.y = 0;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vx > 0) {
	            rayEntryDistance = (-halfExtentsX - px) / vx;
	            if (rayEntryDistance > 0) {
	                iy = py + rayEntryDistance * vy;
	                iz = pz + rayEntryDistance * vz;
	                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = -1;
	                    targetNormal.y = 0;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vy < 0) {
	            rayEntryDistance = (halfExtentsY - py) / vy;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iz = pz + rayEntryDistance * vz;
	                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 1;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vy > 0) {
	            rayEntryDistance = (-halfExtentsY - py) / vy;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iz = pz + rayEntryDistance * vz;
	                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 0;
	                    targetNormal.y = -1;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vz < 0) {
	            rayEntryDistance = (halfExtentsZ - pz) / vz;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iy = py + rayEntryDistance * vy;
	                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 0;
	                    targetNormal.z = 1;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vz > 0) {
	            rayEntryDistance = (-halfExtentsZ - pz) / vz;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iy = py + rayEntryDistance * vy;
	                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 0;
	                    targetNormal.z = -1;
	                    intersects = true;
	                }
	            }
	        }
	        return intersects ? rayEntryDistance : -1;
	    };
	    /**
	     * Finds the closest point on the Box to another given point. This can be used for maximum error calculations for content within a given Box.
	     *
	     * @param point The point for which to find the closest point on the Box
	     * @param target An optional Vector3D to store the result to prevent creating a new object.
	     * @return
	     */
	    Box.prototype.closestPointToPoint = function (point, target) {
	        if (target === void 0) { target = null; }
	        var p;
	        if (target == null)
	            target = new Vector3D_1.default();
	        p = point.x;
	        if (p < this.x)
	            p = this.x;
	        if (p > this.x + this.width)
	            p = this.x + this.width;
	        target.x = p;
	        p = point.y;
	        if (p < this.y + this.height)
	            p = this.y + this.height;
	        if (p > this.y)
	            p = this.y;
	        target.y = p;
	        p = point.z;
	        if (p < this.z)
	            p = this.z;
	        if (p > this.z + this.depth)
	            p = this.z + this.depth;
	        target.z = p;
	        return target;
	    };
	    /**
	     * Determines whether or not this Box object is empty.
	     *
	     * @return A value of <code>true</code> if the Box object's width, height or
	     *         depth is less than or equal to 0; otherwise <code>false</code>.
	     */
	    Box.prototype.isEmpty = function () {
	        return (this.x == 0 && this.y == 0 && this.z == 0 && this.width == 0 && this.height == 0 && this.depth == 0);
	    };
	    /**
	     * Adjusts the location of the Box object, as determined by its
	     * top-left-front corner, by the specified amounts.
	     *
	     * @param dx Moves the <i>x</i> value of the Box object by this amount.
	     * @param dy Moves the <i>y</i> value of the Box object by this amount.
	     * @param dz Moves the <i>z</i> value of the Box object by this amount.
	     */
	    Box.prototype.offset = function (dx, dy, dz) {
	        this.x += dx;
	        this.y += dy;
	        this.z += dz;
	    };
	    /**
	     * Adjusts the location of the Box object using a Vector3D object as a
	     * parameter. This method is similar to the <code>Box.offset()</code>
	     * method, except that it takes a Vector3D object as a parameter.
	     *
	     * @param position A Vector3D object to use to offset this Box object.
	     */
	    Box.prototype.offsetPosition = function (position) {
	        this.x += position.x;
	        this.y += position.y;
	        this.z += position.z;
	    };
	    /**
	     * Sets all of the Box object's properties to 0. A Box object is empty if its
	     * width, height or depth is less than or equal to 0.
	     *
	     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
	     * <code>z</code>, <code>width</code>, <code>height</code>, and
	     * <code>depth</code> properties to 0.</p>
	     *
	     */
	    Box.prototype.setEmpty = function () {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.width = 0;
	        this.height = 0;
	        this.depth = 0;
	    };
	    Box.prototype.setBoundIdentity = function () {
	        this.x = Number.MAX_VALUE / 2;
	        this.y = Number.MAX_VALUE / 2;
	        this.z = Number.MAX_VALUE / 2;
	        this.width = -Number.MAX_VALUE;
	        this.height = -Number.MAX_VALUE;
	        this.depth = -Number.MAX_VALUE;
	    };
	    /**
	     * Sets the members of Box to the specified values
	     *
	     * @param xa      The <i>x</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param ya      The <i>y</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param yz      The <i>z</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param widtha  The width of the box, in pixels.
	     * @param heighta The height of the box, in pixels.
	     * @param deptha  The depth of the box, in pixels.
	     */
	    Box.prototype.setTo = function (xa, ya, za, widtha, heighta, deptha) {
	        this.x = xa;
	        this.y = ya;
	        this.z = za;
	        this.width = widtha;
	        this.height = heighta;
	        this.depth = deptha;
	    };
	    /**
	     * Builds and returns a string that lists the horizontal, vertical and
	     * longitudinal positions and the width, height and depth of the Box object.
	     *
	     * @return A string listing the value of each of the following properties of
	     *         the Box object: <code>x</code>, <code>y</code>, <code>z</code>,
	     *         <code>width</code>, <code>height</code>, and <code>depth</code>.
	     */
	    Box.prototype.toString = function () {
	        return "[Box] (x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", width=" + this.width + ", height=" + this.height + ", depth=" + this.depth + ")";
	    };
	    /**
	     * Adds two boxes together to create a new Box object, by filling
	     * in the horizontal, vertical and longitudinal space between the two boxes.
	     *
	     * <p><b>Note:</b> The <code>union()</code> method ignores boxes with
	     * <code>0</code> as the height, width or depth value, such as: <code>var
	     * box2:Box = new Box(300,300,300,50,50,0);</code></p>
	     *
	     * @param toUnion A Box object to add to this Box object.
	     * @return A new Box object that is the union of the two boxes.
	     */
	    Box.prototype.union = function (toUnion, target) {
	        if (target === void 0) { target = null; }
	        if (target == null)
	            target = new Box();
	        if (this.x < toUnion.x) {
	            target.x = this.x;
	            target.width = toUnion.x - this.x + toUnion.width;
	            if (target.width < this.width)
	                target.width = this.width;
	        }
	        else {
	            target.x = toUnion.x;
	            target.width = this.x - toUnion.x + this.width;
	            if (target.width < toUnion.width)
	                target.width = toUnion.width;
	        }
	        if (this.y < toUnion.y) {
	            target.y = this.y;
	            target.height = toUnion.y - this.y + toUnion.height;
	            if (target.height < this.height)
	                target.height = this.height;
	        }
	        else {
	            target.y = toUnion.y;
	            target.height = this.y - toUnion.y + this.height;
	            if (target.height < toUnion.height)
	                target.height = toUnion.height;
	        }
	        if (this.z < toUnion.z) {
	            target.z = this.z;
	            target.depth = toUnion.z - this.z + toUnion.depth;
	            if (target.depth < this.depth)
	                target.depth = this.depth;
	        }
	        else {
	            target.z = toUnion.z;
	            target.depth = this.z - toUnion.z + this.depth;
	            if (target.depth < toUnion.depth)
	                target.depth = toUnion.depth;
	        }
	        return target;
	    };
	    return Box;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Box;


/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The Vector3D class represents a point or a location in the three-dimensional
	 * space using the Cartesian coordinates x, y, and z. As in a two-dimensional
	 * space, the x property represents the horizontal axis and the y property
	 * represents the vertical axis. In three-dimensional space, the z property
	 * represents depth. The value of the x property increases as the object moves
	 * to the right. The value of the y property increases as the object moves
	 * down. The z property increases as the object moves farther from the point
	 * of view. Using perspective projection and scaling, the object is seen to be
	 * bigger when near and smaller when farther away from the screen. As in a
	 * right-handed three-dimensional coordinate system, the positive z-axis points
	 * away from the viewer and the value of the z property increases as the object
	 * moves away from the viewer's eye. The origin point (0,0,0) of the global
	 * space is the upper-left corner of the stage.
	 *
	 * <p>The Vector3D class can also represent a direction, an arrow pointing from
	 * the origin of the coordinates, such as (0,0,0), to an endpoint; or a
	 * floating-point component of an RGB (Red, Green, Blue) color model.</p>
	 *
	 * <p>Quaternion notation introduces a fourth element, the w property, which
	 * provides additional orientation information. For example, the w property can
	 * define an angle of rotation of a Vector3D object. The combination of the
	 * angle of rotation and the coordinates x, y, and z can determine the display
	 * object's orientation. Here is a representation of Vector3D elements in
	 * matrix notation:</p>
	 */
	var Vector3D = (function () {
	    /**
	     * Creates an instance of a Vector3D object. If you do not specify a
	     * parameter for the constructor, a Vector3D object is created with
	     * the elements (0,0,0,0).
	     *
	     * @param x The first element, such as the x coordinate.
	     * @param y The second element, such as the y coordinate.
	     * @param z The third element, such as the z coordinate.
	     * @param w An optional element for additional data such as the angle
	     *          of rotation.
	     */
	    function Vector3D(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    Object.defineProperty(Vector3D.prototype, "length", {
	        /**
	         * The length, magnitude, of the current Vector3D object from the
	         * origin (0,0,0) to the object's x, y, and z coordinates. The w
	         * property is ignored. A unit vector has a length or magnitude of
	         * one.
	         */
	        get: function () {
	            return Math.sqrt(this.lengthSquared);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector3D.prototype, "lengthSquared", {
	        /**
	         * The square of the length of the current Vector3D object, calculated
	         * using the x, y, and z properties. The w property is ignored. Use the
	         * <code>lengthSquared()</code> method whenever possible instead of the
	         * slower <code>Math.sqrt()</code> method call of the
	         * <code>Vector3D.length()</code> method.
	         */
	        get: function () {
	            return this.x * this.x + this.y * this.y + this.z * this.z;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds the value of the x, y, and z elements of the current Vector3D
	     * object to the values of the x, y, and z elements of another Vector3D
	     * object. The <code>add()</code> method does not change the current
	     * Vector3D object. Instead, it returns a new Vector3D object with
	     * the new values.
	     *
	     * <p>The result of adding two vectors together is a resultant vector.
	     * One way to visualize the result is by drawing a vector from the
	     * origin or tail of the first vector to the end or head of the second
	     * vector. The resultant vector is the distance between the origin
	     * point of the first vector and the end point of the second vector.
	     * </p>
	     */
	    Vector3D.prototype.add = function (a) {
	        return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
	    };
	    /**
	     * Returns the angle in radians between two vectors. The returned angle
	     * is the smallest radian the first Vector3D object rotates until it
	     * aligns with the second Vector3D object.
	     *
	     * <p>The <code>angleBetween()</code> method is a static method. You
	     * can use it directly as a method of the Vector3D class.</p>
	     *
	     * <p>To convert a degree to a radian, you can use the following
	     * formula:</p>
	     *
	     * <p><code>radian = Math.PI/180 * degree</code></p>
	     *
	     * @param a The first Vector3D object.
	     * @param b The second Vector3D object.
	     * @returns The angle between two Vector3D objects.
	     */
	    Vector3D.angleBetween = function (a, b) {
	        return Math.acos(a.dotProduct(b) / (a.length * b.length));
	    };
	    /**
	     * Returns a new Vector3D object that is an exact copy of the current
	     * Vector3D object.
	     *
	     * @returns A new Vector3D object that is a copy of the current
	     * Vector3D object.
	     */
	    Vector3D.prototype.clone = function () {
	        return new Vector3D(this.x, this.y, this.z, this.w);
	    };
	    Vector3D.combine = function (a, b, ascl, bscl) {
	        return new Vector3D(a.x * ascl + b.x * bscl, a.y * ascl + b.y * bscl, a.z * ascl + b.z * bscl);
	    };
	    /**
	     * Copies all of vector data from the source Vector3D object into the
	     * calling Vector3D object.
	     *
	     * @param src The Vector3D object from which to copy the data.
	     */
	    Vector3D.prototype.copyFrom = function (src) {
	        this.x = src.x;
	        this.y = src.y;
	        this.z = src.z;
	        this.w = src.w;
	    };
	    /**
	     * Returns a new Vector3D object that is perpendicular (at a right
	     * angle) to the current Vector3D and another Vector3D object. If the
	     * returned Vector3D object's coordinates are (0,0,0), then the two
	     * Vector3D objects are parallel to each other.
	     *
	     * <p>You can use the normalized cross product of two vertices of a
	     * polygon surface with the normalized vector of the camera or eye
	     * viewpoint to get a dot product. The value of the dot product can
	     * identify whether a surface of a three-dimensional object is hidden
	     * from the viewpoint.</p>
	     *
	     * @param a A second Vector3D object.
	     * @returns A new Vector3D object that is perpendicular to the current
	     *          Vector3D object and the Vector3D object specified as the
	     *          parameter.
	     */
	    Vector3D.prototype.crossProduct = function (a) {
	        return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
	    };
	    /**
	     * Decrements the value of the x, y, and z elements of the current
	     * Vector3D object by the values of the x, y, and z elements of
	     * specified Vector3D object. Unlike the
	     * <code>Vector3D.subtract()</code> method, the
	     * <code>decrementBy()</code> method changes the current Vector3D
	     * object and does not return a new Vector3D object.
	     *
	     * @param a The Vector3D object containing the values to subtract from
	     *          the current Vector3D object.
	     */
	    Vector3D.prototype.decrementBy = function (a) {
	        this.x -= a.x;
	        this.y -= a.y;
	        this.z -= a.z;
	    };
	    /**
	     * Returns the distance between two Vector3D objects. The
	     * <code>distance()</code> method is a static method. You can use it
	     * directly as a method of the Vector3D class to get the Euclidean
	     * distance between two three-dimensional points.
	     *
	     * @param pt1 A Vector3D object as the first three-dimensional point.
	     * @param pt2 A Vector3D object as the second three-dimensional point.
	     * @returns The distance between two Vector3D objects.
	     */
	    Vector3D.distance = function (pt1, pt2) {
	        var x = (pt1.x - pt2.x);
	        var y = (pt1.y - pt2.y);
	        var z = (pt1.z - pt2.z);
	        return Math.sqrt(x * x + y * y + z * z);
	    };
	    /**
	     * If the current Vector3D object and the one specified as the
	     * parameter are unit vertices, this method returns the cosine of the
	     * angle between the two vertices. Unit vertices are vertices that
	     * point to the same direction but their length is one. They remove the
	     * length of the vector as a factor in the result. You can use the
	     * <code>normalize()</code> method to convert a vector to a unit
	     * vector.
	     *
	     * <p>The <code>dotProduct()</code> method finds the angle between two
	     * vertices. It is also used in backface culling or lighting
	     * calculations. Backface culling is a procedure for determining which
	     * surfaces are hidden from the viewpoint. You can use the normalized
	     * vertices from the camera, or eye, viewpoint and the cross product of
	     * the vertices of a polygon surface to get the dot product. If the dot
	     * product is less than zero, then the surface is facing the camera or
	     * the viewer. If the two unit vertices are perpendicular to each
	     * other, they are orthogonal and the dot product is zero. If the two
	     * vertices are parallel to each other, the dot product is one.</p>
	     *
	     * @param a The second Vector3D object.
	     * @returns A scalar which is the dot product of the current Vector3D
	     *          object and the specified Vector3D object.
	     *
	     * @see away.geom.Vector3D#crossProduct()
	     * @see away.geom.Vector3D#normalize()
	     */
	    Vector3D.prototype.dotProduct = function (a) {
	        return this.x * a.x + this.y * a.y + this.z * a.z;
	    };
	    /**
	     * Determines whether two Vector3D objects are equal by comparing the
	     * x, y, and z elements of the current Vector3D object with a
	     * specified Vector3D object. If the values of these elements are the
	     * same, the two Vector3D objects are equal. If the second optional
	     * parameter is set to true, all four elements of the Vector3D objects,
	     * including the w property, are compared.
	     */
	    /**
	     *
	     * @param toCompare The Vector3D object to be compared with the current
	     *                  Vector3D object.
	     * @param allFour   An optional parameter that specifies whether the w
	     *                  property of the Vector3D objects is used in the
	     *                  comparison.
	     * @returns A value of true if the specified Vector3D object is equal
	     *          to the current Vector3D object; false if it is not equal.
	     */
	    Vector3D.prototype.equals = function (toCompare, allFour) {
	        if (allFour === void 0) { allFour = false; }
	        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
	    };
	    /**
	     * Increments the value of the x, y, and z elements of the current
	     * Vector3D object by the values of the x, y, and z elements of a
	     * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
	     * method, the <code>incrementBy()</code> method changes the current
	     * Vector3D object and does not return a new Vector3D object.
	     *
	     * @param a The Vector3D object to be added to the current Vector3D
	     *          object.
	     */
	    Vector3D.prototype.incrementBy = function (a) {
	        this.x += a.x;
	        this.y += a.y;
	        this.z += a.z;
	    };
	    /**
	     * Compares the elements of the current Vector3D object with the
	     * elements of a specified Vector3D object to determine whether they
	     * are nearly equal. The two Vector3D objects are nearly equal if the
	     * value of all the elements of the two vertices are equal, or the
	     * result of the comparison is within the tolerance range. The
	     * difference between two elements must be less than the number
	     * specified as the tolerance parameter. If the third optional
	     * parameter is set to <code>true</code>, all four elements of the
	     * Vector3D objects, including the <code>w</code> property, are
	     * compared. Otherwise, only the x, y, and z elements are included in
	     * the comparison.
	     */
	    /**
	     *
	     * @param toCompare The Vector3D object to be compared with the current
	     *                  Vector3D object.
	     * @param tolerance A number determining the tolerance factor. If the
	     *                  difference between the values of the Vector3D
	     *                  element specified in the toCompare parameter and
	     *                  the current Vector3D element is less than the
	     *                  tolerance number, the two values are considered
	     *                  nearly equal.
	     * @param allFour   An optional parameter that specifies whether the w
	     *                  property of the Vector3D objects is used in the
	     *                  comparison.
	     * @returns A value of true if the specified Vector3D object is nearly
	     *          equal to the current Vector3D object; false if it is not
	     *          equal.
	     *
	     * @see away.geom.Vector3D#equals()
	     */
	    Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
	        if (allFour === void 0) { allFour = true; }
	        return ((Math.abs(this.x - toCompare.x) < tolerance) && (Math.abs(this.y - toCompare.y) < tolerance) && (Math.abs(this.z - toCompare.z) < tolerance) && (!allFour || Math.abs(this.w - toCompare.w) < tolerance));
	    };
	    /**
	     * Sets the current Vector3D object to its inverse. The inverse object
	     * is also considered the opposite of the original object. The value of
	     * the x, y, and z properties of the current Vector3D object is changed
	     * to -x, -y, and -z.
	     */
	    Vector3D.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	    };
	    /**
	     * Converts a Vector3D object to a unit vector by dividing the first
	     * three elements (x, y, z) by the length of the vector. Unit vertices
	     * are vertices that have a direction but their length is one. They
	     * simplify vector calculations by removing length as a factor.
	     */
	    /**
	     * Scales the line segment between(0,0) and the current point to a set
	     * length.
	     *
	     * @param thickness The scaling value. For example, if the current
	     *                  Vector3D object is (0,3,4), and you normalize it to
	     *                  1, the point returned is at(0,0.6,0.8).
	     */
	    Vector3D.prototype.normalize = function (thickness) {
	        if (thickness === void 0) { thickness = 1; }
	        if (this.length != 0) {
	            var invLength = thickness / this.length;
	            this.x *= invLength;
	            this.y *= invLength;
	            this.z *= invLength;
	            return;
	        }
	    };
	    /**
	     * Divides the value of the <code>x</code>, <code>y</code>, and
	     * <code>z</code> properties of the current Vector3D object by the
	     * value of its <code>w</code> property.
	     *
	     * <p>If the current Vector3D object is the result of multiplying a
	     * Vector3D object by a projection Matrix3D object, the w property can
	     * hold the transform value. The <code>project()</code> method then can
	     * complete the projection by dividing the elements by the
	     * <code>w</code> property. Use the <code>Matrix3D.rawData</code>
	     * property to create a projection Matrix3D object.</p>
	     */
	    Vector3D.prototype.project = function () {
	        this.x /= this.w;
	        this.y /= this.w;
	        this.z /= this.w;
	    };
	    /**
	     * Scales the current Vector3D object by a scalar, a magnitude. The
	     * Vector3D object's x, y, and z elements are multiplied by the scalar
	     * number specified in the parameter. For example, if the vector is
	     * scaled by ten, the result is a vector that is ten times longer. The
	     * scalar can also change the direction of the vector. Multiplying the
	     * vector by a negative number reverses its direction.
	     *
	     * @param s A multiplier (scalar) used to scale a Vector3D object.

	     */
	    Vector3D.prototype.scaleBy = function (s) {
	        this.x *= s;
	        this.y *= s;
	        this.z *= s;
	    };
	    /**
	     * Sets the members of Vector3D to the specified values
	     *
	     * @param xa The first element, such as the x coordinate.
	     * @param ya The second element, such as the y coordinate.
	     * @param za The third element, such as the z coordinate.
	     */
	    Vector3D.prototype.setTo = function (xa, ya, za) {
	        this.x = xa;
	        this.y = ya;
	        this.z = za;
	    };
	    /**
	     * Subtracts the value of the x, y, and z elements of the current
	     * Vector3D object from the values of the x, y, and z elements of
	     * another Vector3D object. The <code>subtract()</code> method does not
	     * change the current Vector3D object. Instead, this method returns a
	     * new Vector3D object with the new values.
	     *
	     * @param a The Vector3D object to be subtracted from the current
	     *          Vector3D object.
	     * @returns A new Vector3D object that is the difference between the
	     *          current Vector3D and the specified Vector3D object.
	     *
	     * @see away.geom.Vector3D#decrementBy()
	     */
	    Vector3D.prototype.subtract = function (a) {
	        return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
	    };
	    /**
	     * Returns a string representation of the current Vector3D object. The
	     * string contains the values of the x, y, and z properties.
	     */
	    Vector3D.prototype.toString = function () {
	        return "[Vector3D] (x:" + this.x + " ,y:" + this.y + ", z" + this.z + ", w:" + this.w + ")";
	    };
	    /**
	     * The x axis defined as a Vector3D object with coordinates (1,0,0).
	     */
	    Vector3D.X_AXIS = new Vector3D(1, 0, 0);
	    /**
	     * The y axis defined as a Vector3D object with coordinates (0,1,0).
	     */
	    Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
	    /**
	     * The z axis defined as a Vector3D object with coordinates (0,0,1).
	     */
	    Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
	    return Vector3D;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Vector3D;


/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";
	/**
	* MathConsts provides some commonly used mathematical constants
	*/
	var MathConsts = (function () {
	    function MathConsts() {
	    }
	    /**
	     * The amount to multiply with when converting radians to degrees.
	     */
	    MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
	    /**
	     * The amount to multiply with when converting degrees to radians.
	     */
	    MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
	    return MathConsts;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MathConsts;


/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A Quaternion object which can be used to represent rotations.
	 */
	var Orientation3D = (function () {
	    function Orientation3D() {
	    }
	    /**
	     * The axis angle orientation uses a combination of an axis and an angle to determine the orientation.
	     * @type {string}
	     */
	    Orientation3D.AXIS_ANGLE = "axisAngle";
	    /**
	     * The default orientation for decompose() and recompose() methods, defines the orientation with three separate angles of rotation for each axis.
	     * @type {string}
	     */
	    Orientation3D.EULER_ANGLES = "eulerAngles";
	    /**
	     * The quaternion orientation uses complex numbers.
	     * @type {string}
	     */
	    Orientation3D.QUATERNION = "quaternion";
	    return Orientation3D;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Orientation3D;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	/**
	 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
	 * by a concrete subclass.
	 */
	var ArgumentError = (function (_super) {
	    __extends(ArgumentError, _super);
	    /**
	     * Create a new ArgumentError.
	     *
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function ArgumentError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "ArgumentError", id);
	    }
	    return ArgumentError;
	}(ErrorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ArgumentError;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(28);
	var Rectangle_1 = __webpack_require__(35);
	var EventDispatcher_1 = __webpack_require__(12);
	var ProjectionEvent_1 = __webpack_require__(37);
	var AbstractMethodError_1 = __webpack_require__(20);
	var ProjectionBase = (function (_super) {
	    __extends(ProjectionBase, _super);
	    function ProjectionBase(coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        _super.call(this);
	        this._pMatrix = new Matrix3D_1.default();
	        this._pScissorRect = new Rectangle_1.default();
	        this._pViewPort = new Rectangle_1.default();
	        this._pNear = 20;
	        this._pFar = 3000;
	        this._pAspectRatio = 1;
	        this._pMatrixInvalid = true;
	        this._pFrustumCorners = [];
	        this._pOriginX = 0.5;
	        this._pOriginY = 0.5;
	        this._unprojectionInvalid = true;
	        this.coordinateSystem = coordinateSystem;
	    }
	    Object.defineProperty(ProjectionBase.prototype, "coordinateSystem", {
	        /**
	         * The handedness of the coordinate system projection. The default is LEFT_HANDED.
	         */
	        get: function () {
	            return this._pCoordinateSystem;
	        },
	        set: function (value) {
	            if (this._pCoordinateSystem == value)
	                return;
	            this._pCoordinateSystem = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "frustumCorners", {
	        get: function () {
	            return this._pFrustumCorners;
	        },
	        set: function (frustumCorners) {
	            this._pFrustumCorners = frustumCorners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "matrix", {
	        get: function () {
	            if (this._pMatrixInvalid) {
	                this.pUpdateMatrix();
	                this._pMatrixInvalid = false;
	            }
	            return this._pMatrix;
	        },
	        set: function (value) {
	            this._pMatrix = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "near", {
	        get: function () {
	            return this._pNear;
	        },
	        set: function (value) {
	            if (value == this._pNear) {
	                return;
	            }
	            this._pNear = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "originX", {
	        get: function () {
	            return this._pOriginX;
	        },
	        set: function (value) {
	            if (this._pOriginX == value)
	                return;
	            this._pOriginX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "originY", {
	        get: function () {
	            return this._pOriginY;
	        },
	        set: function (value) {
	            if (this._pOriginY == value)
	                return;
	            this._pOriginY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "far", {
	        get: function () {
	            return this._pFar;
	        },
	        set: function (value) {
	            if (value == this._pFar) {
	                return;
	            }
	            this._pFar = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.project = function (point3d) {
	        var v = this.matrix.transformVector(point3d);
	        v.x = v.x / v.w;
	        v.y = -v.y / v.w;
	        //z is unaffected by transform
	        v.z = point3d.z;
	        return v;
	    };
	    Object.defineProperty(ProjectionBase.prototype, "unprojectionMatrix", {
	        get: function () {
	            if (this._unprojectionInvalid) {
	                if (!this._unprojection)
	                    this._unprojection = new Matrix3D_1.default();
	                this._unprojection.copyFrom(this.matrix);
	                this._unprojection.invert();
	                this._unprojectionInvalid = false;
	            }
	            return this._unprojection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.unproject = function (nX, nY, sZ) {
	        throw new AbstractMethodError_1.default();
	    };
	    ProjectionBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    Object.defineProperty(ProjectionBase.prototype, "_iAspectRatio", {
	        get: function () {
	            return this._pAspectRatio;
	        },
	        set: function (value) {
	            if (this._pAspectRatio == value)
	                return;
	            this._pAspectRatio = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.pInvalidateMatrix = function () {
	        this._pMatrixInvalid = true;
	        this._unprojectionInvalid = true;
	        this.dispatchEvent(new ProjectionEvent_1.default(ProjectionEvent_1.default.MATRIX_CHANGED, this));
	    };
	    ProjectionBase.prototype.pUpdateMatrix = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    ProjectionBase.prototype._iUpdateScissorRect = function (x, y, width, height) {
	        this._pScissorRect.x = x;
	        this._pScissorRect.y = y;
	        this._pScissorRect.width = width;
	        this._pScissorRect.height = height;
	        this.pInvalidateMatrix();
	    };
	    ProjectionBase.prototype._iUpdateViewport = function (x, y, width, height) {
	        this._pViewPort.x = x;
	        this._pViewPort.y = y;
	        this._pViewPort.width = width;
	        this._pViewPort.height = height;
	        this.pInvalidateMatrix();
	    };
	    return ProjectionBase;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ProjectionBase;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Point_1 = __webpack_require__(36);
	/**
	 * A Rectangle object is an area defined by its position, as indicated by its
	 * top-left corner point(<i>x</i>, <i>y</i>) and by its width and its height.
	 *
	 *
	 * <p>The <code>x</code>, <code>y</code>, <code>width</code>, and
	 * <code>height</code> properties of the Rectangle class are independent of
	 * each other; changing the value of one property has no effect on the others.
	 * However, the <code>right</code> and <code>bottom</code> properties are
	 * integrally related to those four properties. For example, if you change the
	 * value of the <code>right</code> property, the value of the
	 * <code>width</code> property changes; if you change the <code>bottom</code>
	 * property, the value of the <code>height</code> property changes. </p>
	 *
	 * <p>The following methods and properties use Rectangle objects:</p>
	 *
	 * <ul>
	 *   <li>The <code>applyFilter()</code>, <code>colorTransform()</code>,
	 * <code>copyChannel()</code>, <code>copyPixels()</code>, <code>draw()</code>,
	 * <code>fillRect()</code>, <code>generateFilterRect()</code>,
	 * <code>getColorBoundsRect()</code>, <code>getPixels()</code>,
	 * <code>merge()</code>, <code>paletteMap()</code>,
	 * <code>pixelDisolve()</code>, <code>setPixels()</code>, and
	 * <code>threshold()</code> methods, and the <code>rect</code> property of the
	 * BitmapData class</li>
	 *   <li>The <code>getBounds()</code> and <code>getRect()</code> methods, and
	 * the <code>scrollRect</code> and <code>scale9Grid</code> properties of the
	 * DisplayObject class</li>
	 *   <li>The <code>getCharBoundaries()</code> method of the TextField
	 * class</li>
	 *   <li>The <code>pixelBounds</code> property of the Transform class</li>
	 *   <li>The <code>bounds</code> parameter for the <code>startDrag()</code>
	 * method of the Sprite class</li>
	 *   <li>The <code>printArea</code> parameter of the <code>addPage()</code>
	 * method of the PrintJob class</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Rectangle()</code> constructor to create a
	 * Rectangle object.</p>
	 *
	 * <p><b>Note:</b> The Rectangle class does not define a rectangular Shape
	 * display object. To draw a rectangular Shape object onscreen, use the
	 * <code>drawRect()</code> method of the Graphics class.</p>
	 */
	var Rectangle = (function () {
	    /**
	     * Creates a new Rectangle object with the top-left corner specified by the
	     * <code>x</code> and <code>y</code> parameters and with the specified
	     * <code>width</code> and <code>height</code> parameters. If you call this
	     * public without parameters, a rectangle with <code>x</code>,
	     * <code>y</code>, <code>width</code>, and <code>height</code> properties set
	     * to 0 is created.
	     *
	     * @param x      The <i>x</i> coordinate of the top-left corner of the
	     *               rectangle.
	     * @param y      The <i>y</i> coordinate of the top-left corner of the
	     *               rectangle.
	     * @param width  The width of the rectangle, in pixels.
	     * @param height The height of the rectangle, in pixels.
	     */
	    function Rectangle(x, y, width, height) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (width === void 0) { width = 0; }
	        if (height === void 0) { height = 0; }
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	    }
	    Object.defineProperty(Rectangle.prototype, "bottom", {
	        /**
	         * The sum of the <code>y</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.y + this.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "bottomRight", {
	        /**
	         * The location of the Rectangle object's bottom-right corner, determined by
	         * the values of the <code>right</code> and <code>bottom</code> properties.
	         */
	        get: function () {
	            if (this._bottomRight == null)
	                this._bottomRight = new Point_1.default();
	            this._bottomRight.x = this.x + this.width;
	            this._bottomRight.y = this.y + this.height;
	            return this._bottomRight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "left", {
	        /**
	         * The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	         * the <code>left</code> property of a Rectangle object has no effect on the
	         * <code>y</code> and <code>height</code> properties. However it does affect
	         * the <code>width</code> property, whereas changing the <code>x</code> value
	         * does <i>not</i> affect the <code>width</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.x;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "right", {
	        /**
	         * The sum of the <code>x</code> and <code>width</code> properties.
	         */
	        get: function () {
	            return this.x + this.width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "size", {
	        /**
	         * The size of the Rectangle object, expressed as a Point object with the
	         * values of the <code>width</code> and <code>height</code> properties.
	         */
	        get: function () {
	            if (this._size == null)
	                this._size = new Point_1.default();
	            this._size.x = this.width;
	            this._size.y = this.height;
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "top", {
	        /**
	         * The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	         * the <code>top</code> property of a Rectangle object has no effect on the
	         * <code>x</code> and <code>width</code> properties. However it does affect
	         * the <code>height</code> property, whereas changing the <code>y</code>
	         * value does <i>not</i> affect the <code>height</code> property.
	         *
	         * <p>The value of the <code>top</code> property is equal to the value of the
	         * <code>y</code> property.</p>
	         */
	        get: function () {
	            return this.y;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "topLeft", {
	        /**
	         * The location of the Rectangle object's top-left corner, determined by the
	         * <i>x</i> and <i>y</i> coordinates of the point.
	         */
	        get: function () {
	            if (this._topLeft == null)
	                this._topLeft = new Point_1.default();
	            this._topLeft.x = this.x;
	            this._topLeft.y = this.y;
	            return this._topLeft;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new Rectangle object with the same values for the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties as the original Rectangle object.
	     *
	     * @return A new Rectangle object with the same values for the
	     *         <code>x</code>, <code>y</code>, <code>width</code>, and
	     *         <code>height</code> properties as the original Rectangle object.
	     */
	    Rectangle.prototype.clone = function () {
	        return new Rectangle(this.x, this.y, this.width, this.height);
	    };
	    /**
	     * Determines whether the specified point is contained within the rectangular
	     * region defined by this Rectangle object.
	     *
	     * @param x The <i>x</i> coordinate(horizontal position) of the point.
	     * @param y The <i>y</i> coordinate(vertical position) of the point.
	     * @return A value of <code>true</code> if the Rectangle object contains the
	     *         specified point; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.contains = function (x, y) {
	        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y);
	    };
	    /**
	     * Determines whether the specified point is contained within the rectangular
	     * region defined by this Rectangle object. This method is similar to the
	     * <code>Rectangle.contains()</code> method, except that it takes a Point
	     * object as a parameter.
	     *
	     * @param point The point, as represented by its <i>x</i> and <i>y</i>
	     *              coordinates.
	     * @return A value of <code>true</code> if the Rectangle object contains the
	     *         specified point; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.containsPoint = function (point) {
	        return (this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y);
	    };
	    /**
	     * Determines whether the Rectangle object specified by the <code>rect</code>
	     * parameter is contained within this Rectangle object. A Rectangle object is
	     * said to contain another if the second Rectangle object falls entirely
	     * within the boundaries of the first.
	     *
	     * @param rect The Rectangle object being checked.
	     * @return A value of <code>true</code> if the Rectangle object that you
	     *         specify is contained by this Rectangle object; otherwise
	     *         <code>false</code>.
	     */
	    Rectangle.prototype.containsRect = function (rect) {
	        return (this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height);
	    };
	    /**
	     * Copies all of rectangle data from the source Rectangle object into the
	     * calling Rectangle object.
	     *
	     * @param sourceRect The Rectangle object from which to copy the data.
	     */
	    Rectangle.prototype.copyFrom = function (sourceRect) {
	    };
	    /**
	     * Determines whether the object specified in the <code>toCompare</code>
	     * parameter is equal to this Rectangle object. This method compares the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties of an object against the same properties of
	     * this Rectangle object.
	     *
	     * @param toCompare The rectangle to compare to this Rectangle object.
	     * @return A value of <code>true</code> if the object has exactly the same
	     *         values for the <code>x</code>, <code>y</code>, <code>width</code>,
	     *         and <code>height</code> properties as this Rectangle object;
	     *         otherwise <code>false</code>.
	     */
	    Rectangle.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width && this.height == toCompare.height);
	    };
	    /**
	     * Increases the size of the Rectangle object by the specified amounts, in
	     * pixels. The center point of the Rectangle object stays the same, and its
	     * size increases to the left and right by the <code>dx</code> value, and to
	     * the top and the bottom by the <code>dy</code> value.
	     *
	     * @param dx The value to be added to the left and the right of the Rectangle
	     *           object. The following equation is used to calculate the new
	     *           width and position of the rectangle:
	     * @param dy The value to be added to the top and the bottom of the
	     *           Rectangle. The following equation is used to calculate the new
	     *           height and position of the rectangle:
	     */
	    Rectangle.prototype.inflate = function (dx, dy) {
	        this.x -= dx / 2;
	        this.y -= dy / 2;
	        this.width += dx / 2;
	        this.height += dy / 2;
	    };
	    /**
	     * Increases the size of the Rectangle object. This method is similar to the
	     * <code>Rectangle.inflate()</code> method except it takes a Point object as
	     * a parameter.
	     *
	     * <p>The following two code examples give the same result:</p>
	     *
	     * @param point The <code>x</code> property of this Point object is used to
	     *              increase the horizontal dimension of the Rectangle object.
	     *              The <code>y</code> property is used to increase the vertical
	     *              dimension of the Rectangle object.
	     */
	    Rectangle.prototype.inflatePoint = function (point) {
	        this.x -= point.x / 2;
	        this.y -= point.y / 2;
	        this.width += point.x / 2;
	        this.height += point.y / 2;
	    };
	    /**
	     * If the Rectangle object specified in the <code>toIntersect</code>
	     * parameter intersects with this Rectangle object, returns the area of
	     * intersection as a Rectangle object. If the rectangles do not intersect,
	     * this method returns an empty Rectangle object with its properties set to
	     * 0.
	     *
	     * @param toIntersect The Rectangle object to compare against to see if it
	     *                    intersects with this Rectangle object.
	     * @return A Rectangle object that equals the area of intersection. If the
	     *         rectangles do not intersect, this method returns an empty
	     *         Rectangle object; that is, a rectangle with its <code>x</code>,
	     *         <code>y</code>, <code>width</code>, and <code>height</code>
	     *         properties set to 0.
	     */
	    Rectangle.prototype.intersection = function (toIntersect) {
	        if (this.intersects(toIntersect)) {
	            var i = new Rectangle();
	            if (this.x > toIntersect.x) {
	                i.x = this.x;
	                i.width = toIntersect.x - this.x + toIntersect.width;
	                if (i.width > this.width)
	                    i.width = this.width;
	            }
	            else {
	                i.x = toIntersect.x;
	                i.width = this.x - toIntersect.x + this.width;
	                if (i.width > toIntersect.width)
	                    i.width = toIntersect.width;
	            }
	            if (this.y > toIntersect.y) {
	                i.y = this.y;
	                i.height = toIntersect.y - this.y + toIntersect.height;
	                if (i.height > this.height)
	                    i.height = this.height;
	            }
	            else {
	                i.y = toIntersect.y;
	                i.height = this.y - toIntersect.y + this.height;
	                if (i.height > toIntersect.height)
	                    i.height = toIntersect.height;
	            }
	            return i;
	        }
	        return new Rectangle();
	    };
	    /**
	     * Determines whether the object specified in the <code>toIntersect</code>
	     * parameter intersects with this Rectangle object. This method checks the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties of the specified Rectangle object to see if
	     * it intersects with this Rectangle object.
	     *
	     * @param toIntersect The Rectangle object to compare against this Rectangle
	     *                    object.
	     * @return A value of <code>true</code> if the specified object intersects
	     *         with this Rectangle object; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.intersects = function (toIntersect) {
	        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height);
	    };
	    /**
	     * Determines whether or not this Rectangle object is empty.
	     *
	     * @return A value of <code>true</code> if the Rectangle object's width or
	     *         height is less than or equal to 0; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.isEmpty = function () {
	        return (this.x == 0 && this.y == 0 && this.width == 0 && this.height == 0);
	    };
	    /**
	     * Adjusts the location of the Rectangle object, as determined by its
	     * top-left corner, by the specified amounts.
	     *
	     * @param dx Moves the <i>x</i> value of the Rectangle object by this amount.
	     * @param dy Moves the <i>y</i> value of the Rectangle object by this amount.
	     */
	    Rectangle.prototype.offset = function (dx, dy) {
	        this.x += dx;
	        this.y += dy;
	    };
	    /**
	     * Adjusts the location of the Rectangle object using a Point object as a
	     * parameter. This method is similar to the <code>Rectangle.offset()</code>
	     * method, except that it takes a Point object as a parameter.
	     *
	     * @param point A Point object to use to offset this Rectangle object.
	     */
	    Rectangle.prototype.offsetPoint = function (point) {
	        this.x += point.x;
	        this.y += point.y;
	    };
	    /**
	     * Sets all of the Rectangle object's properties to 0. A Rectangle object is
	     * empty if its width or height is less than or equal to 0.
	     *
	     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
	     * <code>width</code>, and <code>height</code> properties to 0.</p>
	     *
	     */
	    Rectangle.prototype.setEmpty = function () {
	        this.x = 0;
	        this.y = 0;
	        this.width = 0;
	        this.height = 0;
	    };
	    /**
	     * Sets the members of Rectangle to the specified values
	     *
	     * @param xa      The <i>x</i> coordinate of the top-left corner of the
	     *                rectangle.
	     * @param ya      The <i>y</i> coordinate of the top-left corner of the
	     *                rectangle.
	     * @param widtha  The width of the rectangle, in pixels.
	     * @param heighta The height of the rectangle, in pixels.
	     */
	    Rectangle.prototype.setTo = function (xa, ya, widtha, heighta) {
	        this.x = xa;
	        this.y = ya;
	        this.width = widtha;
	        this.height = heighta;
	    };
	    /**
	     * Builds and returns a string that lists the horizontal and vertical
	     * positions and the width and height of the Rectangle object.
	     *
	     * @return A string listing the value of each of the following properties of
	     *         the Rectangle object: <code>x</code>, <code>y</code>,
	     *         <code>width</code>, and <code>height</code>.
	     */
	    Rectangle.prototype.toString = function () {
	        return "[Rectangle] (x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
	    };
	    /**
	     * Adds two rectangles together to create a new Rectangle object, by filling
	     * in the horizontal and vertical space between the two rectangles.
	     *
	     * <p><b>Note:</b> The <code>union()</code> method ignores rectangles with
	     * <code>0</code> as the height or width value, such as: <code>var
	     * rect2:Rectangle = new Rectangle(300,300,50,0);</code></p>
	     *
	     * @param toUnion A Rectangle object to add to this Rectangle object.
	     * @return A new Rectangle object that is the union of the two rectangles.
	     */
	    Rectangle.prototype.union = function (toUnion) {
	        var u = new Rectangle();
	        if (this.x < toUnion.x) {
	            u.x = this.x;
	            u.width = toUnion.x - this.x + toUnion.width;
	            if (u.width < this.width)
	                u.width = this.width;
	        }
	        else {
	            u.x = toUnion.x;
	            u.width = this.x - toUnion.x + this.width;
	            if (u.width < toUnion.width)
	                u.width = toUnion.width;
	        }
	        if (this.y < toUnion.y) {
	            u.y = this.y;
	            u.height = toUnion.y - this.y + toUnion.height;
	            if (u.height < this.height)
	                u.height = this.height;
	        }
	        else {
	            u.y = toUnion.y;
	            u.height = this.y - toUnion.y + this.height;
	            if (u.height < toUnion.height)
	                u.height = toUnion.height;
	        }
	        return u;
	    };
	    return Rectangle;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Rectangle;


/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The Point object represents a location in a two-dimensional coordinate
	 * system, where <i>x</i> represents the horizontal axis and <i>y</i>
	 * represents the vertical axis.
	 *
	 * <p>The following code creates a point at(0,0):</p>
	 *
	 * <p>Methods and properties of the following classes use Point objects:</p>
	 *
	 * <ul>
	 *   <li>BitmapData</li>
	 *   <li>DisplayObject</li>
	 *   <li>DisplayObjectContainer</li>
	 *   <li>DisplacementMapFilter</li>
	 *   <li>NativeWindow</li>
	 *   <li>Matrix</li>
	 *   <li>Rectangle</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Point()</code> constructor to create a Point
	 * object.</p>
	 */
	var Point = (function () {
	    /**
	     * Creates a new point. If you pass no parameters to this method, a point is
	     * created at(0,0).
	     *
	     * @param x The horizontal coordinate.
	     * @param y The vertical coordinate.
	     */
	    function Point(x, y) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        this.x = x;
	        this.y = y;
	    }
	    Object.defineProperty(Point.prototype, "length", {
	        /**
	         * The length of the line segment from(0,0) to this point.
	         */
	        get: function () {
	            return Math.sqrt(this.x * this.x + this.y * this.y);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds the coordinates of another point to the coordinates of this point to
	     * create a new point.
	     *
	     * @param v The point to be added.
	     * @return The new point.
	     */
	    Point.prototype.add = function (v) {
	        return new Point(this.x + v.x, this.y + v.y);
	    };
	    /**
	     * Creates a copy of this Point object.
	     *
	     * @return The new Point object.
	     */
	    Point.prototype.clone = function () {
	        return new Point(this.x, this.y);
	    };
	    Point.prototype.copyFrom = function (sourcePoint) {
	    };
	    /**
	     * Determines whether two points are equal. Two points are equal if they have
	     * the same <i>x</i> and <i>y</i> values.
	     *
	     * @param toCompare The point to be compared.
	     * @return A value of <code>true</code> if the object is equal to this Point
	     *         object; <code>false</code> if it is not equal.
	     */
	    Point.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y);
	    };
	    /**
	     * Scales the line segment between(0,0) and the current point to a set
	     * length.
	     *
	     * @param thickness The scaling value. For example, if the current point is
	     *                 (0,5), and you normalize it to 1, the point returned is
	     *                  at(0,1).
	     */
	    Point.prototype.normalize = function (thickness) {
	        if (thickness === void 0) { thickness = 1; }
	        if (this.length != 0) {
	            var invLength = thickness / this.length;
	            this.x *= invLength;
	            this.y *= invLength;
	            return;
	        }
	        throw "Cannot divide by zero length.";
	    };
	    /**
	     * Offsets the Point object by the specified amount. The value of
	     * <code>dx</code> is added to the original value of <i>x</i> to create the
	     * new <i>x</i> value. The value of <code>dy</code> is added to the original
	     * value of <i>y</i> to create the new <i>y</i> value.
	     *
	     * @param dx The amount by which to offset the horizontal coordinate,
	     *           <i>x</i>.
	     * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
	     */
	    Point.prototype.offset = function (dx, dy) {
	        this.x += dx;
	        this.y += dy;
	    };
	    Point.prototype.setTo = function (xa, ya) {
	        this.x = xa;
	        this.y = ya;
	    };
	    /**
	     * Subtracts the coordinates of another point from the coordinates of this
	     * point to create a new point.
	     *
	     * @param v The point to be subtracted.
	     * @return The new point.
	     */
	    Point.prototype.subtract = function (v) {
	        return new Point(this.x - v.x, this.y - v.y);
	    };
	    /**
	     * Returns a string that contains the values of the <i>x</i> and <i>y</i>
	     * coordinates. The string has the form <code>"(x=<i>x</i>,
	     * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
	     * point at 23,17 would return <code>"(x=23, y=17)"</code>.
	     *
	     * @return The string representation of the coordinates.
	     */
	    Point.prototype.toString = function () {
	        return "[Point] (x=" + this.x + ", y=" + this.y + ")";
	    };
	    /**
	     * Returns the distance between <code>pt1</code> and <code>pt2</code>.
	     *
	     * @param pt1 The first point.
	     * @param pt2 The second point.
	     * @return The distance between the first and second points.
	     */
	    Point.distance = function (pt1, pt2) {
	        var dx = pt2.x - pt1.x;
	        var dy = pt2.y - pt1.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**
	     * Determines a point between two specified points. The parameter
	     * <code>f</code> determines where the new interpolated point is located
	     * relative to the two end points specified by parameters <code>pt1</code>
	     * and <code>pt2</code>. The closer the value of the parameter <code>f</code>
	     * is to <code>1.0</code>, the closer the interpolated point is to the first
	     * point(parameter <code>pt1</code>). The closer the value of the parameter
	     * <code>f</code> is to 0, the closer the interpolated point is to the second
	     * point(parameter <code>pt2</code>).
	     *
	     * @param pt1 The first point.
	     * @param pt2 The second point.
	     * @param f   The level of interpolation between the two points. Indicates
	     *            where the new point will be, along the line between
	     *            <code>pt1</code> and <code>pt2</code>. If <code>f</code>=1,
	     *            <code>pt1</code> is returned; if <code>f</code>=0,
	     *            <code>pt2</code> is returned.
	     * @return The new, interpolated point.
	     */
	    Point.interpolate = function (pt1, pt2, f) {
	        return new Point(pt2.x + (pt1.x - pt2.x) * f, pt2.y + (pt1.y - pt2.y) * f);
	    };
	    /**
	     * Converts a pair of polar coordinates to a Cartesian point coordinate.
	     *
	     * @param len   The length coordinate of the polar pair.
	     * @param angle The angle, in radians, of the polar pair.
	     * @return The Cartesian point.
	     */
	    Point.polar = function (len, angle) {
	        return new Point(len * Math.cos(angle), len * Math.sin(angle));
	    };
	    return Point;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Point;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var ProjectionEvent = (function (_super) {
	    __extends(ProjectionEvent, _super);
	    function ProjectionEvent(type, projection) {
	        _super.call(this, type);
	        this._projection = projection;
	    }
	    Object.defineProperty(ProjectionEvent.prototype, "projection", {
	        get: function () {
	            return this._projection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionEvent.MATRIX_CHANGED = "matrixChanged";
	    return ProjectionEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ProjectionEvent;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var getTimer_1 = __webpack_require__(39);
	var RequestAnimationFrame = (function () {
	    function RequestAnimationFrame(callback, callbackContext) {
	        var _this = this;
	        this._active = false;
	        this._argsArray = new Array();
	        this._getTimer = getTimer_1.default;
	        this.setCallback(callback, callbackContext);
	        this._rafUpdateFunction = function () {
	            if (_this._active)
	                _this._tick();
	        };
	        this._argsArray.push(this._dt);
	    }
	    // Public
	    /**
	     *
	     * @param callback
	     * @param callbackContext
	     */
	    RequestAnimationFrame.prototype.setCallback = function (callback, callbackContext) {
	        this._callback = callback;
	        this._callbackContext = callbackContext;
	    };
	    /**
	     *
	     */
	    RequestAnimationFrame.prototype.start = function () {
	        this._prevTime = this._getTimer();
	        this._active = true;
	        if (window) {
	            if (window.requestAnimationFrame) {
	                window.requestAnimationFrame(this._rafUpdateFunction);
	            }
	            else {
	                if (window['mozRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['mozRequestAnimationFrame'];
	                else if (window['webkitRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
	                else if (window['oRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['oRequestAnimationFrame'];
	            }
	        }
	    };
	    /**
	     *
	     */
	    RequestAnimationFrame.prototype.stop = function () {
	        this._active = false;
	    };
	    Object.defineProperty(RequestAnimationFrame.prototype, "active", {
	        // Get / Set
	        /**
	         *
	         * @returns {boolean}
	         */
	        get: function () {
	            return this._active;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Private
	    /**
	     *
	     * @private
	     */
	    RequestAnimationFrame.prototype._tick = function () {
	        this._currentTime = this._getTimer();
	        this._dt = this._currentTime - this._prevTime;
	        this._argsArray[0] = this._dt;
	        this._callback.apply(this._callbackContext, this._argsArray);
	        window.requestAnimationFrame(this._rafUpdateFunction);
	        this._prevTime = this._currentTime;
	    };
	    return RequestAnimationFrame;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RequestAnimationFrame;


/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 *
	 * @returns {number}
	 */
	function getTimer() {
	    // number milliseconds of 1970/01/01
	    // this different to AS3 implementation which gets the number of milliseconds
	    // since instance of Flash player was initialised
	    return Date.now();
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = getTimer;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var getTimer_1 = __webpack_require__(39);
	var TouchPoint_1 = __webpack_require__(41);
	var Scene_1 = __webpack_require__(42);
	var RaycastPicker_1 = __webpack_require__(63);
	var Camera_1 = __webpack_require__(64);
	var CameraEvent_1 = __webpack_require__(68);
	var DisplayObjectEvent_1 = __webpack_require__(56);
	var RendererEvent_1 = __webpack_require__(69);
	var MouseManager_1 = __webpack_require__(70);
	var View = (function () {
	    /*
	     ***********************************************************************
	     * Disabled / Not yet implemented
	     ***********************************************************************
	     *
	     * private _background:away.textures.Texture2DBase;
	     *
	     * public _pTouch3DManager:away.managers.Touch3DManager;
	     *
	     */
	    function View(renderer, scene, camera) {
	        var _this = this;
	        if (scene === void 0) { scene = null; }
	        if (camera === void 0) { camera = null; }
	        this._width = 0;
	        this._height = 0;
	        this._time = 0;
	        this._deltaTime = 0;
	        this._backgroundColor = 0x000000;
	        this._backgroundAlpha = 1;
	        this._viewportDirty = true;
	        this._scissorDirty = true;
	        this._mousePicker = new RaycastPicker_1.default();
	        this._pTouchPoints = new Array();
	        this._onPartitionChangedDelegate = function (event) { return _this._onPartitionChanged(event); };
	        this._onProjectionChangedDelegate = function (event) { return _this._onProjectionChanged(event); };
	        this._onViewportUpdatedDelegate = function (event) { return _this._onViewportUpdated(event); };
	        this._onScissorUpdatedDelegate = function (event) { return _this._onScissorUpdated(event); };
	        this.scene = scene || new Scene_1.default();
	        this.camera = camera || new Camera_1.default();
	        this.renderer = renderer;
	        //make sure document border is zero
	        if (document) {
	            document.body.style.margin = "0px";
	            this._htmlElement = document.createElement("div");
	            this._htmlElement.style.position = "absolute";
	            document.body.appendChild(this._htmlElement);
	        }
	        this._mouseManager = MouseManager_1.default.getInstance();
	        this._mouseManager.registerView(this);
	        //			if (this._shareContext)
	        //				this._mouse3DManager.addViewLayer(this);
	    }
	    Object.defineProperty(View.prototype, "mouseX", {
	        get: function () {
	            return this._pMouseX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "mouseY", {
	        get: function () {
	            return this._pMouseY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "touchPoints", {
	        get: function () {
	            return this._pTouchPoints;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    View.prototype.getLocalMouseX = function (displayObject) {
	        return displayObject.inverseSceneTransform.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).x;
	    };
	    View.prototype.getLocalMouseY = function (displayObject) {
	        return displayObject.inverseSceneTransform.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).y;
	    };
	    View.prototype.getLocalTouchPoints = function (displayObject) {
	        var localPosition;
	        var localTouchPoints = new Array();
	        var len = this._pTouchPoints.length;
	        for (var i = 0; i < len; i++) {
	            localPosition = displayObject.inverseSceneTransform.transformVector(this.unproject(this._pTouchPoints[i].x, this._pTouchPoints[i].y, 1000));
	            localTouchPoints.push(new TouchPoint_1.default(localPosition.x, localPosition.y, this._pTouchPoints[i].id));
	        }
	        return localTouchPoints;
	    };
	    Object.defineProperty(View.prototype, "htmlElement", {
	        /**
	         *
	         */
	        get: function () {
	            return this._htmlElement;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "renderer", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer;
	        },
	        set: function (value) {
	            if (this._pRenderer == value)
	                return;
	            if (this._pRenderer) {
	                this._pRenderer.dispose();
	                this._pRenderer.removeEventListener(RendererEvent_1.default.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	                this._pRenderer.removeEventListener(RendererEvent_1.default.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
	            }
	            this._pRenderer = value;
	            this._pRenderer.addEventListener(RendererEvent_1.default.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	            this._pRenderer.addEventListener(RendererEvent_1.default.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
	            //reset back buffer
	            this._pRenderer._iBackgroundR = ((this._backgroundColor >> 16) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundG = ((this._backgroundColor >> 8) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundB = (this._backgroundColor & 0xff) / 0xff;
	            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha;
	            this._pRenderer.width = this._width;
	            this._pRenderer.height = this._height;
	            this._pRenderer.shareContext = this._shareContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "shareContext", {
	        /**
	         *
	         */
	        get: function () {
	            return this._shareContext;
	        },
	        set: function (value) {
	            if (this._shareContext == value)
	                return;
	            this._shareContext = value;
	            if (this._pRenderer)
	                this._pRenderer.shareContext = this._shareContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "backgroundColor", {
	        /**
	         *
	         */
	        get: function () {
	            return this._backgroundColor;
	        },
	        set: function (value) {
	            if (this._backgroundColor == value)
	                return;
	            this._backgroundColor = value;
	            this._pRenderer._iBackgroundR = ((value >> 16) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundG = ((value >> 8) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "backgroundAlpha", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._backgroundAlpha;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            if (value > 1)
	                value = 1;
	            else if (value < 0)
	                value = 0;
	            if (this._backgroundAlpha == value)
	                return;
	            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "camera", {
	        /**
	         *
	         * @returns {Camera3D}
	         */
	        get: function () {
	            return this._pCamera;
	        },
	        /**
	         * Set camera that's used to render the scene for this viewport
	         */
	        set: function (value) {
	            if (this._pCamera == value)
	                return;
	            if (this._pCamera)
	                this._pCamera.removeEventListener(CameraEvent_1.default.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
	            this._pCamera = value;
	            if (this._pScene)
	                this._pScene.partition._iRegisterEntity(this._pCamera);
	            this._pCamera.addEventListener(CameraEvent_1.default.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
	            this._scissorDirty = true;
	            this._viewportDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "scene", {
	        /**
	         *
	         * @returns {away.containers.Scene3D}
	         */
	        get: function () {
	            return this._pScene;
	        },
	        /**
	         * Set the scene that's used to render for this viewport
	         */
	        set: function (value) {
	            if (this._pScene == value)
	                return;
	            if (this._pScene)
	                this._pScene.removeEventListener(DisplayObjectEvent_1.default.PARTITION_CHANGED, this._onPartitionChangedDelegate);
	            this._pScene = value;
	            this._pScene.addEventListener(DisplayObjectEvent_1.default.PARTITION_CHANGED, this._onPartitionChangedDelegate);
	            if (this._pCamera)
	                this._pScene.partition._iRegisterEntity(this._pCamera);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "deltaTime", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._deltaTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "width", {
	        /**
	         *
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            if (this._width == value)
	                return;
	            this._width = value;
	            this._aspectRatio = this._width / this._height;
	            this._pCamera.projection._iAspectRatio = this._aspectRatio;
	            this._pRenderer.width = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.width = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "height", {
	        /**
	         *
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            if (this._height == value)
	                return;
	            this._height = value;
	            this._aspectRatio = this._width / this._height;
	            this._pCamera.projection._iAspectRatio = this._aspectRatio;
	            this._pRenderer.height = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.height = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "mousePicker", {
	        /**
	         *
	         */
	        get: function () {
	            return this._mousePicker;
	        },
	        set: function (value) {
	            if (this._mousePicker == value)
	                return;
	            if (value == null)
	                this._mousePicker = new RaycastPicker_1.default();
	            else
	                this._mousePicker = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "x", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer.x;
	        },
	        set: function (value) {
	            if (this._pRenderer.x == value)
	                return;
	            this._pRenderer.x == value;
	            if (this._htmlElement) {
	                this._htmlElement.style.left = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "y", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer.y;
	        },
	        set: function (value) {
	            if (this._pRenderer.y == value)
	                return;
	            this._pRenderer.y == value;
	            if (this._htmlElement) {
	                this._htmlElement.style.top = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "visible", {
	        /**
	         *
	         */
	        get: function () {
	            return (this._htmlElement && this._htmlElement.style.visibility == "visible");
	        },
	        set: function (value) {
	            if (this._htmlElement) {
	                this._htmlElement.style.visibility = value ? "visible" : "hidden";
	            }
	            //TODO transfer visible property to associated context (if one exists)
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "renderedFacesCount", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return 0; //TODO
	            //return this._pEntityCollector._pNumTriangles;//numTriangles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Renders the view.
	     */
	    View.prototype.render = function () {
	        this.pUpdateTime();
	        //update view and size data
	        this._pCamera.projection._iAspectRatio = this._aspectRatio;
	        if (this._scissorDirty) {
	            this._scissorDirty = false;
	            this._pCamera.projection._iUpdateScissorRect(this._pRenderer.scissorRect.x, this._pRenderer.scissorRect.y, this._pRenderer.scissorRect.width, this._pRenderer.scissorRect.height);
	        }
	        if (this._viewportDirty) {
	            this._viewportDirty = false;
	            this._pCamera.projection._iUpdateViewport(this._pRenderer.viewPort.x, this._pRenderer.viewPort.y, this._pRenderer.viewPort.width, this._pRenderer.viewPort.height);
	        }
	        // update picking
	        if (!this._shareContext) {
	            if (this.forceMouseMove && this._htmlElement == this._mouseManager._iActiveDiv && !this._mouseManager._iUpdateDirty)
	                this._mouseManager._iCollision = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
	            this._mouseManager.fireMouseEvents(this.forceMouseMove);
	        }
	        //_touch3DManager.updateCollider();
	        //render the contents of the scene
	        this._pRenderer.render(this._pCamera, this._pScene);
	    };
	    /**
	     *
	     */
	    View.prototype.pUpdateTime = function () {
	        var time = getTimer_1.default();
	        if (this._time == 0)
	            this._time = time;
	        this._deltaTime = time - this._time;
	        this._time = time;
	    };
	    /**
	     *
	     */
	    View.prototype.dispose = function () {
	        this._pRenderer.dispose();
	        // TODO: imeplement mouseManager / touch3DManager
	        this._mouseManager.unregisterView(this);
	        //this._touch3DManager.disableTouchListeners(this);
	        //this._touch3DManager.dispose();
	        this._mouseManager = null;
	        //this._touch3DManager = null;
	        this._pRenderer = null;
	    };
	    /**
	     *
	     * @param e
	     */
	    View.prototype._onPartitionChanged = function (event) {
	        if (this._pCamera)
	            this._pScene.partition._iRegisterEntity(this._pCamera);
	    };
	    /**
	     *
	     */
	    View.prototype._onProjectionChanged = function (event) {
	        this._scissorDirty = true;
	        this._viewportDirty = true;
	    };
	    /**
	     *
	     */
	    View.prototype._onViewportUpdated = function (event) {
	        this._viewportDirty = true;
	    };
	    /**
	     *
	     */
	    View.prototype._onScissorUpdated = function (event) {
	        this._scissorDirty = true;
	    };
	    View.prototype.project = function (point3d) {
	        var v = this._pCamera.project(point3d);
	        v.x = v.x * this._pRenderer.viewPort.width / 2 + this._width * this._pCamera.projection.originX;
	        v.y = v.y * this._pRenderer.viewPort.height / 2 + this._height * this._pCamera.projection.originY;
	        return v;
	    };
	    View.prototype.unproject = function (sX, sY, sZ) {
	        return this._pCamera.unproject(2 * (sX - this._width * this._pCamera.projection.originX) / this._pRenderer.viewPort.width, 2 * (sY - this._height * this._pCamera.projection.originY) / this._pRenderer.viewPort.height, sZ);
	    };
	    View.prototype.getRay = function (sX, sY, sZ) {
	        return this._pCamera.getRay((sX * 2 - this._width) / this._width, (sY * 2 - this._height) / this._height, sZ);
	    };
	    /*TODO: implement Background
	     public get background():away.textures.Texture2DBase
	     {
	     return this._background;
	     }
	     */
	    /*TODO: implement Background
	     public set background( value:away.textures.Texture2DBase )
	     {
	     this._background = value;
	     this._renderer.background = _background;
	     }
	     */
	    // TODO: required dependency stageGL
	    View.prototype.updateCollider = function () {
	        if (!this._shareContext) {
	            if (this._htmlElement == this._mouseManager._iActiveDiv)
	                this._mouseManager._iCollision = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
	        }
	        else {
	            var collidingObject = this.mousePicker.getViewCollision(this._pMouseX, this._pMouseY, this);
	            if (this.layeredView || this._mouseManager._iCollision == null || collidingObject.rayEntryDistance < this._mouseManager._iCollision.rayEntryDistance)
	                this._mouseManager._iCollision = collidingObject;
	        }
	    };
	    return View;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = View;


/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var TouchPoint = (function () {
	    function TouchPoint(x, y, id) {
	        this.x = x;
	        this.y = y;
	        this.id = id;
	    }
	    return TouchPoint;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TouchPoint;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DisplayObjectContainer_1 = __webpack_require__(43);
	var BasicPartition_1 = __webpack_require__(57);
	var Scene = (function (_super) {
	    __extends(Scene, _super);
	    function Scene(partition) {
	        if (partition === void 0) { partition = null; }
	        _super.call(this);
	        this._expandedPartitions = new Array();
	        this._partitions = new Array();
	        this._iCollectionMark = 0;
	        this.partition = partition || new BasicPartition_1.default();
	        this._iIsRoot = true;
	        this._pScene = this;
	    }
	    Scene.prototype.traversePartitions = function (traverser) {
	        var i = 0;
	        var len = this._partitions.length;
	        while (i < len)
	            this._partitions[i++].traverse(traverser);
	    };
	    /**
	     * @internal
	     */
	    Scene.prototype._iRegisterPartition = function (partition) {
	        this._expandedPartitions.push(partition);
	        //ensure duplicates are not found in partitions array
	        if (this._partitions.indexOf(partition) == -1)
	            this._partitions.push(partition);
	    };
	    /**
	     * @internal
	     */
	    Scene.prototype._iUnregisterPartition = function (partition) {
	        this._expandedPartitions.splice(this._expandedPartitions.indexOf(partition), 1);
	        //if no more partition references found, remove from partitions array
	        if (this._expandedPartitions.indexOf(partition) == -1)
	            this._partitions.splice(this._partitions.indexOf(partition), 1);
	    };
	    return Scene;
	}(DisplayObjectContainer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Scene;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArgumentError_1 = __webpack_require__(33);
	var RangeError_1 = __webpack_require__(44);
	var DisplayObject_1 = __webpack_require__(45);
	var HierarchicalProperties_1 = __webpack_require__(49);
	/**
	 * The DisplayObjectContainer class is the base class for all objects that can
	 * serve as display object containers on the display list. The display list
	 * manages all objects displayed in the Flash runtimes. Use the
	 * DisplayObjectContainer class to arrange the display objects in the display
	 * list. Each DisplayObjectContainer object has its own child list for
	 * organizing the z-order of the objects. The z-order is the front-to-back
	 * order that determines which object is drawn in front, which is behind, and
	 * so on.
	 *
	 * <p>DisplayObject is an abstract base class; therefore, you cannot call
	 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
	 * <code>ArgumentError</code> exception.</p>
	 * The DisplayObjectContainer class is an abstract base class for all objects
	 * that can contain child objects. It cannot be instantiated directly; calling
	 * the <code>new DisplayObjectContainer()</code> constructor throws an
	 * <code>ArgumentError</code> exception.
	 *
	 * <p>For more information, see the "Display Programming" chapter of the
	 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
	 */
	var DisplayObjectContainer = (function (_super) {
	    __extends(DisplayObjectContainer, _super);
	    /**
	     * Calling the <code>new DisplayObjectContainer()</code> constructor throws
	     * an <code>ArgumentError</code> exception. You <i>can</i>, however, call
	     * constructors for the following subclasses of DisplayObjectContainer:
	     * <ul>
	     *   <li><code>new Loader()</code></li>
	     *   <li><code>new Sprite()</code></li>
	     *   <li><code>new MovieClip()</code></li>
	     * </ul>
	     */
	    function DisplayObjectContainer() {
	        _super.call(this);
	        this._mouseChildren = true;
	        this._depth_childs = {};
	        this._nextHighestDepth = 0;
	        this._children = new Array();
	    }
	    Object.defineProperty(DisplayObjectContainer.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return DisplayObjectContainer.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
	        /**
	         * Determines whether or not the children of the object are mouse, or user
	         * input device, enabled. If an object is enabled, a user can interact with
	         * it by using a mouse or user input device. The default is
	         * <code>true</code>.
	         *
	         * <p>This property is useful when you create a button with an instance of
	         * the Sprite class(instead of using the SimpleButton class). When you use a
	         * Sprite instance to create a button, you can choose to decorate the button
	         * by using the <code>addChild()</code> method to add additional Sprite
	         * instances. This process can cause unexpected behavior with mouse events
	         * because the Sprite instances you add as children can become the target
	         * object of a mouse event when you expect the parent instance to be the
	         * target object. To ensure that the parent instance serves as the target
	         * objects for mouse events, you can set the <code>mouseChildren</code>
	         * property of the parent instance to <code>false</code>.</p>
	         *
	         * <p> No event is dispatched by setting this property. You must use the
	         * <code>addEventListener()</code> method to create interactive
	         * functionality.</p>
	         */
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.MOUSE_ENABLED)
	                this._updateMouseEnabled();
	            return this._mouseChildren;
	        },
	        set: function (value) {
	            if (this._mouseChildren == value)
	                return;
	            this._mouseChildren = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.MOUSE_ENABLED);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
	        /**
	         * Returns the number of children of this object.
	         */
	        get: function () {
	            return this._children.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a child DisplayObject instance to this DisplayObjectContainer
	     * instance. The child is added to the front(top) of all other children in
	     * this DisplayObjectContainer instance.(To add a child to a specific index
	     * position, use the <code>addChildAt()</code> method.)
	     *
	     * <p>If you add a child object that already has a different display object
	     * container as a parent, the object is removed from the child list of the
	     * other display object container. </p>
	     *
	     * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
	     * problems with a published SWF file, including security problems and
	     * conflicts with other loaded SWF files. There is only one Stage within a
	     * Flash runtime instance, no matter how many SWF files you load into the
	     * runtime. So, generally, objects should not be added to the Stage,
	     * directly, at all. The only object the Stage should contain is the root
	     * object. Create a DisplayObjectContainer to contain all of the items on the
	     * display list. Then, if necessary, add that DisplayObjectContainer instance
	     * to the Stage.</p>
	     *
	     * @param child The DisplayObject instance to add as a child of this
	     *              DisplayObjectContainer instance.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child is the same as the parent. Also
	     *                       throws if the caller is a child(or grandchild etc.)
	     *                       of the child being added.
	     * @event added Dispatched when a display object is added to the display
	     *              list.
	     */
	    DisplayObjectContainer.prototype.addChild = function (child) {
	        return this.addChildAt(child, this._children.length);
	    };
	    DisplayObjectContainer.prototype.addChildAtDepth = function (child, depth, replace) {
	        if (replace === void 0) { replace = true; }
	        if (child == null)
	            throw new ArgumentError_1.default("Parameter child cannot be null.");
	        //if child already has a parent, remove it.
	        if (child._pParent)
	            child._pParent.removeChildAtInternal(child._pParent.getChildIndex(child));
	        var index = this.getDepthIndexInternal(depth);
	        if (index != -1) {
	            if (replace) {
	                this.removeChildAt(index);
	            }
	            else {
	                //move depth of existing child up by 1
	                this.addChildAtDepth(this._children[index], depth + 1, false);
	            }
	        }
	        if (this._nextHighestDepth < depth + 1)
	            this._nextHighestDepth = depth + 1;
	        this._depth_childs[depth] = child;
	        this._children.push(child);
	        child._depthID = depth;
	        child.iSetParent(this);
	        this._invalidateChildren();
	        return child;
	    };
	    /**
	     * Adds a child DisplayObject instance to this DisplayObjectContainer
	     * instance. The child is added at the index position specified. An index of
	     * 0 represents the back(bottom) of the display list for this
	     * DisplayObjectContainer object.
	     *
	     * <p>For example, the following example shows three display objects, labeled
	     * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
	     *
	     * <p>If you add a child object that already has a different display object
	     * container as a parent, the object is removed from the child list of the
	     * other display object container. </p>
	     *
	     * @param child The DisplayObject instance to add as a child of this
	     *              DisplayObjectContainer instance.
	     * @param index The index position to which the child is added. If you
	     *              specify a currently occupied index position, the child object
	     *              that exists at that position and all higher positions are
	     *              moved up one position in the child list.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child is the same as the parent. Also
	     *                       throws if the caller is a child(or grandchild etc.)
	     *                       of the child being added.
	     * @throws RangeError    Throws if the index position does not exist in the
	     *                       child list.
	     * @event added Dispatched when a display object is added to the display
	     *              list.
	     */
	    DisplayObjectContainer.prototype.addChildAt = function (child, index) {
	        return this.addChildAtDepth(child, (index < this._children.length) ? this._children[index]._depthID : this.getNextHighestDepth(), false);
	    };
	    DisplayObjectContainer.prototype.addChildren = function () {
	        var childarray = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            childarray[_i - 0] = arguments[_i];
	        }
	        var len = childarray.length;
	        for (var i = 0; i < len; i++)
	            this.addChild(childarray[i]);
	    };
	    /**
	     *
	     */
	    DisplayObjectContainer.prototype.clone = function () {
	        var newInstance = new DisplayObjectContainer();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    DisplayObjectContainer.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.mouseChildren = this._mouseChildren;
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            newInstance.addChild(this._children[i].clone());
	    };
	    /**
	     * Determines whether the specified display object is a child of the
	     * DisplayObjectContainer instance or the instance itself. The search
	     * includes the entire display list including this DisplayObjectContainer
	     * instance. Grandchildren, great-grandchildren, and so on each return
	     * <code>true</code>.
	     *
	     * @param child The child object to test.
	     * @return <code>true</code> if the <code>child</code> object is a child of
	     *         the DisplayObjectContainer or the container itself; otherwise
	     *         <code>false</code>.
	     */
	    DisplayObjectContainer.prototype.contains = function (child) {
	        return this._children.indexOf(child) >= 0;
	    };
	    /**
	     *
	     */
	    DisplayObjectContainer.prototype.disposeValues = function () {
	        for (var i = this._children.length - 1; i >= 0; i--)
	            this.removeChild(this._children[i]);
	        _super.prototype.disposeValues.call(this);
	    };
	    DisplayObjectContainer.prototype.getChildAtDepth = function (depth) {
	        return this._depth_childs[depth];
	    };
	    /**
	     * Returns the child display object instance that exists at the specified
	     * index.
	     *
	     * @param index The index position of the child object.
	     * @return The child display object at the specified index position.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     */
	    DisplayObjectContainer.prototype.getChildAt = function (index /*int*/) {
	        var child = this._children[index];
	        if (child == null)
	            throw new RangeError_1.default("Index does not exist in the child list of the caller");
	        return child;
	    };
	    /**
	     * Returns the child display object that exists with the specified name. If
	     * more that one child display object has the specified name, the method
	     * returns the first object in the child list.
	     *
	     * <p>The <code>getChildAt()</code> method is faster than the
	     * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
	     * accesses a child from a cached array, whereas the
	     * <code>getChildByName()</code> method has to traverse a linked list to
	     * access a child.</p>
	     *
	     * @param name The name of the child to return.
	     * @return The child display object with the specified name.
	     */
	    DisplayObjectContainer.prototype.getChildByName = function (name) {
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            if (this._children[i].name == name)
	                return this._children[i];
	        return null;
	    };
	    /**
	     * Returns the index position of a <code>child</code> DisplayObject instance.
	     *
	     * @param child The DisplayObject instance to identify.
	     * @return The index position of the child display object to identify.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     */
	    DisplayObjectContainer.prototype.getChildIndex = function (child) {
	        var childIndex = this._children.indexOf(child);
	        if (childIndex == -1)
	            throw new ArgumentError_1.default("Child parameter is not a child of the caller");
	        return childIndex;
	    };
	    DisplayObjectContainer.prototype.getNextHighestDepth = function () {
	        if (this._nextHighestDepthDirty)
	            this._updateNextHighestDepth();
	        return this._nextHighestDepth;
	    };
	    /**
	     * Returns an array of objects that lie under the specified point and are
	     * children(or grandchildren, and so on) of this DisplayObjectContainer
	     * instance. Any child objects that are inaccessible for security reasons are
	     * omitted from the returned array. To determine whether this security
	     * restriction affects the returned array, call the
	     * <code>areInaccessibleObjectsUnderPoint()</code> method.
	     *
	     * <p>The <code>point</code> parameter is in the coordinate space of the
	     * Stage, which may differ from the coordinate space of the display object
	     * container(unless the display object container is the Stage). You can use
	     * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	     * methods to convert points between these coordinate spaces.</p>
	     *
	     * @param point The point under which to look.
	     * @return An array of objects that lie under the specified point and are
	     *         children(or grandchildren, and so on) of this
	     *         DisplayObjectContainer instance.
	     */
	    DisplayObjectContainer.prototype.getObjectsUnderPoint = function (point) {
	        return new Array();
	    };
	    /**
	     * Removes the specified <code>child</code> DisplayObject instance from the
	     * child list of the DisplayObjectContainer instance. The <code>parent</code>
	     * property of the removed child is set to <code>null</code> , and the object
	     * is garbage collected if no other references to the child exist. The index
	     * positions of any display objects above the child in the
	     * DisplayObjectContainer are decreased by 1.
	     *
	     * <p>The garbage collector reallocates unused memory space. When a variable
	     * or object is no longer actively referenced or stored somewhere, the
	     * garbage collector sweeps through and wipes out the memory space it used to
	     * occupy if no other references to it exist.</p>
	     *
	     * @param child The DisplayObject instance to remove.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     */
	    DisplayObjectContainer.prototype.removeChild = function (child) {
	        if (child == null)
	            throw new ArgumentError_1.default("Parameter child cannot be null");
	        this.removeChildAt(this.getChildIndex(child));
	        return child;
	    };
	    DisplayObjectContainer.prototype.removeChildAtDepth = function (depth /*int*/) {
	        return this.removeChildAt(this.getDepthIndexInternal(depth));
	    };
	    /**
	     * Removes a child DisplayObject from the specified <code>index</code>
	     * position in the child list of the DisplayObjectContainer. The
	     * <code>parent</code> property of the removed child is set to
	     * <code>null</code>, and the object is garbage collected if no other
	     * references to the child exist. The index positions of any display objects
	     * above the child in the DisplayObjectContainer are decreased by 1.
	     *
	     * <p>The garbage collector reallocates unused memory space. When a variable
	     * or object is no longer actively referenced or stored somewhere, the
	     * garbage collector sweeps through and wipes out the memory space it used to
	     * occupy if no other references to it exist.</p>
	     *
	     * @param index The child index of the DisplayObject to remove.
	     * @return The DisplayObject instance that was removed.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     * @throws SecurityError This child display object belongs to a sandbox to
	     *                       which the calling object does not have access. You
	     *                       can avoid this situation by having the child movie
	     *                       call the <code>Security.allowDomain()</code> method.
	     */
	    DisplayObjectContainer.prototype.removeChildAt = function (index /*int*/) {
	        var child = this.removeChildAtInternal(index);
	        child.iSetParent(null);
	        this._invalidateChildren();
	        return child;
	    };
	    /**
	     * Removes all <code>child</code> DisplayObject instances from the child list
	     * of the DisplayObjectContainer instance. The <code>parent</code> property
	     * of the removed children is set to <code>null</code>, and the objects are
	     * garbage collected if no other references to the children exist.
	     *
	     * The garbage collector reallocates unused memory space. When a variable or
	     * object is no longer actively referenced or stored somewhere, the garbage
	     * collector sweeps through and wipes out the memory space it used to occupy
	     * if no other references to it exist.
	     *
	     * @param beginIndex The beginning position. A value smaller than 0 throws a RangeError.
	     * @param endIndex The ending position. A value smaller than 0 throws a RangeError.
	     * @throws RangeError    Throws if the beginIndex or endIndex positions do
	     *                       not exist in the child list.
	     */
	    DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = 0; }
	        if (endIndex === void 0) { endIndex = 2147483647; }
	        if (beginIndex < 0)
	            throw new RangeError_1.default("beginIndex is out of range of the child list");
	        if (endIndex > this._children.length)
	            throw new RangeError_1.default("endIndex is out of range of the child list");
	        for (var i = beginIndex; i < endIndex; i++)
	            this.removeChild(this._children[i]);
	    };
	    /**
	     * Changes the position of an existing child in the display object container.
	     * This affects the layering of child objects. For example, the following
	     * example shows three display objects, labeled a, b, and c, at index
	     * positions 0, 1, and 2, respectively:
	     *
	     * <p>When you use the <code>setChildIndex()</code> method and specify an
	     * index position that is already occupied, the only positions that change
	     * are those in between the display object's former and new position. All
	     * others will stay the same. If a child is moved to an index LOWER than its
	     * current index, all children in between will INCREASE by 1 for their index
	     * reference. If a child is moved to an index HIGHER than its current index,
	     * all children in between will DECREASE by 1 for their index reference. For
	     * example, if the display object container in the previous example is named
	     * <code>container</code>, you can swap the position of the display objects
	     * labeled a and b by calling the following code:</p>
	     *
	     * <p>This code results in the following arrangement of objects:</p>
	     *
	     * @param child The child DisplayObject instance for which you want to change
	     *              the index number.
	     * @param index The resulting index number for the <code>child</code> display
	     *              object.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     */
	    DisplayObjectContainer.prototype.setChildIndex = function (child, index /*int*/) {
	        //TODO
	    };
	    /**
	     * Swaps the z-order (front-to-back order) of the two specified child
	     * objects. All other child objects in the display object container remain in
	     * the same index positions.
	     *
	     * @param child1 The first child object.
	     * @param child2 The second child object.
	     * @throws ArgumentError Throws if either child parameter is not a child of
	     *                       this object.
	     */
	    DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
	        this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
	    };
	    /**
	     * Swaps the z-order(front-to-back order) of the child objects at the two
	     * specified index positions in the child list. All other child objects in
	     * the display object container remain in the same index positions.
	     *
	     * @param index1 The index position of the first child object.
	     * @param index2 The index position of the second child object.
	     * @throws RangeError If either index does not exist in the child list.
	     */
	    DisplayObjectContainer.prototype.swapChildrenAt = function (index1, index2) {
	        var depth = this._children[index2]._depthID;
	        var child = this._children[index1];
	        this.addChildAtDepth(this._children[index2], this._children[index1]._depthID);
	        this.addChildAtDepth(child, depth);
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    DisplayObjectContainer.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        var box;
	        var numChildren = this._children.length;
	        if (numChildren > 0) {
	            var min;
	            var max;
	            var minX, minY, minZ;
	            var maxX, maxY, maxZ;
	            for (var i = 0; i < numChildren; ++i) {
	                box = this._children[i].getBox(this);
	                if (i == 0) {
	                    maxX = box.width + (minX = box.x);
	                    maxY = box.height + (minY = box.y);
	                    maxZ = box.depth + (minZ = box.z);
	                }
	                else {
	                    max = box.width + (min = box.x);
	                    if (min < minX)
	                        minX = min;
	                    if (max > maxX)
	                        maxX = max;
	                    max = box.height + (min = box.y);
	                    if (min < minY)
	                        minY = min;
	                    if (max > maxY)
	                        maxY = max;
	                    max = box.depth + (min = box.z);
	                    if (min < minZ)
	                        minZ = min;
	                    if (max > maxZ)
	                        maxZ = max;
	                }
	            }
	            this._pBoxBounds.width = maxX - (this._pBoxBounds.x = minX);
	            this._pBoxBounds.height = maxY - (this._pBoxBounds.y = minY);
	            this._pBoxBounds.depth = maxZ - (this._pBoxBounds.z = minZ);
	        }
	        else {
	            this._pBoxBounds.setEmpty();
	        }
	    };
	    /**
	     * @protected
	     */
	    DisplayObjectContainer.prototype.pInvalidateHierarchicalProperties = function (bitFlag) {
	        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, bitFlag))
	            return true;
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            this._children[i].pInvalidateHierarchicalProperties(bitFlag);
	        return false;
	    };
	    /**
	     * @internal
	     */
	    DisplayObjectContainer.prototype._iSetScene = function (value, partition) {
	        _super.prototype._iSetScene.call(this, value, partition);
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            this._children[i]._iSetScene(value, partition);
	    };
	    /**
	     * @private
	     *
	     * @param child
	     */
	    DisplayObjectContainer.prototype.removeChildAtInternal = function (index) {
	        var child = this._children.splice(index, 1)[0];
	        //update next highest depth
	        if (this._nextHighestDepth == child._depthID + 1)
	            this._nextHighestDepthDirty = true;
	        delete this._depth_childs[child._depthID];
	        child._depthID = -16384;
	        return child;
	    };
	    DisplayObjectContainer.prototype.getDepthIndexInternal = function (depth /*int*/) {
	        if (!this._depth_childs[depth])
	            return -1;
	        return this._children.indexOf(this._depth_childs[depth]);
	    };
	    DisplayObjectContainer.prototype._updateNextHighestDepth = function () {
	        this._nextHighestDepthDirty = false;
	        this._nextHighestDepth = 0;
	        var len = this._children.length;
	        for (var i = 0; i < len; i++)
	            if (this._nextHighestDepth < this._children[i]._depthID)
	                this._nextHighestDepth = this._children[i]._depthID;
	        this._nextHighestDepth += 1;
	    };
	    DisplayObjectContainer.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        var numChildren = this._children.length;
	        for (var i = 0; i < numChildren; i++)
	            if (this._children[i].hitTestPoint(x, y, shapeFlag, masksFlag))
	                return true;
	        return false;
	    };
	    DisplayObjectContainer.prototype._updateMaskMode = function () {
	        if (this.maskMode)
	            this.mouseChildren = false;
	        _super.prototype._updateMaskMode.call(this);
	    };
	    DisplayObjectContainer.prototype._invalidateChildren = function () {
	        if (this._pIsContainer != Boolean(this._children.length)) {
	            if (this._pImplicitPartition)
	                this._pImplicitPartition._iUnregisterEntity(this);
	            this._pIsContainer = Boolean(this._children.length);
	            if (this._pImplicitPartition)
	                this._pImplicitPartition._iRegisterEntity(this);
	        }
	        this._pInvalidateBounds();
	    };
	    DisplayObjectContainer.assetType = "[asset DisplayObjectContainer]";
	    return DisplayObjectContainer;
	}(DisplayObject_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DisplayObjectContainer;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	/**
	 * RangeError is thrown when an index is accessed out of range of the number of
	 * available indices on an Array.
	 */
	var RangeError = (function (_super) {
	    __extends(RangeError, _super);
	    /**
	     * Create a new RangeError.
	     *
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function RangeError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "RangeError", id);
	    }
	    return RangeError;
	}(ErrorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RangeError;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Box_1 = __webpack_require__(29);
	var ColorTransform_1 = __webpack_require__(46);
	var Sphere_1 = __webpack_require__(48);
	var MathConsts_1 = __webpack_require__(31);
	var Matrix3D_1 = __webpack_require__(28);
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Point_1 = __webpack_require__(36);
	var Vector3D_1 = __webpack_require__(30);
	var AssetBase_1 = __webpack_require__(24);
	var HierarchicalProperties_1 = __webpack_require__(49);
	var BoundsType_1 = __webpack_require__(50);
	var AlignmentMode_1 = __webpack_require__(51);
	var OrientationMode_1 = __webpack_require__(52);
	var Transform_1 = __webpack_require__(53);
	var PickingCollision_1 = __webpack_require__(55);
	var DisplayObjectEvent_1 = __webpack_require__(56);
	var TransformEvent_1 = __webpack_require__(54);
	/**
	 * The DisplayObject class is the base class for all objects that can be
	 * placed on the display list. The display list manages all objects displayed
	 * in flash. Use the DisplayObjectContainer class to arrange the
	 * display objects in the display list. DisplayObjectContainer objects can
	 * have child display objects, while other display objects, such as Shape and
	 * TextField objects, are "leaf" nodes that have only parents and siblings, no
	 * children.
	 *
	 * <p>The DisplayObject class supports basic functionality like the <i>x</i>
	 * and <i>y</i> position of an object, as well as more advanced properties of
	 * the object such as its transformation matrix. </p>
	 *
	 * <p>DisplayObject is an abstract base class; therefore, you cannot call
	 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
	 * <code>ArgumentError</code> exception. </p>
	 *
	 * <p>All display objects inherit from the DisplayObject class.</p>
	 *
	 * <p>The DisplayObject class itself does not include any APIs for rendering
	 * content onscreen. For that reason, if you want create a custom subclass of
	 * the DisplayObject class, you will want to extend one of its subclasses that
	 * do have APIs for rendering content onscreen, such as the Shape, Sprite,
	 * Bitmap, SimpleButton, TextField, or MovieClip class.</p>
	 *
	 * <p>The DisplayObject class contains several broadcast events. Normally, the
	 * target of any particular event is a specific DisplayObject instance. For
	 * example, the target of an <code>added</code> event is the specific
	 * DisplayObject instance that was added to the display list. Having a single
	 * target restricts the placement of event listeners to that target and in
	 * some cases the target's ancestors on the display list. With broadcast
	 * events, however, the target is not a specific DisplayObject instance, but
	 * rather all DisplayObject instances, including those that are not on the
	 * display list. This means that you can add a listener to any DisplayObject
	 * instance to listen for broadcast events. In addition to the broadcast
	 * events listed in the DisplayObject class's Events table, the DisplayObject
	 * class also inherits two broadcast events from the EventDispatcher class:
	 * <code>activate</code> and <code>deactivate</code>.</p>
	 *
	 * <p>Some properties previously used in the ActionScript 1.0 and 2.0
	 * MovieClip, TextField, and Button classes(such as <code>_alpha</code>,
	 * <code>_height</code>, <code>_name</code>, <code>_width</code>,
	 * <code>_x</code>, <code>_y</code>, and others) have equivalents in the
	 * ActionScript 3.0 DisplayObject class that are renamed so that they no
	 * longer begin with the underscore(_) character.</p>
	 *
	 * <p>For more information, see the "Display Programming" chapter of the
	 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
	 *
	 * @event added            Dispatched when a display object is added to the
	 *                         display list. The following methods trigger this
	 *                         event:
	 *                         <code>DisplayObjectContainer.addChild()</code>,
	 *                         <code>DisplayObjectContainer.addChildAt()</code>.
	 * @event addedToScene     Dispatched when a display object is added to the on
	 *                         scene display list, either directly or through the
	 *                         addition of a sub tree in which the display object
	 *                         is contained. The following methods trigger this
	 *                         event:
	 *                         <code>DisplayObjectContainer.addChild()</code>,
	 *                         <code>DisplayObjectContainer.addChildAt()</code>.
	 * @event enterFrame       [broadcast event] Dispatched when the playhead is
	 *                         entering a new frame. If the playhead is not
	 *                         moving, or if there is only one frame, this event
	 *                         is dispatched continuously in conjunction with the
	 *                         frame rate. This event is a broadcast event, which
	 *                         means that it is dispatched by all display objects
	 *                         with a listener registered for this event.
	 * @event exitFrame        [broadcast event] Dispatched when the playhead is
	 *                         exiting the current frame. All frame scripts have
	 *                         been run. If the playhead is not moving, or if
	 *                         there is only one frame, this event is dispatched
	 *                         continuously in conjunction with the frame rate.
	 *                         This event is a broadcast event, which means that
	 *                         it is dispatched by all display objects with a
	 *                         listener registered for this event.
	 * @event frameConstructed [broadcast event] Dispatched after the constructors
	 *                         of frame display objects have run but before frame
	 *                         scripts have run. If the playhead is not moving, or
	 *                         if there is only one frame, this event is
	 *                         dispatched continuously in conjunction with the
	 *                         frame rate. This event is a broadcast event, which
	 *                         means that it is dispatched by all display objects
	 *                         with a listener registered for this event.
	 * @event removed          Dispatched when a display object is about to be
	 *                         removed from the display list. Two methods of the
	 *                         DisplayObjectContainer class generate this event:
	 *                         <code>removeChild()</code> and
	 *                         <code>removeChildAt()</code>.
	 *
	 *                         <p>The following methods of a
	 *                         DisplayObjectContainer object also generate this
	 *                         event if an object must be removed to make room for
	 *                         the new object: <code>addChild()</code>,
	 *                         <code>addChildAt()</code>, and
	 *                         <code>setChildIndex()</code>. </p>
	 * @event removedFromScene Dispatched when a display object is about to be
	 *                         removed from the display list, either directly or
	 *                         through the removal of a sub tree in which the
	 *                         display object is contained. Two methods of the
	 *                         DisplayObjectContainer class generate this event:
	 *                         <code>removeChild()</code> and
	 *                         <code>removeChildAt()</code>.
	 *
	 *                         <p>The following methods of a
	 *                         DisplayObjectContainer object also generate this
	 *                         event if an object must be removed to make room for
	 *                         the new object: <code>addChild()</code>,
	 *                         <code>addChildAt()</code>, and
	 *                         <code>setChildIndex()</code>. </p>
	 * @event render           [broadcast event] Dispatched when the display list
	 *                         is about to be updated and rendered. This event
	 *                         provides the last opportunity for objects listening
	 *                         for this event to make changes before the display
	 *                         list is rendered. You must call the
	 *                         <code>invalidate()</code> method of the Scene
	 *                         object each time you want a <code>render</code>
	 *                         event to be dispatched. <code>Render</code> events
	 *                         are dispatched to an object only if there is mutual
	 *                         trust between it and the object that called
	 *                         <code>Scene.invalidate()</code>. This event is a
	 *                         broadcast event, which means that it is dispatched
	 *                         by all display objects with a listener registered
	 *                         for this event.
	 *
	 *                         <p><b>Note: </b>This event is not dispatched if the
	 *                         display is not rendering. This is the case when the
	 *                         content is either minimized or obscured. </p>
	 */
	var DisplayObject = (function (_super) {
	    __extends(DisplayObject, _super);
	    /**
	     * Creates a new <code>DisplayObject</code> instance.
	     */
	    function DisplayObject() {
	        var _this = this;
	        _super.call(this);
	        this._queuedEvents = new Array();
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        this._pSceneTransform = new Matrix3D_1.default();
	        this._pIsEntity = false;
	        this._pIsContainer = false;
	        this._sessionID = -1;
	        this._depthID = -16384;
	        this._inverseSceneTransform = new Matrix3D_1.default();
	        this._scenePosition = new Vector3D_1.default();
	        this._explicitVisibility = true;
	        this._explicitMaskId = -1;
	        this._pImplicitVisibility = true;
	        this._pImplicitMaskId = -1;
	        this._pImplicitMaskIds = new Array();
	        this._explicitMouseEnabled = true;
	        this._pImplicitMouseEnabled = true;
	        this._orientationMatrix = new Matrix3D_1.default();
	        this._inheritColorTransform = false;
	        this._maskMode = false;
	        //temp vector used in global to local
	        this._tempVector3D = new Vector3D_1.default();
	        /**
	         *
	         */
	        this.alignmentMode = AlignmentMode_1.default.REGISTRATION_POINT;
	        /**
	         *
	         */
	        this.castsShadows = true;
	        /**
	         *
	         */
	        this.orientationMode = OrientationMode_1.default.DEFAULT;
	        /**
	         *
	         */
	        this.zOffset = 0;
	        //creation of associated transform object
	        this._transform = new Transform_1.default();
	        //setup transform listeners
	        this._transform.addEventListener(TransformEvent_1.default.INVALIDATE_MATRIX3D, function (event) { return _this._onInvalidateMatrix3D(event); });
	        this._transform.addEventListener(TransformEvent_1.default.INVALIDATE_COLOR_TRANSFORM, function (event) { return _this._onInvalidateColorTransform(event); });
	        //default bounds type
	        this._boundsType = BoundsType_1.default.AXIS_ALIGNED_BOX;
	    }
	    Object.defineProperty(DisplayObject.prototype, "adapter", {
	        /**
	         * adapter is used to provide MovieClip to scripts taken from different platforms
	         * setter typically managed by factory
	         */
	        get: function () {
	            return this._adapter;
	        },
	        set: function (value) {
	            this._adapter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "inheritColorTransform", {
	        get: function () {
	            return this._inheritColorTransform;
	        },
	        set: function (value) {
	            if (this._inheritColorTransform == value)
	                return;
	            this._inheritColorTransform = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.COLOR_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "alpha", {
	        /**
	         * Indicates the alpha transparency value of the object specified. Valid
	         * values are 0(fully transparent) to 1(fully opaque). The default value is
	         * 1. Display objects with <code>alpha</code> set to 0 <i>are</i> active,
	         * even though they are invisible.
	         */
	        get: function () {
	            return this._transform.colorTransform ? this._transform.colorTransform.alphaMultiplier : 1;
	        },
	        set: function (value) {
	            if (!this._transform.colorTransform)
	                this._transform.colorTransform = new ColorTransform_1.default();
	            this._transform.colorTransform.alphaMultiplier = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "boundsType", {
	        /**
	         *
	         */
	        get: function () {
	            return this._boundsType;
	        },
	        set: function (value) {
	            if (this._boundsType == value)
	                return;
	            this._boundsType = value;
	            this.invalidate();
	            this._pInvalidateBounds();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "depth", {
	        /**
	         * Indicates the depth of the display object, in pixels. The depth is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>depth</code> property, the <code>scaleZ</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content (such as an empty sprite) has a depth of 0, even if you try to
	         * set <code>depth</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().depth * this.scaleZ;
	        },
	        set: function (val) {
	            if (this._depth == val)
	                return;
	            this._depth = val;
	            this._setScaleZ(val / this.getBox().depth);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "eulers", {
	        /**
	         * Defines the rotation of the 3d object as a <code>Vector3D</code> object containing euler angles for rotation around x, y and z axis.
	         */
	        get: function () {
	            if (!this._eulers)
	                this._eulers = new Vector3D_1.default();
	            this._eulers.x = this.rotationX;
	            this._eulers.y = this.rotationY;
	            this._eulers.z = this.rotationZ;
	            return this._eulers;
	        },
	        set: function (value) {
	            this.rotationX = value.x;
	            this.rotationY = value.y;
	            this.rotationZ = value.z;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "height", {
	        /**
	         * An indexed array that contains each filter object currently associated
	         * with the display object. The flash.filters package contains several
	         * classes that define specific filters you can use.
	         *
	         * <p>Filters can be applied in Flash Professional at design time, or at run
	         * time by using ActionScript code. To apply a filter by using ActionScript,
	         * you must make a temporary copy of the entire <code>filters</code> array,
	         * modify the temporary array, then assign the value of the temporary array
	         * back to the <code>filters</code> array. You cannot directly add a new
	         * filter object to the <code>filters</code> array.</p>
	         *
	         * <p>To add a filter by using ActionScript, perform the following steps
	         * (assume that the target display object is named
	         * <code>myDisplayObject</code>):</p>
	         *
	         * <ol>
	         *   <li>Create a new filter object by using the constructor method of your
	         * chosen filter class.</li>
	         *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
	         * to a temporary array, such as one named <code>myFilters</code>.</li>
	         *   <li>Add the new filter object to the <code>myFilters</code> temporary
	         * array.</li>
	         *   <li>Assign the value of the temporary array to the
	         * <code>myDisplayObject.filters</code> array.</li>
	         * </ol>
	         *
	         * <p>If the <code>filters</code> array is undefined, you do not need to use
	         * a temporary array. Instead, you can directly assign an array literal that
	         * contains one or more filter objects that you create. The first example in
	         * the Examples section adds a drop shadow filter by using code that handles
	         * both defined and undefined <code>filters</code> arrays.</p>
	         *
	         * <p>To modify an existing filter object, you must use the technique of
	         * modifying a copy of the <code>filters</code> array:</p>
	         *
	         * <ol>
	         *   <li>Assign the value of the <code>filters</code> array to a temporary
	         * array, such as one named <code>myFilters</code>.</li>
	         *   <li>Modify the property by using the temporary array,
	         * <code>myFilters</code>. For example, to set the quality property of the
	         * first filter in the array, you could use the following code:
	         * <code>myFilters[0].quality = 1;</code></li>
	         *   <li>Assign the value of the temporary array to the <code>filters</code>
	         * array.</li>
	         * </ol>
	         *
	         * <p>At load time, if a display object has an associated filter, it is
	         * marked to cache itself as a transparent bitmap. From this point forward,
	         * as long as the display object has a valid filter list, the player caches
	         * the display object as a bitmap. This source bitmap is used as a source
	         * image for the filter effects. Each display object usually has two bitmaps:
	         * one with the original unfiltered source display object and another for the
	         * final image after filtering. The final image is used when rendering. As
	         * long as the display object does not change, the final image does not need
	         * updating.</p>
	         *
	         * <p>The flash.filters package includes classes for filters. For example, to
	         * create a DropShadow filter, you would write:</p>
	         *
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader output type is not compatible with
	         *                       this operation(the shader must specify a
	         *                       <code>pixel4</code> output).
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader doesn't specify any image input or
	         *                       the first input is not an <code>image4</code> input.
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader specifies an image input that isn't
	         *                       provided.
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
	         *                       ByteArray or Vector.<Number> instance as a shader
	         *                       input, and the <code>width</code> and
	         *                       <code>height</code> properties aren't specified for
	         *                       the ShaderInput object, or the specified values
	         *                       don't match the amount of data in the input data.
	         *                       See the <code>ShaderInput.input</code> property for
	         *                       more information.
	         */
	        //		public filters:Array<Dynamic>;
	        /**
	         * Indicates the height of the display object, in pixels. The height is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>height</code> property, the <code>scaleY</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content (such as an empty sprite) has a height of 0, even if you try to
	         * set <code>height</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().height * this.scaleY;
	        },
	        set: function (val) {
	            if (this._height == val)
	                return;
	            this._height = val;
	            this._setScaleY(val / this.getBox().height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "index", {
	        /**
	         * Indicates the instance container index of the DisplayObject. The object can be
	         * identified in the child list of its parent display object container by
	         * calling the <code>getChildByIndex()</code> method of the display object
	         * container.
	         *
	         * <p>If the DisplayObject has no parent container, index defaults to 0.</p>
	         */
	        get: function () {
	            if (this._pParent)
	                return this._pParent.getChildIndex(this);
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "inverseSceneTransform", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._inverseSceneTransformDirty) {
	                this._inverseSceneTransform.copyFrom(this.sceneTransform);
	                this._inverseSceneTransform.invert();
	                this._inverseSceneTransformDirty = false;
	            }
	            return this._inverseSceneTransform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "isEntity", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pIsEntity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "isContainer", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pIsContainer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
	        /**
	         * Returns a LoaderInfo object containing information about loading the file
	         * to which this display object belongs. The <code>loaderInfo</code> property
	         * is defined only for the root display object of a SWF file or for a loaded
	         * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
	         * <code>loaderInfo</code> object associated with the SWF file that contains
	         * a display object named <code>myDisplayObject</code>, use
	         * <code>myDisplayObject.root.loaderInfo</code>.
	         *
	         * <p>A large SWF file can monitor its download by calling
	         * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
	         * func)</code>.</p>
	         */
	        get: function () {
	            return this._loaderInfo;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "maskMode", {
	        get: function () {
	            return this._maskMode;
	        },
	        set: function (value) {
	            if (this._maskMode == value)
	                return;
	            this._maskMode = value;
	            this._explicitMaskId = value ? this.id : -1;
	            this._updateMaskMode();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseEnabled", {
	        /**
	         * Specifies whether this object receives mouse, or other user input,
	         * messages. The default value is <code>true</code>, which means that by
	         * default any InteractiveObject instance that is on the display list
	         * receives mouse events or other user input events. If
	         * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
	         * not receive any mouse events(or other user input events like keyboard
	         * events). Any children of this instance on the display list are not
	         * affected. To change the <code>mouseEnabled</code> behavior for all
	         * children of an object on the display list, use
	         * <code>flash.display.DisplayObjectContainer.mouseChildren</code>.
	         *
	         * <p> No event is dispatched by setting this property. You must use the
	         * <code>addEventListener()</code> method to create interactive
	         * functionality.</p>
	         */
	        get: function () {
	            return this._explicitMouseEnabled;
	        },
	        set: function (value) {
	            if (this._explicitMouseEnabled == value)
	                return;
	            this._explicitMouseEnabled = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseX", {
	        /**
	         * Indicates the x coordinate of the mouse or user input device position, in
	         * pixels.
	         *
	         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
	         * coordinate will reflect the non-rotated object.</p>
	         */
	        get: function () {
	            return this._mouseX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseY", {
	        /**
	         * Indicates the y coordinate of the mouse or user input device position, in
	         * pixels.
	         *
	         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
	         * coordinate will reflect the non-rotated object.</p>
	         */
	        get: function () {
	            return this._mouseY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "name", {
	        /**
	         * Indicates the instance name of the DisplayObject. The object can be
	         * identified in the child list of its parent display object container by
	         * calling the <code>getChildByName()</code> method of the display object
	         * container.
	         *
	         * @throws IllegalOperationError If you are attempting to set this property
	         *                               on an object that was placed on the timeline
	         *                               in the Flash authoring tool.
	         */
	        get: function () {
	            return this._pName;
	        },
	        set: function (value) {
	            this._pName = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "parent", {
	        /**
	         * Indicates the DisplayObjectContainer object that contains this display
	         * object. Use the <code>parent</code> property to specify a relative path to
	         * display objects that are above the current display object in the display
	         * list hierarchy.
	         *
	         * <p>You can use <code>parent</code> to move up multiple levels in the
	         * display list as in the following:</p>
	         *
	         * @throws SecurityError The parent display object belongs to a security
	         *                       sandbox to which you do not have access. You can
	         *                       avoid this situation by having the parent movie call
	         *                       the <code>Security.allowDomain()</code> method.
	         */
	        get: function () {
	            return this._pParent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "partition", {
	        /**
	         *
	         */
	        get: function () {
	            return this._explicitPartition;
	        },
	        set: function (value) {
	            if (this._explicitPartition == value)
	                return;
	            this._explicitPartition = value;
	            this._iSetScene(this._pScene, this._pParent ? this._pParent._iAssignedPartition : null);
	            this.dispatchEvent(new DisplayObjectEvent_1.default(DisplayObjectEvent_1.default.PARTITION_CHANGED, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "pivot", {
	        /**
	         * Defines the local point around which the object rotates.
	         */
	        get: function () {
	            return this._pivot;
	        },
	        set: function (pivot) {
	            if (this._pivot && this._pivot.x == pivot.x && this._pivot.y == pivot.y && this._pivot.z == pivot.z)
	                return;
	            if (!pivot) {
	                this._pivot = null;
	                this._pivotScale = null;
	            }
	            else {
	                if (!this._pivot)
	                    this._pivot = new Vector3D_1.default();
	                this._pivot.x = pivot.x;
	                this._pivot.y = pivot.y;
	                this._pivot.z = pivot.z;
	            }
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.SCENE_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "root", {
	        /**
	         * For a display object in a loaded SWF file, the <code>root</code> property
	         * is the top-most display object in the portion of the display list's tree
	         * structure represented by that SWF file. For a Bitmap object representing a
	         * loaded image file, the <code>root</code> property is the Bitmap object
	         * itself. For the instance of the main class of the first SWF file loaded,
	         * the <code>root</code> property is the display object itself. The
	         * <code>root</code> property of the Scene object is the Scene object itself.
	         * The <code>root</code> property is set to <code>null</code> for any display
	         * object that has not been added to the display list, unless it has been
	         * added to a display object container that is off the display list but that
	         * is a child of the top-most display object in a loaded SWF file.
	         *
	         * <p>For example, if you create a new Sprite object by calling the
	         * <code>Sprite()</code> constructor method, its <code>root</code> property
	         * is <code>null</code> until you add it to the display list(or to a display
	         * object container that is off the display list but that is a child of the
	         * top-most display object in a SWF file).</p>
	         *
	         * <p>For a loaded SWF file, even though the Loader object used to load the
	         * file may not be on the display list, the top-most display object in the
	         * SWF file has its <code>root</code> property set to itself. The Loader
	         * object does not have its <code>root</code> property set until it is added
	         * as a child of a display object for which the <code>root</code> property is
	         * set.</p>
	         */
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationX", {
	        /**
	         * Indicates the x-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.x * MathConsts_1.default.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationX == val)
	                return;
	            this._transform.rotation.x = val * MathConsts_1.default.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationY", {
	        /**
	         * Indicates the y-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.y * MathConsts_1.default.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationY == val)
	                return;
	            this._transform.rotation.y = val * MathConsts_1.default.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationZ", {
	        /**
	         * Indicates the z-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.z * MathConsts_1.default.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationZ == val)
	                return;
	            this._transform.rotation.z = val * MathConsts_1.default.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleX", {
	        /**
	         * Indicates the horizontal scale(percentage) of the object as applied from
	         * the registration point. The default registration point is(0,0). 1.0
	         * equals 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code> and
	         * <code>y</code> property values, which are defined in whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.x;
	        },
	        set: function (val) {
	            //remove absolute width
	            this._width = null;
	            this._setScaleX(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleY", {
	        /**
	         * Indicates the vertical scale(percentage) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         * 1.0 is 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code> and
	         * <code>y</code> property values, which are defined in whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.y;
	        },
	        set: function (val) {
	            //remove absolute height
	            this._height = null;
	            this._setScaleY(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleZ", {
	        /**
	         * Indicates the depth scale(percentage) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         * 1.0 is 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code>,
	         * <code>y</code> and <code>z</code> property values, which are defined in
	         * whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.z;
	        },
	        set: function (val) {
	            //remove absolute depth
	            this._depth = null;
	            this._setScaleZ(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewX", {
	        /**
	         * Indicates the horizontal skew(angle) of the object as applied from
	         * the registration point. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.x;
	        },
	        set: function (val) {
	            if (this.skewX == val)
	                return;
	            this._transform.skew.x = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewY", {
	        /**
	         * Indicates the vertical skew(angle) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.y;
	        },
	        set: function (val) {
	            if (this.skewY == val)
	                return;
	            this._transform.skew.y = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewZ", {
	        /**
	         * Indicates the depth skew(angle) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.z;
	        },
	        set: function (val) {
	            if (this.skewZ == val)
	                return;
	            this._transform.skew.z = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scene", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pScene;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scenePosition", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._scenePositionDirty) {
	                if (this._pivot && this.alignmentMode == AlignmentMode_1.default.PIVOT_POINT) {
	                    this._scenePosition = this.sceneTransform.transformVector(this._pivotScale);
	                }
	                else {
	                    this.sceneTransform.copyColumnTo(3, this._scenePosition);
	                }
	                this._scenePositionDirty = false;
	            }
	            return this._scenePosition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "sceneTransform", {
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.SCENE_TRANSFORM)
	                this.pUpdateSceneTransform();
	            return this._pSceneTransform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "shaderPickingDetails", {
	        /**
	         *
	         */
	        get: function () {
	            return this._shaderPickingDetails;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "debugVisible", {
	        /**
	         *
	         */
	        get: function () {
	            return this._debugVisible;
	        },
	        set: function (value) {
	            if (value == this._debugVisible)
	                return;
	            this._debugVisible = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "transform", {
	        /**
	         * An object with properties pertaining to a display object's matrix, color
	         * transform, and pixel bounds. The specific properties  -  matrix,
	         * colorTransform, and three read-only properties
	         * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
	         * and <code>pixelBounds</code>)  -  are described in the entry for the
	         * Transform class.
	         *
	         * <p>Each of the transform object's properties is itself an object. This
	         * concept is important because the only way to set new values for the matrix
	         * or colorTransform objects is to create a new object and copy that object
	         * into the transform.matrix or transform.colorTransform property.</p>
	         *
	         * <p>For example, to increase the <code>tx</code> value of a display
	         * object's matrix, you must make a copy of the entire matrix object, then
	         * copy the new object into the matrix property of the transform object:</p>
	         * <pre xml:space="preserve"><code> public myMatrix:Matrix =
	         * myDisplayObject.transform.matrix; myMatrix.tx += 10;
	         * myDisplayObject.transform.matrix = myMatrix; </code></pre>
	         *
	         * <p>You cannot directly set the <code>tx</code> property. The following
	         * code has no effect on <code>myDisplayObject</code>: </p>
	         * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
	         * 10; </code></pre>
	         *
	         * <p>You can also copy an entire transform object and assign it to another
	         * display object's transform property. For example, the following code
	         * copies the entire transform object from <code>myOldDisplayObj</code> to
	         * <code>myNewDisplayObj</code>:</p>
	         * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
	         *
	         * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
	         * same values for its matrix, color transform, and pixel bounds as the old
	         * display object, <code>myOldDisplayObj</code>.</p>
	         *
	         * <p>Note that AIR for TV devices use hardware acceleration, if it is
	         * available, for color transforms.</p>
	         */
	        get: function () {
	            return this._transform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "visible", {
	        /**
	         * Whether or not the display object is visible. Display objects that are not
	         * visible are disabled. For example, if <code>visible=false</code> for an
	         * InteractiveObject instance, it cannot be clicked.
	         */
	        get: function () {
	            return this._explicitVisibility;
	        },
	        set: function (value) {
	            if (this._explicitVisibility == value)
	                return;
	            this._explicitVisibility = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.VISIBLE);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "masks", {
	        get: function () {
	            return this._explicitMasks;
	        },
	        set: function (value) {
	            if (this._explicitMasks == value)
	                return;
	            this._explicitMasks = value;
	            //make sure maskMode is set to true for all masks
	            if (value != null && value.length) {
	                var len = value.length;
	                for (var i = 0; i < len; i++)
	                    value[i].maskMode = true;
	            }
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.MASKS);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "width", {
	        /**
	         * Indicates the width of the display object, in pixels. The width is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>width</code> property, the <code>scaleX</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content(such as an empty sprite) has a width of 0, even if you try to set
	         * <code>width</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().width * this.scaleX;
	        },
	        set: function (val) {
	            if (this._width == val)
	                return;
	            this._width = val;
	            this._setScaleX(val / this.getBox().width);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "x", {
	        /**
	         * Indicates the <i>x</i> coordinate of the DisplayObject instance relative
	         * to the local coordinates of the parent DisplayObjectContainer. If the
	         * object is inside a DisplayObjectContainer that has transformations, it is
	         * in the local coordinate system of the enclosing DisplayObjectContainer.
	         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	         * DisplayObjectContainer's children inherit a coordinate system that is
	         * rotated 90° counterclockwise. The object's coordinates refer to the
	         * registration point position.
	         */
	        get: function () {
	            return this._transform.position.x;
	        },
	        set: function (val) {
	            if (this._transform.position.x == val)
	                return;
	            this._transform.matrix3D.rawData[12] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "y", {
	        /**
	         * Indicates the <i>y</i> coordinate of the DisplayObject instance relative
	         * to the local coordinates of the parent DisplayObjectContainer. If the
	         * object is inside a DisplayObjectContainer that has transformations, it is
	         * in the local coordinate system of the enclosing DisplayObjectContainer.
	         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	         * DisplayObjectContainer's children inherit a coordinate system that is
	         * rotated 90° counterclockwise. The object's coordinates refer to the
	         * registration point position.
	         */
	        get: function () {
	            return this._transform.position.y;
	        },
	        set: function (val) {
	            if (this._transform.position.y == val)
	                return;
	            this._transform.matrix3D.rawData[13] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "z", {
	        /**
	         * Indicates the z coordinate position along the z-axis of the DisplayObject
	         * instance relative to the 3D parent container. The z property is used for
	         * 3D coordinates, not screen or pixel coordinates.
	         *
	         * <p>When you set a <code>z</code> property for a display object to
	         * something other than the default value of <code>0</code>, a corresponding
	         * Matrix3D object is automatically created. for adjusting a display object's
	         * position and orientation in three dimensions. When working with the
	         * z-axis, the existing behavior of x and y properties changes from screen or
	         * pixel coordinates to positions relative to the 3D parent container.</p>
	         *
	         * <p>For example, a child of the <code>_root</code> at position x = 100, y =
	         * 100, z = 200 is not drawn at pixel location(100,100). The child is drawn
	         * wherever the 3D projection calculation puts it. The calculation is:</p>
	         *
	         * <p><code>(x~~cameraFocalLength/cameraRelativeZPosition,
	         * y~~cameraFocalLength/cameraRelativeZPosition)</code></p>
	         */
	        get: function () {
	            return this._transform.position.z;
	        },
	        set: function (val) {
	            if (this._transform.position.z == val)
	                return;
	            this._transform.matrix3D.rawData[14] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    DisplayObject.prototype.addEventListener = function (type, listener) {
	        _super.prototype.addEventListener.call(this, type, listener);
	        switch (type) {
	            case DisplayObjectEvent_1.default.SCENE_CHANGED:
	                this._listenToSceneChanged = true;
	                break;
	            case DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED:
	                this._listenToSceneTransformChanged = true;
	                break;
	        }
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.clone = function () {
	        var newInstance = new DisplayObject();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    DisplayObject.prototype.copyTo = function (newInstance) {
	        newInstance.partition = this._explicitPartition;
	        newInstance.boundsType = this._boundsType;
	        newInstance.pivot = this._pivot;
	        newInstance.name = this._pName;
	        newInstance.mouseEnabled = this._explicitMouseEnabled;
	        newInstance.extra = this.extra;
	        newInstance.maskMode = this._maskMode;
	        newInstance.castsShadows = this.castsShadows;
	        if (this._explicitMasks)
	            newInstance.masks = this._explicitMasks;
	        if (this._adapter)
	            newInstance.adapter = this._adapter.clone(newInstance);
	        newInstance._transform.matrix3D = this._transform.matrix3D;
	        if (this._transform.colorTransform)
	            newInstance.transform.colorTransform = this._transform.colorTransform.clone();
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.dispose = function () {
	        this.disposeValues();
	    };
	    DisplayObject.prototype.disposeValues = function () {
	        if (this._pParent)
	            this._pParent.removeChild(this);
	        //if (this._adapter) {
	        //	this._adapter.dispose();
	        //	this._adapter = null;
	        //}
	        //this._pos = null;
	        //this._rot = null;
	        //this._sca = null;
	        //this._ske = null;
	        //this._transformComponents = null;
	        //this._transform.dispose();
	        //this._transform = null;
	        //
	        //this._matrix3D = null;
	        //this._pSceneTransform = null;
	        //this._inverseSceneTransform = null;
	        this._explicitMasks = null;
	    };
	    /**
	     * Returns a rectangle that defines the area of the display object relative
	     * to the coordinate system of the <code>targetCoordinateSpace</code> object.
	     * Consider the following code, which shows how the rectangle returned can
	     * vary depending on the <code>targetCoordinateSpace</code> parameter that
	     * you pass to the method:
	     *
	     * <p><b>Note:</b> Use the <code>localToGlobal()</code> and
	     * <code>globalToLocal()</code> methods to convert the display object's local
	     * coordinates to display coordinates, or display coordinates to local
	     * coordinates, respectively.</p>
	     *
	     * <p>The <code>getBounds()</code> method is similar to the
	     * <code>getRect()</code> method; however, the Rectangle returned by the
	     * <code>getBounds()</code> method includes any strokes on shapes, whereas
	     * the Rectangle returned by the <code>getRect()</code> method does not. For
	     * an example, see the description of the <code>getRect()</code> method.</p>
	     *
	     * @param targetCoordinateSpace The display object that defines the
	     *                              coordinate system to use.
	     * @return The rectangle that defines the area of the display object relative
	     *         to the <code>targetCoordinateSpace</code> object's coordinate
	     *         system.
	     */
	    DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
	        return this._bounds; //TODO
	    };
	    /**
	     * Returns a rectangle that defines the boundary of the display object, based
	     * on the coordinate system defined by the <code>targetCoordinateSpace</code>
	     * parameter, excluding any strokes on shapes. The values that the
	     * <code>getRect()</code> method returns are the same or smaller than those
	     * returned by the <code>getBounds()</code> method.
	     *
	     * <p><b>Note:</b> Use <code>localToGlobal()</code> and
	     * <code>globalToLocal()</code> methods to convert the display object's local
	     * coordinates to Scene coordinates, or Scene coordinates to local
	     * coordinates, respectively.</p>
	     *
	     * @param targetCoordinateSpace The display object that defines the
	     *                              coordinate system to use.
	     * @return The rectangle that defines the area of the display object relative
	     *         to the <code>targetCoordinateSpace</code> object's coordinate
	     *         system.
	     */
	    DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        return this._bounds; //TODO
	    };
	    DisplayObject.prototype.getBox = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        //TODO targetCoordinateSpace
	        if (this._boxBoundsInvalid) {
	            this._pUpdateBoxBounds();
	            //scale updates if absolute dimensions are detected
	            if (this._width != null)
	                this._setScaleX(this._width / this._pBoxBounds.width);
	            if (this._height != null)
	                this._setScaleY(this._height / this._pBoxBounds.height);
	            if (this._depth != null)
	                this._setScaleZ(this._depth / this._pBoxBounds.depth);
	        }
	        if (targetCoordinateSpace == null || targetCoordinateSpace == this)
	            return this._pBoxBounds;
	        if (targetCoordinateSpace == this._pParent)
	            return this._transform.matrix3D.transformBox(this._pBoxBounds);
	        else
	            return targetCoordinateSpace.inverseSceneTransform.transformBox(this.sceneTransform.transformBox(this._pBoxBounds));
	    };
	    DisplayObject.prototype.getSphere = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        if (this._sphereBoundsInvalid)
	            this._pUpdateSphereBounds();
	        return this._pSphereBounds;
	    };
	    /**
	     * Converts the <code>point</code> object from the Scene(global) coordinates
	     * to the display object's(local) coordinates.
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent global coordinates
	     * because they relate to the origin(0,0) of the main display area. Then
	     * pass the Point instance as the parameter to the
	     * <code>globalToLocal()</code> method. The method returns a new Point object
	     * with <i>x</i> and <i>y</i> values that relate to the origin of the display
	     * object instead of the origin of the Scene.</p>
	     *
	     * @param point An object created with the Point class. The Point object
	     *              specifies the <i>x</i> and <i>y</i> coordinates as
	     *              properties.
	     * @return A Point object with coordinates relative to the display object.
	     */
	    DisplayObject.prototype.globalToLocal = function (point, target) {
	        if (target === void 0) { target = null; }
	        this._tempVector3D.setTo(point.x, point.y, 0);
	        var pos = this.inverseSceneTransform.transformVector(this._tempVector3D, this._tempVector3D);
	        if (!target)
	            target = new Point_1.default();
	        target.x = pos.x;
	        target.y = pos.y;
	        return target;
	    };
	    /**
	     * Converts a two-dimensional point from the Scene(global) coordinates to a
	     * three-dimensional display object's(local) coordinates.
	     *
	     * <p>To use this method, first create an instance of the Vector3D class. The x,
	     * y and z values that you assign to the Vector3D object represent global
	     * coordinates because they are relative to the origin(0,0,0) of the scene. Then
	     * pass the Vector3D object to the <code>globalToLocal3D()</code> method as the
	     * <code>position</code> parameter.
	     * The method returns three-dimensional coordinates as a Vector3D object
	     * containing <code>x</code>, <code>y</code>, and <code>z</code> values that
	     * are relative to the origin of the three-dimensional display object.</p>
	     *
	     * @param point A Vector3D object representing global x, y and z coordinates in
	     *              the scene.
	     * @return A Vector3D object with coordinates relative to the three-dimensional
	     *         display object.
	     */
	    DisplayObject.prototype.globalToLocal3D = function (position) {
	        return this.inverseSceneTransform.transformVector(position);
	    };
	    /**
	     * Evaluates the bounding box of the display object to see if it overlaps or
	     * intersects with the bounding box of the <code>obj</code> display object.
	     *
	     * @param obj The display object to test against.
	     * @return <code>true</code> if the bounding boxes of the display objects
	     *         intersect; <code>false</code> if not.
	     */
	    DisplayObject.prototype.hitTestObject = function (obj) {
	        var objBox = obj.getBox();
	        if (!objBox)
	            return false;
	        var topLeft = new Point_1.default(objBox.x, objBox.y);
	        var bottomLeft = new Point_1.default(objBox.x, objBox.y - objBox.height);
	        var topRight = new Point_1.default(objBox.x + objBox.width, objBox.y);
	        var bottomRight = new Point_1.default(objBox.x + objBox.width, objBox.y - objBox.height);
	        topLeft = this.globalToLocal(obj.localToGlobal(topLeft));
	        bottomLeft = this.globalToLocal(obj.localToGlobal(bottomLeft));
	        topRight = this.globalToLocal(obj.localToGlobal(topRight));
	        bottomRight = this.globalToLocal(obj.localToGlobal(bottomRight));
	        var box = this.getBox();
	        if (!box)
	            return false;
	        //first check all points against targer box
	        if (topLeft.x <= box.left && topLeft.x <= box.left && topLeft.y <= box.top && topLeft.y >= box.bottom)
	            return true;
	        if (bottomLeft.x <= box.left && bottomLeft.x <= box.left && bottomLeft.y <= box.top && bottomLeft.y >= box.bottom)
	            return true;
	        if (topRight.x <= box.left && topRight.x <= box.left && topRight.y <= box.top && topRight.y >= box.bottom)
	            return true;
	        if (bottomRight.x <= box.left && bottomRight.x <= box.left && bottomRight.y <= box.top && bottomRight.y >= box.bottom)
	            return true;
	        //now test against obj box
	        var n0x = topRight.y - topLeft.y;
	        var n0y = -(topRight.x - topLeft.x);
	        var n1x = bottomRight.y - topRight.y;
	        var n1y = -(bottomRight.x - topRight.x);
	        var n2x = bottomLeft.y - bottomRight.y;
	        var n2y = -(bottomLeft.x - bottomRight.x);
	        var n3x = topLeft.y - bottomLeft.y;
	        var n3y = -(topLeft.x - bottomLeft.x);
	        var p0x = box.left - topLeft.x;
	        var p0y = box.top - topLeft.y;
	        var p1x = box.left - topRight.x;
	        var p1y = box.top - topRight.y;
	        var p2x = box.left - bottomRight.x;
	        var p2y = box.top - bottomRight.y;
	        var p3x = box.left - bottomLeft.x;
	        var p3y = box.top - bottomLeft.y;
	        var dot0 = (n0x * p0x) + (n0y * p0y);
	        var dot1 = (n1x * p1x) + (n1y * p1y);
	        var dot2 = (n2x * p2x) + (n2y * p2y);
	        var dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if topLeft is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.right - topLeft.x;
	        p0y = box.top - topLeft.y;
	        p1x = box.right - topRight.x;
	        p1y = box.top - topRight.y;
	        p2x = box.right - bottomRight.x;
	        p2y = box.top - bottomRight.y;
	        p3x = box.right - bottomLeft.x;
	        p3y = box.top - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if topRight is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.left - topLeft.x;
	        p0y = box.bottom - topLeft.y;
	        p1x = box.left - topRight.x;
	        p1y = box.bottom - topRight.y;
	        p2x = box.left - bottomRight.x;
	        p2y = box.bottom - bottomRight.y;
	        p3x = box.left - bottomLeft.x;
	        p3y = box.bottom - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if bottomLeft is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.right - topLeft.x;
	        p0y = box.bottom - topLeft.y;
	        p1x = box.right - topRight.x;
	        p1y = box.bottom - topRight.y;
	        p2x = box.right - bottomRight.x;
	        p2y = box.bottom - bottomRight.y;
	        p3x = box.right - bottomLeft.x;
	        p3y = box.bottom - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if bottomRight is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        return false; //TODO
	    };
	    /**
	     * Evaluates the display object to see if it overlaps or intersects with the
	     * point specified by the <code>x</code> and <code>y</code> parameters. The
	     * <code>x</code> and <code>y</code> parameters specify a point in the
	     * coordinate space of the Scene, not the display object container that
	     * contains the display object(unless that display object container is the
	     * Scene).
	     *
	     * @param x         The <i>x</i> coordinate to test against this object.
	     * @param y         The <i>y</i> coordinate to test against this object.
	     * @param shapeFlag Whether to check against the actual pixels of the object
	     *                 (<code>true</code>) or the bounding box
	     *                 (<code>false</code>).
	     * @param maskFlag Whether to check against the object when it is used as mask
	     *                 (<code>false</code>).
	     * @return <code>true</code> if the display object overlaps or intersects
	     *         with the specified point; <code>false</code> otherwise.
	     */
	    DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag, masksFlag) {
	        if (shapeFlag === void 0) { shapeFlag = false; }
	        if (masksFlag === void 0) { masksFlag = false; }
	        if (!this._pImplicitVisibility)
	            return;
	        if (this._pImplicitMaskId != -1 && !masksFlag)
	            return;
	        if (this._explicitMasks) {
	            var numMasks = this._explicitMasks.length;
	            var maskHit = false;
	            for (var i = 0; i < numMasks; i++) {
	                if (this._explicitMasks[i].hitTestPoint(x, y, shapeFlag, true)) {
	                    maskHit = true;
	                    break;
	                }
	            }
	            if (!maskHit)
	                return false;
	        }
	        return this._hitTestPointInternal(x, y, shapeFlag, masksFlag);
	    };
	    DisplayObject.prototype.isMask = function () {
	        return this._explicitMaskId == -1;
	    };
	    /**
	     * Rotates the 3d object around to face a point defined relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	     *
	     * @param    target        The vector defining the point to be looked at
	     * @param    upAxis        An optional vector used to define the desired up orientation of the 3d object after rotation has occurred
	     */
	    DisplayObject.prototype.lookAt = function (target, upAxis) {
	        if (upAxis === void 0) { upAxis = null; }
	        var yAxis;
	        var zAxis;
	        var xAxis;
	        var raw;
	        if (upAxis == null)
	            upAxis = Vector3D_1.default.Y_AXIS;
	        else
	            upAxis.normalize();
	        zAxis = target.subtract(this._transform.position);
	        zAxis.normalize();
	        xAxis = upAxis.crossProduct(zAxis);
	        xAxis.normalize();
	        if (xAxis.length < 0.05) {
	            xAxis.x = upAxis.y;
	            xAxis.y = upAxis.x;
	            xAxis.z = 0;
	            xAxis.normalize();
	        }
	        yAxis = zAxis.crossProduct(xAxis);
	        raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        raw[0] = xAxis.x;
	        raw[1] = xAxis.y;
	        raw[2] = xAxis.z;
	        raw[3] = 0;
	        raw[4] = yAxis.x;
	        raw[5] = yAxis.y;
	        raw[6] = yAxis.z;
	        raw[7] = 0;
	        raw[8] = zAxis.x;
	        raw[9] = zAxis.y;
	        raw[10] = zAxis.z;
	        raw[11] = 0;
	        var m = new Matrix3D_1.default();
	        m.copyRawDataFrom(raw);
	        var vec = m.decompose()[1];
	        this.rotationX = vec.x * MathConsts_1.default.RADIANS_TO_DEGREES;
	        this.rotationY = vec.y * MathConsts_1.default.RADIANS_TO_DEGREES;
	        this.rotationZ = vec.z * MathConsts_1.default.RADIANS_TO_DEGREES;
	    };
	    /**
	     * Converts the <code>point</code> object from the display object's(local)
	     * coordinates to the Scene(global) coordinates.
	     *
	     * <p>This method allows you to convert any given <i>x</i> and <i>y</i>
	     * coordinates from values that are relative to the origin(0,0) of a
	     * specific display object(local coordinates) to values that are relative to
	     * the origin of the Scene(global coordinates).</p>
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
	     * because they relate to the origin of the display object.</p>
	     *
	     * <p>You then pass the Point instance that you created as the parameter to
	     * the <code>localToGlobal()</code> method. The method returns a new Point
	     * object with <i>x</i> and <i>y</i> values that relate to the origin of the
	     * Scene instead of the origin of the display object.</p>
	     *
	     * @param point The name or identifier of a point created with the Point
	     *              class, specifying the <i>x</i> and <i>y</i> coordinates as
	     *              properties.
	     * @return A Point object with coordinates relative to the Scene.
	     */
	    DisplayObject.prototype.localToGlobal = function (point, target) {
	        if (target === void 0) { target = null; }
	        this._tempVector3D.setTo(point.x, point.y, 0);
	        var pos = this.sceneTransform.transformVector(this._tempVector3D, this._tempVector3D);
	        if (!target)
	            target = new Point_1.default();
	        target.x = pos.x;
	        target.y = pos.y;
	        return target;
	    };
	    /**
	     * Converts a three-dimensional point of the three-dimensional display
	     * object's(local) coordinates to a three-dimensional point in the Scene
	     * (global) coordinates.
	     *
	     * <p>This method allows you to convert any given <i>x</i>, <i>y</i> and
	     * <i>z</i> coordinates from values that are relative to the origin(0,0,0) of
	     * a specific display object(local coordinates) to values that are relative to
	     * the origin of the Scene(global coordinates).</p>
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
	     * because they relate to the origin of the display object.</p>
	     *
	     * <p>You then pass the Vector3D instance that you created as the parameter to
	     * the <code>localToGlobal3D()</code> method. The method returns a new
	     * Vector3D object with <i>x</i>, <i>y</i> and <i>z</i> values that relate to
	     * the origin of the Scene instead of the origin of the display object.</p>
	     *
	     * @param position A Vector3D object containing either a three-dimensional
	     *                position or the coordinates of the three-dimensional
	     *                display object.
	     * @return A Vector3D object representing a three-dimensional position in
	     *         the Scene.
	     */
	    DisplayObject.prototype.localToGlobal3D = function (position) {
	        return this.sceneTransform.transformVector(position);
	    };
	    /**
	     * Moves the local point around which the object rotates.
	     *
	     * @param    dx        The amount of movement along the local x axis.
	     * @param    dy        The amount of movement along the local y axis.
	     * @param    dz        The amount of movement along the local z axis.
	     */
	    DisplayObject.prototype.movePivot = function (dx, dy, dz) {
	        if (dx == 0 && dy == 0 && dz == 0)
	            return;
	        this._pivot.x += dx;
	        this._pivot.y += dy;
	        this._pivot.z += dz;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.SCENE_TRANSFORM);
	    };
	    DisplayObject.prototype.reset = function () {
	        this.visible = true;
	        if (this._transform.matrix3D)
	            this._transform.clearMatrix3D();
	        if (this._transform.colorTransform)
	            this._transform.clearColorTransform();
	        //this.name="";
	        this.masks = null;
	        this.maskMode = false;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.getRenderSceneTransform = function (cameraTransform) {
	        if (this.orientationMode == OrientationMode_1.default.CAMERA_PLANE) {
	            var comps = cameraTransform.decompose();
	            var scale = comps[3];
	            comps[0].copyFrom(this.scenePosition);
	            scale.x = this.scaleX;
	            scale.y = this.scaleY;
	            scale.z = this.scaleZ;
	            this._orientationMatrix.recompose(comps);
	            //add in case of pivot
	            if (this._pivot && this.alignmentMode == AlignmentMode_1.default.PIVOT_POINT)
	                this._orientationMatrix.prependTranslation(-this._pivot.x / this.scaleX, -this._pivot.y / this.scaleY, -this._pivot.z / this.scaleZ);
	            return this._orientationMatrix;
	        }
	        return this.sceneTransform;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.removeEventListener = function (type, listener) {
	        _super.prototype.removeEventListener.call(this, type, listener);
	        if (this.hasEventListener(type))
	            return;
	        switch (type) {
	            case DisplayObjectEvent_1.default.SCENE_CHANGED:
	                this._listenToSceneChanged = false;
	                break;
	            case DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED:
	                this._listenToSceneTransformChanged = true;
	                break;
	        }
	    };
	    Object.defineProperty(DisplayObject.prototype, "_iAssignedPartition", {
	        /**
	         * @internal
	         */
	        get: function () {
	            return this._pImplicitPartition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "_iPickingCollision", {
	        /**
	         * @internal
	         */
	        get: function () {
	            if (!this._pickingCollision)
	                this._pickingCollision = new PickingCollision_1.default(this);
	            return this._pickingCollision;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @internal
	     */
	    DisplayObject.prototype.iSetParent = function (value) {
	        this._pParent = value;
	        if (value)
	            this._iSetScene(value._pScene, value._iAssignedPartition);
	        else
	            this._iSetScene(null, null);
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.ALL);
	    };
	    DisplayObject.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
	        var newPropDirty = (this._hierarchicalPropsDirty ^ propDirty) & propDirty;
	        if (!newPropDirty)
	            return true;
	        this._hierarchicalPropsDirty |= propDirty;
	        if (newPropDirty & HierarchicalProperties_1.default.SCENE_TRANSFORM) {
	            this._inverseSceneTransformDirty = true;
	            this._scenePositionDirty = true;
	            if (this.isEntity)
	                this.invalidatePartitionBounds();
	            if (this._pParent)
	                this._pParent._pInvalidateBounds();
	            if (this._listenToSceneTransformChanged)
	                this.queueDispatch(this._sceneTransformChanged || (this._sceneTransformChanged = new DisplayObjectEvent_1.default(DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED, this)));
	        }
	        return false;
	    };
	    /**
	     * @protected
	     */
	    DisplayObject.prototype._iSetScene = function (scene, partition) {
	        var sceneChanged = this._pScene != scene;
	        if (this._pScene && this._pImplicitPartition) {
	            //unregister partition from current scene
	            this._pScene._iUnregisterPartition(this._pImplicitPartition);
	            //unregister entity from current partition
	            this._pImplicitPartition._iUnregisterEntity(this);
	            //gc abstraction objects
	            this.clear();
	        }
	        // assign parent implicit partition if no explicit one is given
	        this._pImplicitPartition = this._explicitPartition || partition;
	        //assign scene
	        if (sceneChanged)
	            this._pScene = scene;
	        if (this._pScene && this._pImplicitPartition) {
	            //register partition with scene
	            this._pScene._iRegisterPartition(this._pImplicitPartition);
	            //register entity with new partition
	            this._pImplicitPartition._iRegisterEntity(this);
	        }
	        if (sceneChanged && this._listenToSceneChanged)
	            this.queueDispatch(this._sceneChanged || (this._sceneChanged = new DisplayObjectEvent_1.default(DisplayObjectEvent_1.default.SCENE_CHANGED, this)));
	    };
	    /**
	     * @protected
	     */
	    DisplayObject.prototype.pUpdateSceneTransform = function () {
	        if (this._iController)
	            this._iController.updateController();
	        this._pSceneTransform.copyFrom(this._transform.matrix3D);
	        if (this._pivot) {
	            if (!this._pivotScale)
	                this._pivotScale = new Vector3D_1.default();
	            this._pivotScale.x = this._pivot.x / this._transform.scale.x;
	            this._pivotScale.y = this._pivot.y / this._transform.scale.y;
	            this._pivotScale.z = this._pivot.z / this._transform.scale.z;
	            this._pSceneTransform.prependTranslation(-this._pivotScale.x, -this._pivotScale.y, -this._pivotScale.z);
	            if (this.alignmentMode != AlignmentMode_1.default.PIVOT_POINT)
	                this._pSceneTransform.appendTranslation(this._pivot.x, this._pivot.y, this._pivot.z);
	        }
	        if (this._pParent && !this._pParent._iIsRoot)
	            this._pSceneTransform.append(this._pParent.sceneTransform);
	        this._matrix3DDirty = false;
	        this._positionDirty = false;
	        this._rotationDirty = false;
	        this._skewDirty = false;
	        this._scaleDirty = false;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.SCENE_TRANSFORM;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype._iInternalUpdate = function () {
	        if (this._iController)
	            this._iController.update();
	        // Dispatch all queued events.
	        var len = this._queuedEvents.length;
	        for (var i = 0; i < len; ++i)
	            this.dispatchEvent(this._queuedEvents[i]);
	        this._queuedEvents.length = 0;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iIsVisible = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.VISIBLE)
	            this._updateVisible();
	        return this._pImplicitVisibility;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iAssignedMaskId = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.MASK_ID)
	            this._updateMaskId();
	        return this._pImplicitMaskId;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iAssignedMasks = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.MASKS)
	            this._updateMasks();
	        return this._pImplicitMasks;
	    };
	    DisplayObject.prototype._iMasksConfig = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.MASKS)
	            this._updateMasks();
	        return this._pImplicitMaskIds;
	    };
	    DisplayObject.prototype._iAssignedColorTransform = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.COLOR_TRANSFORM)
	            this._updateColorTransform();
	        return this._pImplicitColorTransform;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iIsMouseEnabled = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.MOUSE_ENABLED)
	            this._updateMouseEnabled();
	        return this._pImplicitMouseEnabled && this._explicitMouseEnabled;
	    };
	    DisplayObject.prototype._acceptTraverser = function (collector) {
	        //nothing to do here
	    };
	    /**
	     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
	     *
	     * @private
	     */
	    DisplayObject.prototype._onInvalidateMatrix3D = function (event) {
	        if (this._matrix3DDirty)
	            return;
	        this._matrix3DDirty = true;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.SCENE_TRANSFORM);
	    };
	    /**
	     * @private
	     */
	    DisplayObject.prototype._onInvalidateColorTransform = function (event) {
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.COLOR_TRANSFORM);
	    };
	    DisplayObject.prototype._pInvalidateBounds = function () {
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        if (this.isEntity)
	            this.invalidatePartitionBounds();
	        if (this._pParent)
	            this._pParent._pInvalidateBounds();
	    };
	    DisplayObject.prototype._pUpdateBoxBounds = function () {
	        this._boxBoundsInvalid = false;
	        if (this._pBoxBounds == null)
	            this._pBoxBounds = new Box_1.default();
	    };
	    DisplayObject.prototype._pUpdateSphereBounds = function () {
	        this._sphereBoundsInvalid = false;
	        if (this._pSphereBounds == null)
	            this._pSphereBounds = new Sphere_1.default();
	    };
	    DisplayObject.prototype.queueDispatch = function (event) {
	        // Store event to be dispatched later.
	        this._queuedEvents.push(event);
	    };
	    DisplayObject.prototype._setScaleX = function (val) {
	        if (this.scaleX == val)
	            return;
	        this._transform.scale.x = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._setScaleY = function (val) {
	        if (this.scaleY == val)
	            return;
	        this._transform.scale.y = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._setScaleZ = function (val) {
	        if (this.scaleZ == val)
	            return;
	        this._transform.scale.z = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._updateMouseEnabled = function () {
	        this._pImplicitMouseEnabled = (this._pParent) ? this._pParent.mouseChildren && this._pParent._pImplicitMouseEnabled : true;
	        // If there is a parent and this child does not have a picking collider, use its parent's picking collider.
	        if (this._pImplicitMouseEnabled && this._pParent && !this.pickingCollider)
	            this.pickingCollider = this._pParent.pickingCollider;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.MOUSE_ENABLED;
	    };
	    DisplayObject.prototype._updateVisible = function () {
	        this._pImplicitVisibility = (this._pParent) ? this._explicitVisibility && this._pParent._iIsVisible() : this._explicitVisibility;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.VISIBLE;
	    };
	    DisplayObject.prototype._updateMaskId = function () {
	        this._pImplicitMaskId = (this._pParent && this._pParent._iAssignedMaskId() != -1) ? this._pParent._iAssignedMaskId() : this._explicitMaskId;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.MASK_ID;
	    };
	    DisplayObject.prototype._updateMasks = function () {
	        this._pImplicitMasks = (this._pParent && this._pParent._iAssignedMasks()) ? (this._explicitMasks != null) ? this._pParent._iAssignedMasks().concat([this._explicitMasks]) : this._pParent._iAssignedMasks().concat() : (this._explicitMasks != null) ? [this._explicitMasks] : null;
	        this._pImplicitMaskIds.length = 0;
	        if (this._pImplicitMasks && this._pImplicitMasks.length) {
	            var numLayers = this._pImplicitMasks.length;
	            var numChildren;
	            var implicitChildren;
	            var implicitChildIds;
	            for (var i = 0; i < numLayers; i++) {
	                implicitChildren = this._pImplicitMasks[i];
	                numChildren = implicitChildren.length;
	                implicitChildIds = new Array();
	                for (var j = 0; j < numChildren; j++)
	                    implicitChildIds.push(implicitChildren[j].id);
	                this._pImplicitMaskIds.push(implicitChildIds);
	            }
	        }
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.MASKS;
	    };
	    DisplayObject.prototype._updateColorTransform = function () {
	        if (!this._pImplicitColorTransform)
	            this._pImplicitColorTransform = new ColorTransform_1.default();
	        if (this._inheritColorTransform && this._pParent && this._pParent._iAssignedColorTransform()) {
	            this._pImplicitColorTransform.copyFrom(this._pParent._iAssignedColorTransform());
	            if (this._transform.colorTransform)
	                this._pImplicitColorTransform.prepend(this._transform.colorTransform);
	        }
	        else {
	            if (this._transform.colorTransform)
	                this._pImplicitColorTransform.copyFrom(this._transform.colorTransform);
	            else
	                this._pImplicitColorTransform.clear();
	        }
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.default.COLOR_TRANSFORM;
	    };
	    DisplayObject.prototype._updateMaskMode = function () {
	        if (this.maskMode)
	            this.mouseEnabled = false;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.MASK_ID);
	    };
	    DisplayObject.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        var i;
	        this._pImplicitColorTransform = null;
	        this._pImplicitMasks = null;
	    };
	    DisplayObject.prototype.invalidatePartitionBounds = function () {
	        this.dispatchEvent(new DisplayObjectEvent_1.default(DisplayObjectEvent_1.default.INVALIDATE_PARTITION_BOUNDS, this));
	    };
	    DisplayObject.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        return false;
	    };
	    return DisplayObject;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DisplayObject;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorUtils_1 = __webpack_require__(47);
	/**
	 * The ColorTransform class lets you adjust the color values in a display
	 * object. The color adjustment or <i>color transformation</i> can be applied
	 * to all four channels: red, green, blue, and alpha transparency.
	 *
	 * <p>When a ColorTransform object is applied to a display object, a new value
	 * for each color channel is calculated like this:</p>
	 *
	 * <ul>
	 *   <li>New red value = (old red value * <code>redMultiplier</code>) +
	 * <code>redOffset</code></li>
	 *   <li>New green value = (old green value * <code>greenMultiplier</code>) +
	 * <code>greenOffset</code></li>
	 *   <li>New blue value = (old blue value * <code>blueMultiplier</code>) +
	 * <code>blueOffset</code></li>
	 *   <li>New alpha value = (old alpha value * <code>alphaMultiplier</code>) +
	 * <code>alphaOffset</code></li>
	 * </ul>
	 *
	 * <p>If any of the color channel values is greater than 255 after the
	 * calculation, it is set to 255. If it is less than 0, it is set to 0.</p>
	 *
	 * <p>You can use ColorTransform objects in the following ways:</p>
	 *
	 * <ul>
	 *   <li>In the <code>colorTransform</code> parameter of the
	 * <code>colorTransform()</code> method of the BitmapData class</li>
	 *   <li>As the <code>colorTransform</code> property of a Transform object
	 * (which can be used as the <code>transform</code> property of a display
	 * object)</li>
	 * </ul>
	 *
	 * <p>You must use the <code>new ColorTransform()</code> constructor to create
	 * a ColorTransform object before you can call the methods of the
	 * ColorTransform object.</p>
	 *
	 * <p>Color transformations do not apply to the background color of a movie
	 * clip(such as a loaded SWF object). They apply only to graphics and symbols
	 * that are attached to the movie clip.</p>
	 */
	var ColorTransform = (function () {
	    /**
	     * Creates a ColorTransform object for a display object with the specified
	     * color channel values and alpha values.
	     *
	     * @param redMultiplier   The value for the red multiplier, in the range from
	     *                        0 to 1.
	     * @param greenMultiplier The value for the green multiplier, in the range
	     *                        from 0 to 1.
	     * @param blueMultiplier  The value for the blue multiplier, in the range
	     *                        from 0 to 1.
	     * @param alphaMultiplier The value for the alpha transparency multiplier, in
	     *                        the range from 0 to 1.
	     * @param redOffset       The offset value for the red color channel, in the
	     *                        range from -255 to 255.
	     * @param greenOffset     The offset value for the green color channel, in
	     *                        the range from -255 to 255.
	     * @param blueOffset      The offset for the blue color channel value, in the
	     *                        range from -255 to 255.
	     * @param alphaOffset     The offset for alpha transparency channel value, in
	     *                        the range from -255 to 255.
	     */
	    function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
	        if (redMultiplier === void 0) { redMultiplier = 1; }
	        if (greenMultiplier === void 0) { greenMultiplier = 1; }
	        if (blueMultiplier === void 0) { blueMultiplier = 1; }
	        if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
	        if (redOffset === void 0) { redOffset = 0; }
	        if (greenOffset === void 0) { greenOffset = 0; }
	        if (blueOffset === void 0) { blueOffset = 0; }
	        if (alphaOffset === void 0) { alphaOffset = 0; }
	        this.redMultiplier = redMultiplier;
	        this.greenMultiplier = greenMultiplier;
	        this.blueMultiplier = blueMultiplier;
	        this.alphaMultiplier = alphaMultiplier;
	        this.redOffset = redOffset;
	        this.greenOffset = greenOffset;
	        this.blueOffset = blueOffset;
	        this.alphaOffset = alphaOffset;
	    }
	    Object.defineProperty(ColorTransform.prototype, "color", {
	        /**
	         * The RGB color value for a ColorTransform object.
	         *
	         * <p>When you set this property, it changes the three color offset values
	         * (<code>redOffset</code>, <code>greenOffset</code>, and
	         * <code>blueOffset</code>) accordingly, and it sets the three color
	         * multiplier values(<code>redMultiplier</code>,
	         * <code>greenMultiplier</code>, and <code>blueMultiplier</code>) to 0. The
	         * alpha transparency multiplier and offset values do not change.</p>
	         *
	         * <p>When you pass a value for this property, use the format
	         * 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist of two
	         * hexadecimal digits that specify the offset of each color component. The 0x
	         * tells the ActionScript compiler that the number is a hexadecimal
	         * value.</p>
	         */
	        get: function () {
	            return ((this.redOffset << 16) | (this.greenOffset << 8) | this.blueOffset);
	        },
	        set: function (value) {
	            var argb = ColorUtils_1.default.float32ColorToARGB(value);
	            this.redOffset = argb[1]; //(value >> 16) & 0xFF;
	            this.greenOffset = argb[2]; //(value >> 8) & 0xFF;
	            this.blueOffset = argb[3]; //value & 0xFF;
	            this.redMultiplier = 0;
	            this.greenMultiplier = 0;
	            this.blueMultiplier = 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ColorTransform.prototype.clear = function () {
	        this.redMultiplier = 1;
	        this.greenMultiplier = 1;
	        this.blueMultiplier = 1;
	        this.alphaMultiplier = 1;
	        this.redOffset = 0;
	        this.greenOffset = 0;
	        this.blueOffset = 0;
	        this.alphaOffset = 0;
	    };
	    ColorTransform.prototype.clone = function () {
	        return new ColorTransform(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
	    };
	    ColorTransform.prototype.copyFrom = function (source) {
	        this.redMultiplier = source.redMultiplier;
	        this.greenMultiplier = source.greenMultiplier;
	        this.blueMultiplier = source.blueMultiplier;
	        this.alphaMultiplier = source.alphaMultiplier;
	        this.redOffset = source.redOffset;
	        this.greenOffset = source.greenOffset;
	        this.blueOffset = source.blueOffset;
	        this.alphaOffset = source.alphaOffset;
	    };
	    ColorTransform.prototype.copyTo = function (destination) {
	        destination.copyFrom(this);
	    };
	    ColorTransform.prototype.prepend = function (ct) {
	        this.redOffset += ct.redOffset * this.redMultiplier;
	        this.greenOffset += ct.greenOffset * this.greenMultiplier;
	        this.blueOffset += ct.blueOffset * this.blueMultiplier;
	        this.alphaOffset += ct.alphaOffset * this.alphaMultiplier;
	        this.redMultiplier *= ct.redMultiplier;
	        this.greenMultiplier *= ct.greenMultiplier;
	        this.blueMultiplier *= ct.blueMultiplier;
	        this.alphaMultiplier *= ct.alphaMultiplier;
	    };
	    return ColorTransform;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ColorTransform;


/***/ },
/* 47 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var ColorUtils = (function () {
	    function ColorUtils() {
	    }
	    ColorUtils.float32ColorToARGB = function (float32Color) {
	        var a = (float32Color & 0xff000000) >>> 24;
	        var r = (float32Color & 0xff0000) >>> 16;
	        var g = (float32Color & 0xff00) >>> 8;
	        var b = float32Color & 0xff;
	        var result = [a, r, g, b];
	        return result;
	    };
	    ColorUtils.ARGBtoFloat32 = function (a, r, g, b) {
	        return ((a << 24) | (r << 16) | (g << 8) | b);
	    };
	    ColorUtils.componentToHex = function (c) {
	        var hex = c.toString(16);
	        return hex.length == 1 ? "0" + hex : hex;
	    };
	    ColorUtils.RGBToHexString = function (argb) {
	        return "#" + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
	    };
	    ColorUtils.ARGBToHexString = function (argb) {
	        return "#" + ColorUtils.componentToHex(argb[0]) + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
	    };
	    return ColorUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ColorUtils;


/***/ },
/* 48 */
/***/ function(module, exports) {

	"use strict";
	var Sphere = (function () {
	    /**
	     * Create a Sphere with ABCD coefficients
	     */
	    function Sphere(x, y, z, radius) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (radius === void 0) { radius = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.radius = radius;
	    }
	    Sphere.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this.containsPoint(position))
	            return 0;
	        var px = position.x - this.x, py = position.y - this.y, pz = position.z - this.z;
	        var vx = direction.x, vy = direction.y, vz = direction.z;
	        var rayEntryDistance;
	        var a = vx * vx + vy * vy + vz * vz;
	        var b = 2 * (px * vx + py * vy + pz * vz);
	        var c = px * px + py * py + pz * pz - this.radius * this.radius;
	        var det = b * b - 4 * a * c;
	        if (det >= 0) {
	            var sqrtDet = Math.sqrt(det);
	            rayEntryDistance = (-b - sqrtDet) / (2 * a);
	            if (rayEntryDistance >= 0) {
	                targetNormal.x = px + rayEntryDistance * vx;
	                targetNormal.y = py + rayEntryDistance * vy;
	                targetNormal.z = pz + rayEntryDistance * vz;
	                targetNormal.normalize();
	                return rayEntryDistance;
	            }
	        }
	        // ray misses sphere
	        return -1;
	    };
	    Sphere.prototype.containsPoint = function (position) {
	        var px = position.x - this.x;
	        var py = position.y - this.y;
	        var pz = position.z - this.z;
	        var distance = Math.sqrt(px * px + py * py + pz * pz);
	        return distance <= this.radius;
	    };
	    Sphere.prototype.toString = function () {
	        return "Sphere [x:" + this.x + ", y:" + this.y + ", z:" + this.z + ", radius:" + this.radius + "]";
	    };
	    return Sphere;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Sphere;


/***/ },
/* 49 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var HierarchicalProperties = (function () {
	    function HierarchicalProperties() {
	    }
	    /**
	     *
	     */
	    HierarchicalProperties.MOUSE_ENABLED = 1;
	    /**
	     *
	     */
	    HierarchicalProperties.VISIBLE = 2;
	    /**
	     *
	     */
	    HierarchicalProperties.MASK_ID = 4;
	    /**
	     *
	     */
	    HierarchicalProperties.MASKS = 8;
	    /**
	     *
	     */
	    HierarchicalProperties.COLOR_TRANSFORM = 16;
	    /**
	     *
	     */
	    HierarchicalProperties.SCENE_TRANSFORM = 32;
	    /**
	     *
	     */
	    HierarchicalProperties.ALL = 63;
	    return HierarchicalProperties;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = HierarchicalProperties;


/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var BoundsType = (function () {
	    function BoundsType() {
	    }
	    /**
	     *
	     */
	    BoundsType.SPHERE = "sphere";
	    /**
	     *
	     */
	    BoundsType.AXIS_ALIGNED_BOX = "axisAlignedBox";
	    /**
	     *
	     */
	    BoundsType.NULL = "null";
	    return BoundsType;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BoundsType;


/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var AlignmentMode = (function () {
	    function AlignmentMode() {
	    }
	    /**
	     *
	     */
	    AlignmentMode.REGISTRATION_POINT = "registrationPoint";
	    /**
	     *
	     */
	    AlignmentMode.PIVOT_POINT = "pivot";
	    return AlignmentMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AlignmentMode;


/***/ },
/* 52 */
/***/ function(module, exports) {

	"use strict";
	var OrientationMode = (function () {
	    function OrientationMode() {
	    }
	    /**
	     *
	     */
	    OrientationMode.DEFAULT = "default";
	    /**
	     *
	     */
	    OrientationMode.CAMERA_PLANE = "cameraPlane";
	    /**
	     *
	     */
	    OrientationMode.CAMERA_POSITION = "cameraPosition";
	    return OrientationMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OrientationMode;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(12);
	var Matrix3D_1 = __webpack_require__(28);
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Vector3D_1 = __webpack_require__(30);
	var TransformEvent_1 = __webpack_require__(54);
	/**
	 * The Transform class provides access to color adjustment properties and two-
	 * or three-dimensional transformation objects that can be applied to a
	 * display object. During the transformation, the color or the orientation and
	 * position of a display object is adjusted(offset) from the current values
	 * or coordinates to new values or coordinates. The Transform class also
	 * collects data about color and two-dimensional matrix transformations that
	 * are applied to a display object and all of its parent objects. You can
	 * access these combined transformations through the
	 * <code>concatenatedColorTransform</code> and <code>concatenatedMatrix</code>
	 * properties.
	 *
	 * <p>To apply color transformations: create a ColorTransform object, set the
	 * color adjustments using the object's methods and properties, and then
	 * assign the <code>colorTransformation</code> property of the
	 * <code>transform</code> property of the display object to the new
	 * ColorTransformation object.</p>
	 *
	 * <p>To apply two-dimensional transformations: create a Matrix object, set
	 * the matrix's two-dimensional transformation, and then assign the
	 * <code>transform.matrix</code> property of the display object to the new
	 * Matrix object.</p>
	 *
	 * <p>To apply three-dimensional transformations: start with a
	 * three-dimensional display object. A three-dimensional display object has a
	 * <code>z</code> property value other than zero. You do not need to create
	 * the Matrix3D object. For all three-dimensional objects, a Matrix3D object
	 * is created automatically when you assign a <code>z</code> value to a
	 * display object. You can access the display object's Matrix3D object through
	 * the display object's <code>transform</code> property. Using the methods of
	 * the Matrix3D class, you can add to or modify the existing transformation
	 * settings. Also, you can create a custom Matrix3D object, set the custom
	 * Matrix3D object's transformation elements, and then assign the new Matrix3D
	 * object to the display object using the <code>transform.matrix</code>
	 * property.</p>
	 *
	 * <p>To modify a perspective projection of the stage or root object: use the
	 * <code>transform.matrix</code> property of the root display object to gain
	 * access to the PerspectiveProjection object. Or, apply different perspective
	 * projection properties to a display object by setting the perspective
	 * projection properties of the display object's parent. The child display
	 * object inherits the new properties. Specifically, create a
	 * PerspectiveProjection object and set its properties, then assign the
	 * PerspectiveProjection object to the <code>perspectiveProjection</code>
	 * property of the parent display object's <code>transform</code> property.
	 * The specified projection transformation then applies to all the display
	 * object's three-dimensional children.</p>
	 *
	 * <p>Since both PerspectiveProjection and Matrix3D objects perform
	 * perspective transformations, do not assign both to a display object at the
	 * same time. Use the PerspectiveProjection object for focal length and
	 * projection center changes. For more control over the perspective
	 * transformation, create a perspective projection Matrix3D object.</p>
	 */
	var Transform = (function (_super) {
	    __extends(Transform, _super);
	    function Transform() {
	        _super.call(this);
	        this._matrix3D = new Matrix3D_1.default();
	        this._rotation = new Vector3D_1.default();
	        this._skew = new Vector3D_1.default();
	        this._scale = new Vector3D_1.default(1, 1, 1);
	        // Cached vector of transformation components used when
	        // recomposing the transform matrix in updateTransform()
	        this._components = new Array(4);
	        this._components[1] = this._rotation;
	        this._components[2] = this._skew;
	        this._components[3] = this._scale;
	    }
	    Object.defineProperty(Transform.prototype, "backVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.default.getForward(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "colorTransform", {
	        /**
	         * A ColorTransform object containing values that universally adjust the
	         * colors in the display object.
	         *
	         * @throws TypeError The colorTransform is null when being set
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (val) {
	            if (this._colorTransform == val)
	                return;
	            this._colorTransform = val;
	            this.invalidateColorTransform();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "concatenatedColorTransform", {
	        /**
	         * A ColorTransform object representing the combined color transformations
	         * applied to the display object and all of its parent objects, back to the
	         * root level. If different color transformations have been applied at
	         * different levels, all of those transformations are concatenated into one
	         * ColorTransform object for this property.
	         */
	        get: function () {
	            return this._concatenatedColorTransform; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "concatenatedMatrix", {
	        /**
	         * A Matrix object representing the combined transformation matrixes of the
	         * display object and all of its parent objects, back to the root level. If
	         * different transformation matrixes have been applied at different levels,
	         * all of those matrixes are concatenated into one matrix for this property.
	         * Also, for resizeable SWF content running in the browser, this property
	         * factors in the difference between stage coordinates and window coordinates
	         * due to window resizing. Thus, the property converts local coordinates to
	         * window coordinates, which may not be the same coordinate space as that of
	         * the Scene.
	         */
	        get: function () {
	            return this._concatenatedMatrix; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "downVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.default.getUp(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "forwardVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.default.getForward(this._matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "leftVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.default.getRight(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "matrix3D", {
	        /**
	         * Provides access to the Matrix3D object of a three-dimensional display
	         * object. The Matrix3D object represents a transformation matrix that
	         * determines the display object's position and orientation. A Matrix3D
	         * object can also perform perspective projection.
	         *
	         * <p>If the <code>matrix</code> property is set to a value(not
	         * <code>null</code>), the <code>matrix3D</code> property is
	         * <code>null</code>. And if the <code>matrix3D</code> property is set to a
	         * value(not <code>null</code>), the <code>matrix</code> property is
	         * <code>null</code>.</p>
	         */
	        get: function () {
	            if (this._matrix3DDirty)
	                this._updateMatrix3D();
	            return this._matrix3D;
	        },
	        set: function (val) {
	            for (var i = 0; i < 15; i++)
	                this._matrix3D.rawData[i] = val.rawData[i];
	            this.invalidateComponents();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "pixelBounds", {
	        /**
	         * A Rectangle object that defines the bounding rectangle of the display
	         * object on the stage.
	         */
	        get: function () {
	            return this._pixelBounds;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "position", {
	        /**
	         * Defines the position of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            return this._matrix3D.position;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "rightVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.default.getRight(this.matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "rotation", {
	        /**
	         * Defines the rotation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._rotation;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Rotates the 3d object directly to a euler angle
	     *
	     * @param    ax        The angle in degrees of the rotation around the x axis.
	     * @param    ay        The angle in degrees of the rotation around the y axis.
	     * @param    az        The angle in degrees of the rotation around the z axis.
	     */
	    Transform.prototype.rotateTo = function (ax, ay, az) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._rotation.x = ax;
	        this._rotation.y = ay;
	        this._rotation.z = az;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "scale", {
	        /**
	         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._scale;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.scaleTo = function (sx, sy, sz) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._scale.x = sx;
	        this._scale.y = sy;
	        this._scale.z = sz;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "skew", {
	        /**
	         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._skew;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.skewTo = function (sx, sy, sz) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._skew.x = sx;
	        this._skew.y = sy;
	        this._skew.z = sz;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "upVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.default.getUp(this.matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.dispose = function () {
	    };
	    /**
	     * Returns a Matrix3D object, which can transform the space of a specified
	     * display object in relation to the current display object's space. You can
	     * use the <code>getRelativeMatrix3D()</code> method to move one
	     * three-dimensional display object relative to another three-dimensional
	     * display object.
	     *
	     * @param relativeTo The display object relative to which the transformation
	     *                   occurs. To get a Matrix3D object relative to the stage,
	     *                   set the parameter to the <code>root</code> or
	     *                   <code>stage</code> object. To get the world-relative
	     *                   matrix of the display object, set the parameter to a
	     *                   display object that has a perspective transformation
	     *                   applied to it.
	     * @return A Matrix3D object that can be used to transform the space from the
	     *         <code>relativeTo</code> display object to the current display
	     *         object space.
	     */
	    Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
	        return new Matrix3D_1.default(); //TODO
	    };
	    /**
	     * Moves the 3d object forwards along it's local z axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveForward = function (distance) {
	        this.translateLocal(Vector3D_1.default.Z_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local z axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveBackward = function (distance) {
	        this.translateLocal(Vector3D_1.default.Z_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local x axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveLeft = function (distance) {
	        this.translateLocal(Vector3D_1.default.X_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object forwards along it's local x axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveRight = function (distance) {
	        this.translateLocal(Vector3D_1.default.X_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object forwards along it's local y axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveUp = function (distance) {
	        this.translateLocal(Vector3D_1.default.Y_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local y axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveDown = function (distance) {
	        this.translateLocal(Vector3D_1.default.Y_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object directly to a point in space
	     *
	     * @param    dx        The amount of movement along the local x axis.
	     * @param    dy        The amount of movement along the local y axis.
	     * @param    dz        The amount of movement along the local z axis.
	     */
	    Transform.prototype.moveTo = function (dx, dy, dz) {
	        this._matrix3D.rawData[12] = dx;
	        this._matrix3D.rawData[13] = dy;
	        this._matrix3D.rawData[14] = dz;
	        this.invalidatePosition();
	    };
	    /**
	     * Rotates the 3d object around it's local x-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.pitch = function (angle) {
	        this.rotate(Vector3D_1.default.X_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around it's local z-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.roll = function (angle) {
	        this.rotate(Vector3D_1.default.Z_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around it's local y-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.yaw = function (angle) {
	        this.rotate(Vector3D_1.default.Y_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around an axis by a defined angle
	     *
	     * @param    axis        The vector defining the axis of rotation
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.rotate = function (axis, angle) {
	        this.matrix3D.prependRotation(angle, axis);
	        this.invalidateComponents();
	    };
	    /**
	     * Moves the 3d object along a vector by a defined length
	     *
	     * @param    axis        The vector defining the axis of movement
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.translate = function (axis, distance) {
	        var x = axis.x, y = axis.y, z = axis.z;
	        var len = distance / Math.sqrt(x * x + y * y + z * z);
	        this.matrix3D.appendTranslation(x * len, y * len, z * len);
	        this.invalidatePosition();
	    };
	    /**
	     * Moves the 3d object along a vector by a defined length
	     *
	     * @param    axis        The vector defining the axis of movement
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.translateLocal = function (axis, distance) {
	        var x = axis.x, y = axis.y, z = axis.z;
	        var len = distance / Math.sqrt(x * x + y * y + z * z);
	        this.matrix3D.prependTranslation(x * len, y * len, z * len);
	        this.invalidatePosition();
	    };
	    Transform.prototype.clearMatrix3D = function () {
	        this._matrix3D.identity();
	        this.invalidateComponents();
	    };
	    Transform.prototype.clearColorTransform = function () {
	        if (!this._colorTransform)
	            return;
	        this._colorTransform.clear();
	        this.invalidateColorTransform();
	    };
	    /**
	     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
	     *
	     * @private
	     */
	    Transform.prototype.invalidateMatrix3D = function () {
	        this._matrix3DDirty = true;
	        this.dispatchEvent(new TransformEvent_1.default(TransformEvent_1.default.INVALIDATE_MATRIX3D, this));
	    };
	    Transform.prototype.invalidateComponents = function () {
	        this.invalidatePosition();
	        this._componentsDirty = true;
	    };
	    /**
	     *
	     */
	    Transform.prototype.invalidatePosition = function () {
	        this._matrix3D.invalidatePosition();
	        this.dispatchEvent(new TransformEvent_1.default(TransformEvent_1.default.INVALIDATE_MATRIX3D, this));
	    };
	    Transform.prototype.invalidateColorTransform = function () {
	        this.dispatchEvent(new TransformEvent_1.default(TransformEvent_1.default.INVALIDATE_COLOR_TRANSFORM, this));
	    };
	    /**
	     *
	     */
	    Transform.prototype._updateMatrix3D = function () {
	        this._matrix3D.recompose(this._components);
	        this._matrix3DDirty = false;
	    };
	    Transform.prototype._updateComponents = function () {
	        var elements = this._matrix3D.decompose();
	        var vec;
	        vec = elements[1];
	        this._rotation.x = vec.x;
	        this._rotation.y = vec.y;
	        this._rotation.z = vec.z;
	        vec = elements[2];
	        this._skew.x = vec.x;
	        this._skew.y = vec.y;
	        this._skew.z = vec.z;
	        vec = elements[3];
	        this._scale.x = vec.x;
	        this._scale.y = vec.y;
	        this._scale.z = vec.z;
	        this._componentsDirty = false;
	    };
	    return Transform;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Transform;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var TransformEvent = (function (_super) {
	    __extends(TransformEvent, _super);
	    function TransformEvent(type, transform) {
	        _super.call(this, type);
	        this._transform = transform;
	    }
	    Object.defineProperty(TransformEvent.prototype, "transform", {
	        get: function () {
	            return this._transform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    TransformEvent.prototype.clone = function () {
	        return new TransformEvent(this.type, this._transform);
	    };
	    /**
	     *
	     */
	    TransformEvent.INVALIDATE_MATRIX3D = "invalidateMatrix3D";
	    /**
	     *
	     */
	    TransformEvent.INVALIDATE_COLOR_TRANSFORM = "invalidateColorTransform";
	    return TransformEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TransformEvent;


/***/ },
/* 55 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Value object for a picking collision returned by a picking collider. Created as unique objects on display objects
	 *
	 * @see away.base.DisplayObject#pickingCollision
	 * @see away.core.pick.IPickingCollider
	 *
	 * @class away.pick.PickingCollision
	 */
	var PickingCollision = (function () {
	    /**
	     * Creates a new <code>PickingCollision</code> object.
	     *
	     * @param entity The entity to which this collision object belongs.
	     */
	    function PickingCollision(entity) {
	        this.entity = entity;
	    }
	    return PickingCollision;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PickingCollision;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var DisplayObjectEvent = (function (_super) {
	    __extends(DisplayObjectEvent, _super);
	    function DisplayObjectEvent(type, object) {
	        _super.call(this, type);
	        this._object = object;
	    }
	    Object.defineProperty(DisplayObjectEvent.prototype, "object", {
	        get: function () {
	            return this._object;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    DisplayObjectEvent.prototype.clone = function () {
	        return new DisplayObjectEvent(this.type, this._object);
	    };
	    /**
	     *
	     */
	    DisplayObjectEvent.VISIBLITY_UPDATED = "visiblityUpdated";
	    /**
	     *
	     */
	    DisplayObjectEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.SCENE_CHANGED = "sceneChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.PARTITION_CHANGED = "partitionChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS = "invalidatePartitionBounds";
	    return DisplayObjectEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DisplayObjectEvent;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NodeBase_1 = __webpack_require__(58);
	var PartitionBase_1 = __webpack_require__(62);
	/**
	 * @class away.partition.Partition
	 */
	var BasicPartition = (function (_super) {
	    __extends(BasicPartition, _super);
	    function BasicPartition() {
	        _super.call(this);
	        this._rootNode = new NodeBase_1.default();
	    }
	    return BasicPartition;
	}(PartitionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BasicPartition;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NullBounds_1 = __webpack_require__(59);
	/**
	 * @class away.partition.NodeBase
	 */
	var NodeBase = (function () {
	    /**
	     *
	     */
	    function NodeBase() {
	        this._bounds = new NullBounds_1.default();
	        this._pChildNodes = new Array();
	        this._pNumChildNodes = 0;
	        this.numEntities = 0;
	    }
	    Object.defineProperty(NodeBase.prototype, "debugVisible", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NodeBase.prototype, "bounds", {
	        /**
	         * @internal
	         */
	        get: function () {
	            return this._bounds; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param planes
	     * @param numPlanes
	     * @returns {boolean}
	     * @internal
	     */
	    NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
	        return true;
	    };
	    /**
	     *
	     * @param rayPosition
	     * @param rayDirection
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isCastingShadow = function () {
	        return true;
	    };
	    NodeBase.prototype.dispose = function () {
	        this.parent = null;
	        this._pChildNodes = null;
	    };
	    /**
	     *
	     * @param traverser
	     */
	    NodeBase.prototype.acceptTraverser = function (traverser) {
	        if (this.numEntities == 0)
	            return;
	        if (traverser.enterNode(this)) {
	            for (var i = 0; i < this._pNumChildNodes; i++)
	                this._pChildNodes[i].acceptTraverser(traverser);
	        }
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    NodeBase.prototype.iAddNode = function (node) {
	        node.parent = this;
	        this.numEntities += node.numEntities;
	        this._pChildNodes[this._pNumChildNodes++] = node;
	        var numEntities = node.numEntities;
	        node = this;
	        do {
	            node.numEntities += numEntities;
	        } while ((node = node.parent) != null);
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    NodeBase.prototype.iRemoveNode = function (node) {
	        var index = this._pChildNodes.indexOf(node);
	        this._pChildNodes[index] = this._pChildNodes[--this._pNumChildNodes];
	        this._pChildNodes.pop();
	        var numEntities = node.numEntities;
	        node = this;
	        do {
	            node.numEntities -= numEntities;
	        } while ((node = node.parent) != null);
	    };
	    return NodeBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = NodeBase;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PlaneClassification_1 = __webpack_require__(60);
	var BoundingVolumeBase_1 = __webpack_require__(61);
	var NullBounds = (function (_super) {
	    __extends(NullBounds, _super);
	    function NullBounds(alwaysIn) {
	        if (alwaysIn === void 0) { alwaysIn = true; }
	        _super.call(this, null);
	        this._alwaysIn = alwaysIn;
	    }
	    //@override
	    NullBounds.prototype.clone = function () {
	        return new NullBounds(this._alwaysIn);
	    };
	    //@override
	    NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
	        return this._alwaysIn;
	    };
	    NullBounds.prototype.classifyToPlane = function (plane) {
	        return PlaneClassification_1.default.INTERSECT;
	    };
	    return NullBounds;
	}(BoundingVolumeBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = NullBounds;


/***/ },
/* 60 */
/***/ function(module, exports) {

	"use strict";
	var PlaneClassification = (function () {
	    function PlaneClassification() {
	    }
	    // "back" is synonymous with "in", but used for planes (back of plane is "inside" a solid volume walled by a plane)
	    PlaneClassification.BACK = 0;
	    PlaneClassification.FRONT = 1;
	    PlaneClassification.IN = 0;
	    PlaneClassification.OUT = 1;
	    PlaneClassification.INTERSECT = 2;
	    return PlaneClassification;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PlaneClassification;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(20);
	var BoundingVolumeBase = (function () {
	    function BoundingVolumeBase(entity) {
	        this._pInvalidated = true;
	        this._pEntity = entity;
	    }
	    BoundingVolumeBase.prototype.dispose = function () {
	        this._pEntity = null;
	        this._pBoundsPrimitive = null;
	    };
	    Object.defineProperty(BoundingVolumeBase.prototype, "boundsPrimitive", {
	        get: function () {
	            if (this._pBoundsPrimitive == null) {
	                this._pBoundsPrimitive = this._pCreateBoundsPrimitive();
	                this._pInvalidated = true;
	            }
	            if (this._pInvalidated)
	                this._pUpdate();
	            return this._pBoundsPrimitive;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BoundingVolumeBase.prototype.nullify = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
	        throw new AbstractMethodError_1.default();
	    };
	    BoundingVolumeBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    BoundingVolumeBase.prototype.rayIntersection = function (position, direction, targetNormal) {
	        return -1;
	    };
	    BoundingVolumeBase.prototype.classifyToPlane = function (plane) {
	        throw new AbstractMethodError_1.default();
	    };
	    BoundingVolumeBase.prototype._pUpdate = function () {
	        this._pInvalidated = false;
	    };
	    BoundingVolumeBase.prototype.invalidate = function () {
	        this._pInvalidated = true;
	    };
	    BoundingVolumeBase.prototype._pCreateBoundsPrimitive = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    return BoundingVolumeBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BoundingVolumeBase;


/***/ },
/* 62 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.partition.Partition
	 */
	var PartitionBase = (function () {
	    function PartitionBase() {
	        this._abstractionPool = new Object();
	        this._updatesMade = false;
	    }
	    PartitionBase.prototype.getAbstraction = function (displayObject) {
	        return (this._abstractionPool[displayObject.id] || (this._abstractionPool[displayObject.id] = new PartitionBase._abstractionClassPool[displayObject.assetType](displayObject, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    PartitionBase.prototype.clearAbstraction = function (displayObject) {
	        this._abstractionPool[displayObject.id] = null;
	    };
	    PartitionBase.prototype.traverse = function (traverser) {
	        if (this._updatesMade)
	            this.updateEntities();
	        this._rootNode.acceptTraverser(traverser);
	    };
	    PartitionBase.prototype.iMarkForUpdate = function (node) {
	        var t = this._updateQueue;
	        while (t) {
	            if (node == t)
	                return;
	            t = t._iUpdateQueueNext;
	        }
	        node._iUpdateQueueNext = this._updateQueue;
	        this._updateQueue = node;
	        this._updatesMade = true;
	    };
	    PartitionBase.prototype.iRemoveEntity = function (node) {
	        var t;
	        if (node.parent) {
	            node.parent.iRemoveNode(node);
	            node.parent = null;
	        }
	        if (node == this._updateQueue) {
	            this._updateQueue = node._iUpdateQueueNext;
	        }
	        else {
	            t = this._updateQueue;
	            while (t && t._iUpdateQueueNext != node)
	                t = t._iUpdateQueueNext;
	            if (t)
	                t._iUpdateQueueNext = node._iUpdateQueueNext;
	        }
	        node._iUpdateQueueNext = null;
	        if (!this._updateQueue)
	            this._updatesMade = false;
	    };
	    /**
	     *
	     * @param entity
	     * @returns {away.partition.NodeBase}
	     */
	    PartitionBase.prototype.findParentForNode = function (node) {
	        return this._rootNode;
	    };
	    PartitionBase.prototype.updateEntities = function () {
	        var node = this._updateQueue;
	        while (node) {
	            //required for controllers with autoUpdate set to true and queued events
	            node._displayObject._iInternalUpdate();
	            node = node._iUpdateQueueNext;
	        }
	        //reset head
	        node = this._updateQueue;
	        var targetNode;
	        var t;
	        this._updateQueue = null;
	        this._updatesMade = false;
	        do {
	            targetNode = this.findParentForNode(node);
	            if (node.parent != targetNode) {
	                if (node.parent)
	                    node.parent.iRemoveNode(node);
	                targetNode.iAddNode(node);
	            }
	            t = node._iUpdateQueueNext;
	            node._iUpdateQueueNext = null;
	        } while ((node = t) != null);
	    };
	    /**
	     * @internal
	     */
	    PartitionBase.prototype._iRegisterEntity = function (displayObject) {
	        if (displayObject.isEntity)
	            this.iMarkForUpdate(this.getAbstraction(displayObject));
	    };
	    /**
	     * @internal
	     */
	    PartitionBase.prototype._iUnregisterEntity = function (displayObject) {
	        if (displayObject.isEntity)
	            this.iRemoveEntity(this.getAbstraction(displayObject));
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    PartitionBase.registerAbstraction = function (entityNodeClass, assetClass) {
	        PartitionBase._abstractionClassPool[assetClass.assetType] = entityNodeClass;
	    };
	    PartitionBase._abstractionClassPool = new Object();
	    return PartitionBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PartitionBase;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(30);
	/**
	 * Picks a 3d object from a view or scene by 3D raycast calculations.
	 * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
	 * then triggers an optional picking collider on individual renderable objects to further determine the precise values of the picking ray collision.
	 *
	 * @class away.pick.RaycastPicker
	 */
	var RaycastPicker = (function () {
	    /**
	     * Creates a new <code>RaycastPicker</code> object.
	     *
	     * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
	     * or simply returns the first collision encountered. Defaults to false.
	     */
	    function RaycastPicker(findClosestCollision) {
	        if (findClosestCollision === void 0) { findClosestCollision = false; }
	        this._entities = new Array();
	        /**
	         * @inheritDoc
	         */
	        this.onlyMouseEnabled = true;
	        this._findClosestCollision = findClosestCollision;
	    }
	    /**
	     * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
	     *
	     * @param node The Partition3DNode object to frustum-test.
	     */
	    RaycastPicker.prototype.enterNode = function (node) {
	        return node.isIntersectingRay(this._rayPosition, this._rayDirection);
	    };
	    /**
	     * @inheritDoc
	     */
	    RaycastPicker.prototype.getViewCollision = function (x, y, view) {
	        this._x = x;
	        this._y = y;
	        this._view = view;
	        //update ray
	        var rayPosition = view.unproject(x, y, 0);
	        var rayDirection = view.unproject(x, y, 1).subtract(rayPosition);
	        return this.getSceneCollision(rayPosition, rayDirection, view.scene);
	    };
	    /**
	     * @inheritDoc
	     */
	    RaycastPicker.prototype.getSceneCollision = function (rayPosition, rayDirection, scene) {
	        this._rayPosition = rayPosition;
	        this._rayDirection = rayDirection;
	        // collect entities to test
	        scene.traversePartitions(this);
	        //early out if no collisions detected
	        if (!this._entities.length)
	            return null;
	        var collision = this.getPickingCollision();
	        //discard entities
	        this._entities.length = 0;
	        return collision;
	    };
	    //		public getEntityCollision(position:Vector3D, direction:Vector3D, entities:Array<IEntity>):PickingCollision
	    //		{
	    //			this._numRenderables = 0;
	    //
	    //			var renderable:IEntity;
	    //			var l:number = entities.length;
	    //
	    //			for (var c:number = 0; c < l; c++) {
	    //				renderable = entities[c];
	    //
	    //				if (renderable.isIntersectingRay(position, direction))
	    //					this._renderables[this._numRenderables++] = renderable;
	    //			}
	    //
	    //			return this.getPickingCollision(this._raycastCollector);
	    //		}
	    RaycastPicker.prototype.setIgnoreList = function (entities) {
	        this._ignoredEntities = entities;
	    };
	    RaycastPicker.prototype.isIgnored = function (entity) {
	        if (this.onlyMouseEnabled && !entity._iIsMouseEnabled())
	            return true;
	        if (this._ignoredEntities) {
	            var len = this._ignoredEntities.length;
	            for (var i = 0; i < len; i++)
	                if (this._ignoredEntities[i] == entity)
	                    return true;
	        }
	        return false;
	    };
	    RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
	        return entity1._iPickingCollision.rayEntryDistance > entity2._iPickingCollision.rayEntryDistance ? 1 : -1;
	    };
	    RaycastPicker.prototype.getPickingCollision = function () {
	        // Sort entities from closest to furthest to reduce tests.
	        this._entities = this._entities.sort(this.sortOnNearT); // TODO - test sort filter in JS
	        // ---------------------------------------------------------------------
	        // Evaluate triangle collisions when needed.
	        // Replaces collision data provided by bounds collider with more precise data.
	        // ---------------------------------------------------------------------
	        this._bestCollision = null;
	        var entity;
	        var len = this._entities.length;
	        for (var i = 0; i < len; i++) {
	            entity = this._entities[i];
	            this._testCollision = entity._iPickingCollision;
	            if (this._bestCollision == null || this._testCollision.rayEntryDistance < this._bestCollision.rayEntryDistance) {
	                this._testCollider = entity.pickingCollider;
	                if (this._testCollider) {
	                    this._testCollision.rayEntryDistance = Number.MAX_VALUE;
	                    entity._acceptTraverser(this);
	                    // If a collision exists, update the collision data and stop all checks.
	                    if (this._bestCollision && !this._findClosestCollision)
	                        break;
	                }
	                else if (!this._testCollision.rayOriginIsInsideBounds) {
	                    // A bounds collision with no picking collider stops all checks.
	                    // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
	                    // to enable the detection of a corresponsding triangle collision.
	                    // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
	                    // if it has been established that there is NO triangle collider to test
	                    this._bestCollision = this._testCollision;
	                    break;
	                }
	            }
	        }
	        if (this._bestCollision)
	            this.updatePosition(this._bestCollision);
	        return this._bestCollision;
	    };
	    RaycastPicker.prototype.updatePosition = function (pickingCollision) {
	        var collisionPos = pickingCollision.position || (pickingCollision.position = new Vector3D_1.default());
	        var rayDir = pickingCollision.rayDirection;
	        var rayPos = pickingCollision.rayPosition;
	        var t = pickingCollision.rayEntryDistance;
	        collisionPos.x = rayPos.x + t * rayDir.x;
	        collisionPos.y = rayPos.y + t * rayDir.y;
	        collisionPos.z = rayPos.z + t * rayDir.z;
	    };
	    RaycastPicker.prototype.dispose = function () {
	        //TODO
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyEntity = function (entity) {
	        if (!this.isIgnored(entity))
	            this._entities.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyRenderable = function (renderable) {
	        if (renderable._iTestCollision(this._testCollision, this._testCollider))
	            this._bestCollision = this._testCollision;
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyDirectionalLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyLightProbe = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyPointLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applySkybox = function (entity) {
	        //don't do anything here
	    };
	    return RaycastPicker;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RaycastPicker;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(28);
	var Plane3D_1 = __webpack_require__(65);
	var ProjectionEvent_1 = __webpack_require__(37);
	var PerspectiveProjection_1 = __webpack_require__(66);
	var HierarchicalProperties_1 = __webpack_require__(49);
	var BoundsType_1 = __webpack_require__(50);
	var DisplayObjectContainer_1 = __webpack_require__(43);
	var CameraEvent_1 = __webpack_require__(68);
	var Camera = (function (_super) {
	    __extends(Camera, _super);
	    function Camera(projection) {
	        var _this = this;
	        if (projection === void 0) { projection = null; }
	        _super.call(this);
	        this._viewProjection = new Matrix3D_1.default();
	        this._viewProjectionDirty = true;
	        this._frustumPlanesDirty = true;
	        this._pIsEntity = true;
	        this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
	        this._projection = projection || new PerspectiveProjection_1.default();
	        this._projection.addEventListener(ProjectionEvent_1.default.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	        this._frustumPlanes = [];
	        for (var i = 0; i < 6; ++i)
	            this._frustumPlanes[i] = new Plane3D_1.default();
	        this.z = -1000;
	        //default bounds type
	        this._boundsType = BoundsType_1.default.NULL;
	    }
	    Object.defineProperty(Camera.prototype, "assetType", {
	        //@override
	        get: function () {
	            return Camera.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Camera.prototype.onProjectionMatrixChanged = function (event) {
	        this._viewProjectionDirty = true;
	        this._frustumPlanesDirty = true;
	        this.dispatchEvent(event);
	    };
	    Object.defineProperty(Camera.prototype, "frustumPlanes", {
	        get: function () {
	            if (this._frustumPlanesDirty)
	                this.updateFrustum();
	            return this._frustumPlanes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Camera.prototype.updateFrustum = function () {
	        var a, b, c;
	        //var d : Number;
	        var c11, c12, c13, c14;
	        var c21, c22, c23, c24;
	        var c31, c32, c33, c34;
	        var c41, c42, c43, c44;
	        var p;
	        var raw = this.viewProjection.rawData;
	        var invLen;
	        c11 = raw[0];
	        c12 = raw[4];
	        c13 = raw[8];
	        c14 = raw[12];
	        c21 = raw[1];
	        c22 = raw[5];
	        c23 = raw[9];
	        c24 = raw[13];
	        c31 = raw[2];
	        c32 = raw[6];
	        c33 = raw[10];
	        c34 = raw[14];
	        c41 = raw[3];
	        c42 = raw[7];
	        c43 = raw[11];
	        c44 = raw[15];
	        // left plane
	        p = this._frustumPlanes[0];
	        a = c41 + c11;
	        b = c42 + c12;
	        c = c43 + c13;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -(c44 + c14) * invLen;
	        // right plane
	        p = this._frustumPlanes[1];
	        a = c41 - c11;
	        b = c42 - c12;
	        c = c43 - c13;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c14 - c44) * invLen;
	        // bottom
	        p = this._frustumPlanes[2];
	        a = c41 + c21;
	        b = c42 + c22;
	        c = c43 + c23;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -(c44 + c24) * invLen;
	        // top
	        p = this._frustumPlanes[3];
	        a = c41 - c21;
	        b = c42 - c22;
	        c = c43 - c23;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c24 - c44) * invLen;
	        // near
	        p = this._frustumPlanes[4];
	        a = c31;
	        b = c32;
	        c = c33;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -c34 * invLen;
	        // far
	        p = this._frustumPlanes[5];
	        a = c41 - c31;
	        b = c42 - c32;
	        c = c43 - c33;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c34 - c44) * invLen;
	        this._frustumPlanesDirty = false;
	    };
	    Camera.prototype.pInvalidateHierarchicalProperties = function (bitFlag) {
	        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, bitFlag))
	            return true;
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.SCENE_TRANSFORM) {
	            this._viewProjectionDirty = true;
	            this._frustumPlanesDirty = true;
	        }
	        return false;
	    };
	    Object.defineProperty(Camera.prototype, "projection", {
	        /**
	         *
	         */
	        get: function () {
	            return this._projection;
	        },
	        set: function (value) {
	            if (this._projection == value)
	                return;
	            if (!value)
	                throw new Error("Projection cannot be null!");
	            this._projection.removeEventListener(ProjectionEvent_1.default.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            this._projection = value;
	            this._projection.addEventListener(ProjectionEvent_1.default.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            this.dispatchEvent(new CameraEvent_1.default(CameraEvent_1.default.PROJECTION_CHANGED, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Camera.prototype, "viewProjection", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._viewProjectionDirty) {
	                this._viewProjection.copyFrom(this.inverseSceneTransform);
	                this._viewProjection.append(this._projection.matrix);
	                this._viewProjectionDirty = false;
	            }
	            return this._viewProjection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Calculates the ray in scene space from the camera to the given normalized coordinates in screen space.
	     *
	     * @param nX The normalised x coordinate in screen space, -1 corresponds to the left edge of the viewport, 1 to the right.
	     * @param nY The normalised y coordinate in screen space, -1 corresponds to the top edge of the viewport, 1 to the bottom.
	     * @param sZ The z coordinate in screen space, representing the distance into the screen.
	     * @return The ray from the camera to the scene space position of the given screen coordinates.
	     */
	    Camera.prototype.getRay = function (nX, nY, sZ) {
	        return this.sceneTransform.deltaTransformVector(this._projection.unproject(nX, nY, sZ));
	    };
	    /**
	     * Calculates the normalised position in screen space of the given scene position.
	     *
	     * @param point3d the position vector of the scene coordinates to be projected.
	     * @return The normalised screen position of the given scene coordinates.
	     */
	    Camera.prototype.project = function (point3d) {
	        return this._projection.project(this.inverseSceneTransform.transformVector(point3d));
	    };
	    /**
	     * Calculates the scene position of the given normalized coordinates in screen space.
	     *
	     * @param nX The normalised x coordinate in screen space, minus the originX offset of the projection property.
	     * @param nY The normalised y coordinate in screen space, minus the originY offset of the projection property.
	     * @param sZ The z coordinate in screen space, representing the distance into the screen.
	     * @return The scene position of the given screen coordinates.
	     */
	    Camera.prototype.unproject = function (nX, nY, sZ) {
	        return this.sceneTransform.transformVector(this._projection.unproject(nX, nY, sZ));
	    };
	    Camera.prototype._applyRenderer = function (renderer) {
	        // Since this getter is invoked every iteration of the render loop, and
	        // the prefab construct could affect the sub-sprites, the prefab is
	        // validated here to give it a chance to rebuild.
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        //nothing to do here
	    };
	    Camera.assetType = "[asset Camera]";
	    return Camera;
	}(DisplayObjectContainer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Camera;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PlaneClassification_1 = __webpack_require__(60);
	var Plane3D = (function () {
	    /**
	     * Create a Plane3D with ABCD coefficients
	     */
	    function Plane3D(a, b, c, d) {
	        if (a === void 0) { a = 0; }
	        if (b === void 0) { b = 0; }
	        if (c === void 0) { c = 0; }
	        if (d === void 0) { d = 0; }
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.d = d;
	        if (a == 0 && b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (b == 0 && c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (a == 0 && c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    }
	    /**
	     * Fills this Plane3D with the coefficients from 3 points in 3d space.
	     * @param p0 Vector3D
	     * @param p1 Vector3D
	     * @param p2 Vector3D
	     */
	    Plane3D.prototype.fromPoints = function (p0, p1, p2) {
	        var d1x = p1.x - p0.x;
	        var d1y = p1.y - p0.y;
	        var d1z = p1.z - p0.z;
	        var d2x = p2.x - p0.x;
	        var d2y = p2.y - p0.y;
	        var d2z = p2.z - p0.z;
	        this.a = d1y * d2z - d1z * d2y;
	        this.b = d1z * d2x - d1x * d2z;
	        this.c = d1x * d2y - d1y * d2x;
	        this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
	        // not using epsilon, since a plane is infinite and a small incorrection can grow very large
	        if (this.a == 0 && this.b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (this.b == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (this.a == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    };
	    /**
	     * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
	     * @param normal Vector3D
	     * @param point  Vector3D
	     */
	    Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
	        this.a = normal.x;
	        this.b = normal.y;
	        this.c = normal.z;
	        this.d = this.a * point.x + this.b * point.y + this.c * point.z;
	        if (this.a == 0 && this.b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (this.b == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (this.a == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    };
	    /**
	     * Normalize this Plane3D
	     * @return Plane3D This Plane3D.
	     */
	    Plane3D.prototype.normalize = function () {
	        var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
	        this.a *= len;
	        this.b *= len;
	        this.c *= len;
	        this.d *= len;
	        return this;
	    };
	    /**
	     * Returns the signed distance between this Plane3D and the point p.
	     * @param p Vector3D
	     * @returns Number
	     */
	    Plane3D.prototype.distance = function (p) {
	        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS) {
	            return this.a * p.x - this.d;
	        }
	        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS) {
	            return this.b * p.y - this.d;
	        }
	        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS) {
	            return this.c * p.z - this.d;
	        }
	        else {
	            return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
	        }
	    };
	    /**
	     * Classify a point against this Plane3D. (in front, back or intersecting)
	     * @param p Vector3D
	     * @return int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
	     */
	    Plane3D.prototype.classifyPoint = function (p, epsilon) {
	        if (epsilon === void 0) { epsilon = 0.01; }
	        // check NaN
	        if (this.d != this.d)
	            return PlaneClassification_1.default.FRONT;
	        var len;
	        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS)
	            len = this.a * p.x - this.d;
	        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS)
	            len = this.b * p.y - this.d;
	        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS)
	            len = this.c * p.z - this.d;
	        else
	            len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
	        if (len < -epsilon)
	            return PlaneClassification_1.default.BACK;
	        else if (len > epsilon)
	            return PlaneClassification_1.default.FRONT;
	        else
	            return PlaneClassification_1.default.INTERSECT;
	    };
	    Plane3D.prototype.toString = function () {
	        return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
	    };
	    // indicates the alignment of the plane
	    Plane3D.ALIGN_ANY = 0;
	    Plane3D.ALIGN_XY_AXIS = 1;
	    Plane3D.ALIGN_YZ_AXIS = 2;
	    Plane3D.ALIGN_XZ_AXIS = 3;
	    return Plane3D;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Plane3D;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Vector3D_1 = __webpack_require__(30);
	var CoordinateSystem_1 = __webpack_require__(67);
	var ProjectionBase_1 = __webpack_require__(34);
	var PerspectiveProjection = (function (_super) {
	    __extends(PerspectiveProjection, _super);
	    function PerspectiveProjection(fieldOfView, coordinateSystem) {
	        if (fieldOfView === void 0) { fieldOfView = 60; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        _super.call(this, coordinateSystem);
	        this._fieldOfView = 60;
	        this._focalLength = 1000;
	        this._hFieldOfView = 60;
	        this._hFocalLength = 1000;
	        this._preserveAspectRatio = true;
	        this._preserveFocalLength = false;
	        this.fieldOfView = fieldOfView;
	    }
	    Object.defineProperty(PerspectiveProjection.prototype, "preserveAspectRatio", {
	        /**
	         *
	         */
	        get: function () {
	            return this._preserveAspectRatio;
	        },
	        set: function (value) {
	            if (this._preserveAspectRatio == value)
	                return;
	            this._preserveAspectRatio = value;
	            if (this._preserveAspectRatio)
	                this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "preserveFocalLength", {
	        /**
	         *
	         */
	        get: function () {
	            return this._preserveFocalLength;
	        },
	        set: function (value) {
	            if (this._preserveFocalLength == value)
	                return;
	            this._preserveFocalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
	        /**
	         *
	         */
	        get: function () {
	            return this._fieldOfView;
	        },
	        set: function (value) {
	            if (this._fieldOfView == value)
	                return;
	            this._fieldOfView = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
	        /**
	         *
	         */
	        get: function () {
	            return this._focalLength;
	        },
	        set: function (value) {
	            if (this._focalLength == value)
	                return;
	            this._focalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "hFieldOfView", {
	        /**
	         *
	         */
	        get: function () {
	            return this._hFieldOfView;
	        },
	        set: function (value) {
	            if (this._hFieldOfView == value)
	                return;
	            this._hFieldOfView = value;
	            this._hFocalLength = 1 / Math.tan(this._hFieldOfView * Math.PI / 360);
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "hFocalLength", {
	        /**
	         *
	         */
	        get: function () {
	            return this._hFocalLength;
	        },
	        set: function (value) {
	            if (this._hFocalLength == value)
	                return;
	            this._hFocalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    PerspectiveProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.default(nX, -nY, sZ, 1.0);
	        v.x *= sZ;
	        v.y *= sZ;
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    PerspectiveProjection.prototype.clone = function () {
	        var clone = new PerspectiveProjection(this._fieldOfView);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone._pCoordinateSystem = this._pCoordinateSystem;
	        return clone;
	    };
	    //@override
	    PerspectiveProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        if (this._preserveFocalLength) {
	            if (this._preserveAspectRatio)
	                this._hFocalLength = this._focalLength;
	            this._fieldOfView = Math.atan(0.5 * this._pScissorRect.height / this._focalLength) * 360 / Math.PI;
	            this._hFieldOfView = Math.atan(0.5 * this._pScissorRect.width / this._hFocalLength) * 360 / Math.PI;
	        }
	        else {
	            this._focalLength = 0.5 * this._pScissorRect.height / Math.tan(this._fieldOfView * Math.PI / 360);
	            if (this._preserveAspectRatio)
	                this._hFocalLength = this._focalLength;
	            else
	                this._hFocalLength = 0.5 * this._pScissorRect.width / Math.tan(this._hFieldOfView * Math.PI / 360);
	        }
	        var tanMinX = -this._pOriginX / this._hFocalLength;
	        var tanMaxX = (1 - this._pOriginX) / this._hFocalLength;
	        var tanMinY = -this._pOriginY / this._focalLength;
	        var tanMaxY = (1 - this._pOriginY) / this._focalLength;
	        var left;
	        var right;
	        var top;
	        var bottom;
	        // assume scissored frustum
	        var center = -((tanMinX - tanMaxX) * this._pScissorRect.x + tanMinX * this._pScissorRect.width);
	        var middle = ((tanMinY - tanMaxY) * this._pScissorRect.y + tanMinY * this._pScissorRect.height);
	        left = center - (tanMaxX - tanMinX) * this._pViewPort.width;
	        right = center;
	        top = middle;
	        bottom = middle + (tanMaxY - tanMinY) * this._pViewPort.height;
	        raw[0] = 2 / (right - left);
	        raw[5] = 2 / (bottom - top);
	        raw[8] = (right + left) / (right - left);
	        raw[9] = (bottom + top) / (bottom - top);
	        raw[10] = (this._pFar + this._pNear) / (this._pFar - this._pNear);
	        raw[11] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
	        raw[14] = -2 * this._pFar * this._pNear / (this._pFar - this._pNear);
	        if (this._pCoordinateSystem == CoordinateSystem_1.default.RIGHT_HANDED)
	            raw[5] = -raw[5];
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pNear * left;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pNear * right;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pNear * top;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pNear * bottom;
	        this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._pFar * left;
	        this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._pFar * right;
	        this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._pFar * top;
	        this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._pFar * bottom;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrixInvalid = false;
	    };
	    return PerspectiveProjection;
	}(ProjectionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerspectiveProjection;


/***/ },
/* 67 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Provides constant values for camera lens projection options use the the <code>coordinateSystem</code> property
	 *
	 * @see away.projections.PerspectiveLens#coordinateSystem
	 */
	var CoordinateSystem = (function () {
	    function CoordinateSystem() {
	    }
	    /**
	     * Default option, projects to a left-handed coordinate system
	     */
	    CoordinateSystem.LEFT_HANDED = "leftHanded";
	    /**
	     * Projects to a right-handed coordinate system
	     */
	    CoordinateSystem.RIGHT_HANDED = "rightHanded";
	    return CoordinateSystem;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CoordinateSystem;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * @class away.events.CameraEvent
	 */
	var CameraEvent = (function (_super) {
	    __extends(CameraEvent, _super);
	    function CameraEvent(type, camera) {
	        _super.call(this, type);
	        this._camera = camera;
	    }
	    Object.defineProperty(CameraEvent.prototype, "camera", {
	        get: function () {
	            return this._camera;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    CameraEvent.prototype.clone = function () {
	        return new CameraEvent(this.type, this._camera);
	    };
	    CameraEvent.PROJECTION_CHANGED = "projectionChanged";
	    return CameraEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CameraEvent;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var RendererEvent = (function (_super) {
	    __extends(RendererEvent, _super);
	    function RendererEvent(type) {
	        _super.call(this, type);
	    }
	    RendererEvent.VIEWPORT_UPDATED = "viewportUpdated";
	    RendererEvent.SCISSOR_UPDATED = "scissorUpdated";
	    return RendererEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RendererEvent;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(30);
	var TouchPoint_1 = __webpack_require__(41);
	var MouseEvent_1 = __webpack_require__(71);
	var FrameScriptManager_1 = __webpack_require__(72);
	/**
	 * MouseManager enforces a singleton pattern and is not intended to be instanced.
	 * it provides a manager class for detecting mouse hits on scene objects and sending out mouse events.
	 */
	var MouseManager = (function () {
	    /**
	     * Creates a new <code>MouseManager</code> object.
	     */
	    function MouseManager() {
	        var _this = this;
	        this._viewLookup = new Array();
	        this._nullVector = new Vector3D_1.default();
	        this._queuedEvents = new Array();
	        this._mouseUp = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_UP);
	        this._mouseClick = new MouseEvent_1.default(MouseEvent_1.default.CLICK);
	        this._mouseOut = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_OUT);
	        this._mouseDown = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_DOWN);
	        this._mouseMove = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_MOVE);
	        this._mouseOver = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_OVER);
	        this._mouseWheel = new MouseEvent_1.default(MouseEvent_1.default.MOUSE_WHEEL);
	        this._mouseDoubleClick = new MouseEvent_1.default(MouseEvent_1.default.DOUBLE_CLICK);
	        this.onClickDelegate = function (event) { return _this.onClick(event); };
	        this.onDoubleClickDelegate = function (event) { return _this.onDoubleClick(event); };
	        this.onMouseDownDelegate = function (event) { return _this.onMouseDown(event); };
	        this.onMouseMoveDelegate = function (event) { return _this.onMouseMove(event); };
	        this.onMouseUpDelegate = function (event) { return _this.onMouseUp(event); };
	        this.onMouseWheelDelegate = function (event) { return _this.onMouseWheel(event); };
	        this.onMouseOverDelegate = function (event) { return _this.onMouseOver(event); };
	        this.onMouseOutDelegate = function (event) { return _this.onMouseOut(event); };
	    }
	    MouseManager.getInstance = function () {
	        if (this._instance)
	            return this._instance;
	        return (this._instance = new MouseManager());
	    };
	    MouseManager.prototype.fireMouseEvents = function (forceMouseMove) {
	        // If colliding object has changed, queue over/out events.
	        if (this._iCollision != this._previousCollidingObject) {
	            if (this._previousCollidingObject)
	                this.queueDispatch(this._mouseOut, this._mouseMoveEvent, this._previousCollidingObject);
	            if (this._iCollision)
	                this.queueDispatch(this._mouseOver, this._mouseMoveEvent);
	        }
	        // Fire mouse move events here if forceMouseMove is on.
	        if (forceMouseMove && this._iCollision)
	            this.queueDispatch(this._mouseMove, this._mouseMoveEvent);
	        var event;
	        var dispatcher;
	        // Dispatch all queued events.
	        var len = this._queuedEvents.length;
	        for (var i = 0; i < len; ++i) {
	            event = this._queuedEvents[i];
	            dispatcher = event.entity;
	            // bubble event up the heirarchy until the top level parent is reached
	            while (dispatcher) {
	                if (dispatcher._iIsMouseEnabled())
	                    dispatcher.dispatchEvent(event);
	                dispatcher = dispatcher.parent;
	            }
	            // not totally sure, but i think just calling it is easier and cheaper than any options for that
	            // if nothing is queued, the function will return directly anyway
	            FrameScriptManager_1.default.execute_queue();
	        }
	        this._queuedEvents.length = 0;
	        this._previousCollidingObject = this._iCollision;
	        this._iUpdateDirty = false;
	    };
	    //		public addViewLayer(view:View)
	    //		{
	    //			var stg:Stage = view.stage;
	    //
	    //			// Add instance to mouse3dmanager to fire mouse events for multiple views
	    //			if (!view.stageGL.mouse3DManager)
	    //				view.stageGL.mouse3DManager = this;
	    //
	    //			if (!hasKey(view))
	    //				_view3Ds[view] = 0;
	    //
	    //			_childDepth = 0;
	    //			traverseDisplayObjects(stg);
	    //			_viewCount = _childDepth;
	    //		}
	    MouseManager.prototype.registerView = function (view) {
	        if (view && view.htmlElement) {
	            view.htmlElement.addEventListener("click", this.onClickDelegate);
	            view.htmlElement.addEventListener("dblclick", this.onDoubleClickDelegate);
	            view.htmlElement.addEventListener("touchstart", this.onMouseDownDelegate);
	            view.htmlElement.addEventListener("mousedown", this.onMouseDownDelegate);
	            view.htmlElement.addEventListener("touchmove", this.onMouseMoveDelegate);
	            view.htmlElement.addEventListener("mousemove", this.onMouseMoveDelegate);
	            view.htmlElement.addEventListener("mouseup", this.onMouseUpDelegate);
	            view.htmlElement.addEventListener("touchend", this.onMouseUpDelegate);
	            view.htmlElement.addEventListener("mousewheel", this.onMouseWheelDelegate);
	            view.htmlElement.addEventListener("mouseover", this.onMouseOverDelegate);
	            view.htmlElement.addEventListener("mouseout", this.onMouseOutDelegate);
	            this._viewLookup.push(view);
	        }
	    };
	    MouseManager.prototype.unregisterView = function (view) {
	        if (view && view.htmlElement) {
	            view.htmlElement.removeEventListener("click", this.onClickDelegate);
	            view.htmlElement.removeEventListener("dblclick", this.onDoubleClickDelegate);
	            view.htmlElement.removeEventListener("touchstart", this.onMouseDownDelegate);
	            view.htmlElement.removeEventListener("mousedown", this.onMouseDownDelegate);
	            view.htmlElement.removeEventListener("touchmove", this.onMouseMoveDelegate);
	            view.htmlElement.removeEventListener("mousemove", this.onMouseMoveDelegate);
	            view.htmlElement.removeEventListener("touchend", this.onMouseUpDelegate);
	            view.htmlElement.removeEventListener("mouseup", this.onMouseUpDelegate);
	            view.htmlElement.removeEventListener("mousewheel", this.onMouseWheelDelegate);
	            view.htmlElement.removeEventListener("mouseover", this.onMouseOverDelegate);
	            view.htmlElement.removeEventListener("mouseout", this.onMouseOutDelegate);
	            this._viewLookup.slice(this._viewLookup.indexOf(view), 1);
	        }
	    };
	    // ---------------------------------------------------------------------
	    // Private.
	    // ---------------------------------------------------------------------
	    MouseManager.prototype.queueDispatch = function (event, sourceEvent, collision) {
	        if (collision === void 0) { collision = null; }
	        // 2D properties.
	        if (sourceEvent) {
	            event.ctrlKey = sourceEvent.ctrlKey;
	            event.altKey = sourceEvent.altKey;
	            event.shiftKey = sourceEvent.shiftKey;
	            event.screenX = (sourceEvent.clientX != null) ? sourceEvent.clientX : sourceEvent.changedTouches[0].clientX;
	            event.screenY = (sourceEvent.clientY != null) ? sourceEvent.clientY : sourceEvent.changedTouches[0].clientY;
	        }
	        if (collision == null)
	            collision = this._iCollision;
	        // 3D properties.
	        if (collision) {
	            // Object.
	            event.entity = collision.entity;
	            event.renderable = collision.renderable;
	            // UV.
	            event.uv = collision.uv;
	            // Position.
	            event.position = collision.position ? collision.position.clone() : null;
	            // Normal.
	            event.normal = collision.normal ? collision.normal.clone() : null;
	            // Face index.
	            event.elementIndex = collision.elementIndex;
	        }
	        else {
	            // Set all to null.
	            event.uv = null;
	            event.entity = null;
	            event.position = this._nullVector;
	            event.normal = this._nullVector;
	            event.elementIndex = 0;
	        }
	        // Store event to be dispatched later.
	        this._queuedEvents.push(event);
	    };
	    // ---------------------------------------------------------------------
	    // Listeners.
	    // ---------------------------------------------------------------------
	    MouseManager.prototype.onMouseMove = function (event) {
	        event.preventDefault();
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseMove, this._mouseMoveEvent = event);
	    };
	    MouseManager.prototype.onMouseOut = function (event) {
	        this._iActiveDiv = null;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseOut, event);
	    };
	    MouseManager.prototype.onMouseOver = function (event) {
	        this._iActiveDiv = event.target;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseOver, event);
	    };
	    MouseManager.prototype.onClick = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseClick, event);
	    };
	    MouseManager.prototype.onDoubleClick = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseDoubleClick, event);
	    };
	    MouseManager.prototype.onMouseDown = function (event) {
	        event.preventDefault();
	        this._iActiveDiv = event.target;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseDown, event);
	    };
	    MouseManager.prototype.onMouseUp = function (event) {
	        event.preventDefault();
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseUp, event);
	    };
	    MouseManager.prototype.onMouseWheel = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseWheel, event);
	    };
	    MouseManager.prototype.updateColliders = function (event) {
	        var view;
	        var bounds;
	        var mouseX = (event.clientX != null) ? event.clientX : event.changedTouches[0].clientX;
	        var mouseY = (event.clientY != null) ? event.clientY : event.changedTouches[0].clientY;
	        var len = this._viewLookup.length;
	        for (var i = 0; i < len; i++) {
	            view = this._viewLookup[i];
	            view._pTouchPoints.length = 0;
	            bounds = view.htmlElement.getBoundingClientRect();
	            if (event.touches) {
	                var touch;
	                var len = event.touches.length;
	                for (var i = 0; i < len; i++) {
	                    touch = event.touches[i];
	                    view._pTouchPoints.push(new TouchPoint_1.default(touch.clientX + bounds.left, touch.clientY + bounds.top, touch.identifier));
	                }
	            }
	            if (this._iUpdateDirty)
	                continue;
	            if (mouseX < bounds.left || mouseX > bounds.right || mouseY < bounds.top || mouseY > bounds.bottom) {
	                view._pMouseX = null;
	                view._pMouseY = null;
	            }
	            else {
	                view._pMouseX = mouseX + bounds.left;
	                view._pMouseY = mouseY + bounds.top;
	                view.updateCollider();
	                if (view.layeredView && this._iCollision)
	                    break;
	            }
	        }
	        this._iUpdateDirty = true;
	    };
	    return MouseManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MouseManager;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * A MouseEvent is dispatched when a mouse event occurs over a mouseEnabled object in View.
	 * TODO: we don't have screenZ data, tho this should be easy to implement
	 */
	var MouseEvent = (function (_super) {
	    __extends(MouseEvent, _super);
	    /**
	     * Create a new MouseEvent object.
	     * @param type The type of the MouseEvent.
	     */
	    function MouseEvent(type) {
	        _super.call(this, type);
	        // Private.
	        this._iAllowedToPropagate = true;
	    }
	    Object.defineProperty(MouseEvent.prototype, "bubbles", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            var doesBubble = this._iAllowedToPropagate;
	            this._iAllowedToPropagate = true;
	            // Don't bubble if propagation has been stopped.
	            return doesBubble;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    MouseEvent.prototype.stopPropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopPropagation();
	    };
	    /**
	     * @inheritDoc
	     */
	    MouseEvent.prototype.stopImmediatePropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopImmediatePropagation();
	    };
	    /**
	     * Creates a copy of the MouseEvent object and sets the value of each property to match that of the original.
	     */
	    MouseEvent.prototype.clone = function () {
	        var result = new MouseEvent(this.type);
	        /* TODO: Debug / test - look into isDefaultPrevented
	         if (isDefaultPrevented())
	         result.preventDefault();
	         */
	        result.screenX = this.screenX;
	        result.screenY = this.screenY;
	        result.view = this.view;
	        result.entity = this.entity;
	        result.renderable = this.renderable;
	        result.material = this.material;
	        result.uv = this.uv;
	        result.position = this.position;
	        result.normal = this.normal;
	        result.elementIndex = this.elementIndex;
	        result.delta = this.delta;
	        result.ctrlKey = this.ctrlKey;
	        result.shiftKey = this.shiftKey;
	        result._iParentEvent = this;
	        result._iAllowedToPropagate = this._iAllowedToPropagate;
	        return result;
	    };
	    Object.defineProperty(MouseEvent.prototype, "scenePosition", {
	        /**
	         * The position in scene space where the event took place
	         */
	        get: function () {
	            return this.entity.sceneTransform.transformVector(this.position);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MouseEvent.prototype, "sceneNormal", {
	        /**
	         * The normal in scene space where the event took place
	         */
	        get: function () {
	            var sceneNormal = this.entity.sceneTransform.deltaTransformVector(this.normal);
	            sceneNormal.normalize();
	            return sceneNormal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Defines the value of the type property of a mouseOver3d event object.
	     */
	    MouseEvent.MOUSE_OVER = "mouseOver3d";
	    /**
	     * Defines the value of the type property of a mouseOut3d event object.
	     */
	    MouseEvent.MOUSE_OUT = "mouseOut3d";
	    /**
	     * Defines the value of the type property of a mouseUp3d event object.
	     */
	    MouseEvent.MOUSE_UP = "mouseUp3d";
	    /**
	     * Defines the value of the type property of a mouseDown3d event object.
	     */
	    MouseEvent.MOUSE_DOWN = "mouseDown3d";
	    /**
	     * Defines the value of the type property of a mouseMove3d event object.
	     */
	    MouseEvent.MOUSE_MOVE = "mouseMove3d";
	    /**
	     * Defines the value of the type property of a rollOver3d event object.
	     */
	    //		public static ROLL_OVER : string = "rollOver3d";
	    /**
	     * Defines the value of the type property of a rollOut3d event object.
	     */
	    //		public static ROLL_OUT : string = "rollOut3d";
	    /**
	     * Defines the value of the type property of a click3d event object.
	     */
	    MouseEvent.CLICK = "click3d";
	    /**
	     * Defines the value of the type property of a doubleClick3d event object.
	     */
	    MouseEvent.DOUBLE_CLICK = "doubleClick3d";
	    /**
	     * Defines the value of the type property of a mouseWheel3d event object.
	     */
	    MouseEvent.MOUSE_WHEEL = "mouseWheel3d";
	    return MouseEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MouseEvent;


/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";
	var FrameScriptManager = (function () {
	    function FrameScriptManager() {
	    }
	    FrameScriptManager.setInterval = function (func) {
	        this._intervalID++;
	        this._active_intervals[this._intervalID] = func;
	        return this._intervalID;
	    };
	    FrameScriptManager.clearInterval = function (id) {
	        delete this._active_intervals[id];
	    };
	    FrameScriptManager.execute_intervals = function () {
	        for (var key in this._active_intervals) {
	            this._active_intervals[key].call();
	        }
	    };
	    FrameScriptManager.add_child_to_dispose = function (child) {
	        this._queued_dispose.push(child);
	    };
	    FrameScriptManager.add_script_to_queue = function (mc, script) {
	        // whenever we queue scripts of new objects, we first inject the lists of pass2
	        var i = this._queued_mcs_pass2.length;
	        while (i--) {
	            this._queued_mcs.push(this._queued_mcs_pass2[i]);
	            this._queued_scripts.push(this._queued_scripts_pass2[i]);
	        }
	        this._queued_mcs_pass2.length = 0;
	        this._queued_scripts_pass2.length = 0;
	        this._queued_mcs.push(mc);
	        this._queued_scripts.push(script);
	    };
	    FrameScriptManager.add_script_to_queue_pass2 = function (mc, script) {
	        this._queued_mcs_pass2.push(mc);
	        this._queued_scripts_pass2.push(script);
	    };
	    FrameScriptManager.execute_queue = function () {
	        if (this._queued_mcs.length == 0 && this._queued_mcs_pass2.length == 0)
	            return;
	        var i = this._queued_mcs_pass2.length;
	        while (i--) {
	            this._queued_mcs.push(this._queued_mcs_pass2[i]);
	            this._queued_scripts.push(this._queued_scripts_pass2[i]);
	        }
	        this._queued_mcs_pass2.length = 0;
	        this._queued_scripts_pass2.length = 0;
	        var mc;
	        for (i = 0; i < this._queued_mcs.length; i++) {
	            // during the loop we might add more scripts to the queue
	            mc = this._queued_mcs[i];
	            if (mc.scene != null) {
	                var caller = mc.adapter ? mc.adapter : mc;
	                //	try {
	                this._queued_scripts[i].call(caller);
	            }
	        }
	        // all scripts executed. clear all
	        this._queued_mcs.length = 0;
	        this._queued_scripts.length = 0;
	    };
	    FrameScriptManager.execute_dispose = function () {
	        var len = this._queued_dispose.length;
	        for (var i = 0; i < len; i++)
	            this._queued_dispose[i].dispose();
	        this._queued_dispose.length = 0;
	    };
	    // FrameScript debugging:
	    // the first line of a FrameScript should be a comment that represents the functions unique name
	    // the exporter creates a js file, containing a object that has the framescripts functions set as properties according to the unique names
	    // this object can be set as "frameScriptDebug" in order to enable debug mode
	    FrameScriptManager.frameScriptDebug = undefined;
	    //queue of objects for disposal
	    FrameScriptManager._queued_dispose = new Array();
	    // queues pass1 of scripts.
	    FrameScriptManager._queued_mcs = [];
	    FrameScriptManager._queued_scripts = [];
	    // queues pass2 of scripts. this will be inserted in reversed order into pass1 queue right before something should be added to pass1
	    FrameScriptManager._queued_mcs_pass2 = [];
	    FrameScriptManager._queued_scripts_pass2 = [];
	    FrameScriptManager._active_intervals = new Object(); // maps id to function
	    FrameScriptManager._intervalID = 0;
	    return FrameScriptManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FrameScriptManager;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var Point_1 = __webpack_require__(36);
	var Vector3D_1 = __webpack_require__(30);
	var Graphics_1 = __webpack_require__(74);
	var DisplayObjectContainer_1 = __webpack_require__(43);
	/**
	 * Sprite is an instance of a Graphics, augmenting it with a presence in the scene graph, a material, and an animation
	 * state. It consists out of Graphices, which in turn correspond to SubGeometries. Graphices allow different parts
	 * of the graphics to be assigned different materials.
	 */
	var Sprite = (function (_super) {
	    __extends(Sprite, _super);
	    /**
	     * Create a new Sprite object.
	     *
	     * @param material    [optional]        The material with which to render the Sprite.
	     */
	    function Sprite(material) {
	        var _this = this;
	        if (material === void 0) { material = null; }
	        _super.call(this);
	        //temp point used in hit testing
	        this._tempPoint = new Point_1.default();
	        this._onGraphicsInvalidateDelegate = function (event) { return _this._onGraphicsInvalidate(event); };
	        this._graphics = new Graphics_1.default(); //unique graphics object for each Sprite
	        this._graphics.addEventListener(AssetEvent_1.default.INVALIDATE, this._onGraphicsInvalidateDelegate);
	        this.material = material;
	    }
	    Object.defineProperty(Sprite.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Sprite.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "graphics", {
	        /**
	         * Specifies the Graphics object belonging to this Sprite object, where
	         * drawing commands can occur.
	         */
	        get: function () {
	            if (this._iSourcePrefab)
	                this._iSourcePrefab._iValidate();
	            return this._graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "animator", {
	        /**
	         * Defines the animator of the graphics object.  Default value is <code>null</code>.
	         */
	        get: function () {
	            return this._graphics.animator;
	        },
	        set: function (value) {
	            if (this._graphics.animator)
	                this._graphics.animator.removeOwner(this);
	            this._graphics.animator = value;
	            if (this._graphics.animator)
	                this._graphics.animator.addOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "material", {
	        /**
	         * The material with which to render the Sprite.
	         */
	        get: function () {
	            return this._graphics.material;
	        },
	        set: function (value) {
	            this._graphics.material = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._graphics.style;
	        },
	        set: function (value) {
	            this._graphics.style = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Sprite.prototype.bakeTransformations = function () {
	        this._graphics.applyTransformation(this.transform.matrix3D);
	        this.transform.clearMatrix3D();
	    };
	    /**
	     * @inheritDoc
	     */
	    Sprite.prototype.dispose = function () {
	        this.disposeValues();
	        Sprite._sprites.push(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    Sprite.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._graphics.dispose();
	    };
	    /**
	     * Clones this Sprite instance along with all it's children, while re-using the same
	     * material, graphics and animation set. The returned result will be a copy of this sprite,
	     * containing copies of all of it's children.
	     *
	     * Properties that are re-used (i.e. not cloned) by the new copy include name,
	     * graphics, and material. Properties that are cloned or created anew for the copy
	     * include subSpritees, children of the sprite, and the animator.
	     *
	     * If you want to copy just the sprite, reusing it's graphics and material while not
	     * cloning it's children, the simplest way is to create a new sprite manually:
	     *
	     * <code>
	     * var clone : Sprite = new Sprite(original.graphics, original.material);
	     * </code>
	     */
	    Sprite.prototype.clone = function () {
	        var newInstance = (Sprite._sprites.length) ? Sprite._sprites.pop() : new Sprite();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    Sprite.prototype.copyTo = function (sprite) {
	        _super.prototype.copyTo.call(this, sprite);
	        this._graphics.copyTo(sprite.graphics);
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    Sprite.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.union(this._graphics.getBoxBounds(), this._pBoxBounds);
	    };
	    Sprite.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        var box = this.getBox();
	        if (!this._center)
	            this._center = new Vector3D_1.default();
	        this._center.x = box.x + box.width / 2;
	        this._center.y = box.y + box.height / 2;
	        this._center.z = box.z + box.depth / 2;
	        this._pSphereBounds = this._graphics.getSphereBounds(this._center, this._pSphereBounds);
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    Sprite.prototype._onGraphicsInvalidate = function (event) {
	        if (this._pIsEntity != Boolean(this._graphics.count)) {
	            if (this._pImplicitPartition)
	                this._pImplicitPartition._iUnregisterEntity(this);
	            this._pIsEntity = Boolean(this._graphics.count);
	            if (this._pImplicitPartition)
	                this._pImplicitPartition._iRegisterEntity(this);
	        }
	        this._pInvalidateBounds();
	    };
	    /**
	     *
	     * @param renderer
	     *
	     * @internal
	     */
	    Sprite.prototype._acceptTraverser = function (traverser) {
	        this.graphics.acceptTraverser(traverser);
	    };
	    Sprite.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        if (this._graphics.count) {
	            this._tempPoint.setTo(x, y);
	            var local = this.globalToLocal(this._tempPoint, this._tempPoint);
	            var box;
	            //early out for box test
	            if (!(box = this.getBox()).contains(local.x, local.y, 0))
	                return false;
	            //early out for non-shape tests
	            if (!shapeFlag)
	                return true;
	            //ok do the graphics thing
	            if (this._graphics._hitTestPointInternal(local.x, local.y))
	                return true;
	        }
	        return _super.prototype._hitTestPointInternal.call(this, x, y, shapeFlag, masksFlag);
	    };
	    Sprite.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        this._graphics.clear();
	    };
	    Sprite._sprites = new Array();
	    Sprite.assetType = "[asset Sprite]";
	    return Sprite;
	}(DisplayObjectContainer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Sprite;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Box_1 = __webpack_require__(29);
	var AssetBase_1 = __webpack_require__(24);
	var Graphic_1 = __webpack_require__(75);
	var ElementsEvent_1 = __webpack_require__(78);
	var StyleEvent_1 = __webpack_require__(77);
	var ElementsUtils_1 = __webpack_require__(79);
	/**
	 *
	 * Graphics is a collection of SubGeometries, each of which contain the actual geometrical data such as vertices,
	 * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
	 * A Graphics object is assigned to a Sprite, a scene graph occurence of the geometry, which in turn assigns
	 * the SubGeometries to its respective TriangleGraphic objects.
	 *
	 *
	 *
	 * @see away.core.base.SubGraphics
	 * @see away.entities.Sprite
	 *
	 * @class Graphics
	 */
	var Graphics = (function (_super) {
	    __extends(Graphics, _super);
	    /**
	     * Creates a new Graphics object.
	     */
	    function Graphics() {
	        var _this = this;
	        _super.call(this);
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        this._graphics = new Array();
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
	    }
	    Object.defineProperty(Graphics.prototype, "assetType", {
	        get: function () {
	            return Graphics.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "count", {
	        get: function () {
	            return this._graphics.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "animator", {
	        /**
	         * Defines the animator of the graphics object.  Default value is <code>null</code>.
	         */
	        get: function () {
	            return this._animator;
	        },
	        set: function (value) {
	            this._animator = value;
	            var len = this._graphics.length;
	            var graphic;
	            for (var i = 0; i < len; ++i) {
	                graphic = this._graphics[i];
	                // cause material to be unregistered and registered again to work with the new animation type (if possible)
	                if (graphic.material) {
	                    graphic.material.iRemoveOwner(graphic);
	                    graphic.material.iAddOwner(graphic);
	                }
	                //invalidate any existing graphic objects in case they need to pull new elements
	                graphic.invalidateElements();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._iInvalidateSurfaces();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "material", {
	        /**
	         * The material with which to render the Graphics.
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            var i;
	            var len = this._graphics.length;
	            var graphic;
	            if (this._material)
	                for (i = 0; i < len; i++)
	                    if (!(graphic = this._graphics[i])._iGetExplicitMaterial())
	                        this._material.iRemoveOwner(graphic);
	            this._material = value;
	            if (this._material)
	                for (i = 0; i < len; i++)
	                    if (!(graphic = this._graphics[i])._iGetExplicitMaterial())
	                        this._material.iAddOwner(graphic);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a GraphicBase wrapping a Elements.
	     *
	     * @param elements
	     */
	    Graphics.prototype.addGraphic = function (elements, material, style) {
	        if (material === void 0) { material = null; }
	        if (style === void 0) { style = null; }
	        var graphic;
	        if (Graphic_1.default._available.length) {
	            graphic = Graphic_1.default._available.pop();
	            graphic._iIndex = this._graphics.length;
	            graphic.parent = this;
	            graphic.elements = elements;
	            graphic.material = material;
	            graphic.style = style;
	        }
	        else {
	            graphic = new Graphic_1.default(this._graphics.length, this, elements, material, style);
	        }
	        this._graphics.push(graphic);
	        elements.addEventListener(ElementsEvent_1.default.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        this.invalidate();
	        return graphic;
	    };
	    Graphics.prototype.removeGraphic = function (graphic) {
	        this._graphics.splice(this._graphics.indexOf(graphic), 1);
	        graphic.elements.removeEventListener(ElementsEvent_1.default.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        graphic.elements = null;
	        graphic.material = null;
	        graphic.style = null;
	        graphic.clear();
	        this.invalidate();
	    };
	    Graphics.prototype.getGraphicAt = function (index) {
	        return this._graphics[index];
	    };
	    Graphics.prototype.applyTransformation = function (transform) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].elements.applyTransformation(transform);
	    };
	    Graphics.prototype.copyTo = function (graphics) {
	        graphics.material = this._material;
	        graphics.style = this.style;
	        graphics.particles = this.particles;
	        graphics.numParticles = this.numParticles;
	        var graphic;
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i) {
	            graphic = this._graphics[i];
	            graphics.addGraphic(graphic.elements, graphic._iGetExplicitMaterial(), graphic._iGetExplicitStyle());
	        }
	        if (this._animator)
	            graphics.animator = this._animator.clone();
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    Graphics.prototype.scale = function (scale) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].elements.scale(scale);
	    };
	    Graphics.prototype.clear = function () {
	        for (var i = this._graphics.length - 1; i >= 0; i--)
	            this._graphics[i].clear();
	    };
	    /**
	     * Clears all resources used by the Graphics object, including SubGeometries.
	     */
	    Graphics.prototype.dispose = function () {
	        this.material = null;
	        for (var i = this._graphics.length - 1; i >= 0; i--)
	            this._graphics[i].dispose();
	        if (this._animator)
	            this._animator.dispose();
	    };
	    /**
	     * Scales the uv coordinates (tiling)
	     * @param scaleU The amount by which to scale on the u axis. Default is 1;
	     * @param scaleV The amount by which to scale on the v axis. Default is 1;
	     */
	    Graphics.prototype.scaleUV = function (scaleU, scaleV) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].elements.scaleUV(scaleU, scaleV);
	    };
	    Graphics.prototype.getBoxBounds = function () {
	        if (this._boxBoundsInvalid) {
	            this._boxBoundsInvalid = false;
	            if (!this._boxBounds)
	                this._boxBounds = new Box_1.default();
	            if (this._graphics.length) {
	                this._boxBounds.setBoundIdentity();
	                var len = this._graphics.length;
	                for (var i = 0; i < len; i++)
	                    this._boxBounds = this._graphics[i].elements.getBoxBounds(this._boxBounds);
	            }
	            else {
	                this._boxBounds.setEmpty();
	            }
	        }
	        return this._boxBounds;
	    };
	    Graphics.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++)
	            target = this._graphics[i].elements.getSphereBounds(center, target);
	        return target;
	    };
	    Graphics.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	    };
	    Graphics.prototype._iInvalidateSurfaces = function () {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].invalidateSurface();
	    };
	    Graphics.prototype.invalidateElements = function () {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].invalidateElements();
	    };
	    Graphics.prototype._hitTestPointInternal = function (x, y) {
	        //TODO: handle lines as well
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++)
	            if (ElementsUtils_1.default.hitTestTriangleElements(x, y, 0, this.getBoxBounds(), this._graphics[i].elements))
	                return true;
	        return false;
	    };
	    Graphics.prototype.acceptTraverser = function (traverser) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++)
	            traverser.applyRenderable(this._graphics[i]);
	    };
	    Graphics.prototype._onInvalidateProperties = function (event) {
	        this._iInvalidateSurfaces();
	    };
	    Graphics.prototype._onInvalidateVertices = function (event) {
	        if (event.attributesView != event.target.positions)
	            return;
	        this.invalidate();
	    };
	    Graphics.assetType = "[asset Graphics]";
	    return Graphics;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Graphics;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var RenderableEvent_1 = __webpack_require__(76);
	var StyleEvent_1 = __webpack_require__(77);
	/**
	 * Graphic wraps a Elements as a scene graph instantiation. A Graphic is owned by a Sprite object.
	 *
	 *
	 * @see away.base.ElementsBase
	 * @see away.entities.Sprite
	 *
	 * @class away.base.Graphic
	 */
	var Graphic = (function (_super) {
	    __extends(Graphic, _super);
	    /**
	     * Creates a new Graphic object
	     */
	    function Graphic(index, parent, elements, material, style) {
	        var _this = this;
	        if (material === void 0) { material = null; }
	        if (style === void 0) { style = null; }
	        _super.call(this);
	        this._iIndex = 0;
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._iIndex = index;
	        this.parent = parent;
	        this.elements = elements;
	        this.material = material;
	        this.style = style;
	    }
	    Object.defineProperty(Graphic.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Graphic.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "animator", {
	        /**
	         *
	         */
	        get: function () {
	            return this.parent.animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "material", {
	        //TODO test shader picking
	        //		public get shaderPickingDetails():boolean
	        //		{
	        //
	        //			return this.sourceEntity.shaderPickingDetails;
	        //		}
	        /**
	         * The material used to render the current TriangleGraphic. If set to null, its parent Sprite's material will be used instead.
	         */
	        get: function () {
	            return this._material || this.parent.material;
	        },
	        set: function (value) {
	            if (this.material)
	                this.material.iRemoveOwner(this);
	            this._material = value;
	            if (this.material)
	                this.material.iAddOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "style", {
	        /**
	         * The style used to render the current TriangleGraphic. If set to null, its parent Sprite's style will be used instead.
	         */
	        get: function () {
	            return this._style || this.parent.style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this.invalidateSurface();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Graphic.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this.parent.removeGraphic(this);
	        this.parent = null;
	        Graphic._available.push(this);
	    };
	    Graphic.prototype.invalidateElements = function () {
	        this.dispatchEvent(new RenderableEvent_1.default(RenderableEvent_1.default.INVALIDATE_ELEMENTS, this));
	    };
	    Graphic.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.default(RenderableEvent_1.default.INVALIDATE_RENDER_OWNER, this));
	    };
	    Graphic.prototype._iGetExplicitMaterial = function () {
	        return this._material;
	    };
	    Graphic.prototype._iGetExplicitStyle = function () {
	        return this._style;
	    };
	    Graphic.prototype._onInvalidateProperties = function (event) {
	        this.invalidateSurface();
	    };
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @param findClosest
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Graphic.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return this.elements._iTestCollision(pickingCollider, this.material, pickingCollision);
	    };
	    Graphic._available = new Array();
	    Graphic.assetType = "[asset Graphic]";
	    return Graphic;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Graphic;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * Dispatched to notify changes in a sub geometry object's state.
	 *
	 * @class away.events.RenderableEvent
	 * @see away.core.base.Graphics
	 */
	var RenderableEvent = (function (_super) {
	    __extends(RenderableEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param dataType An optional data type of the vertex data being updated.
	     */
	    function RenderableEvent(type, renderable) {
	        _super.call(this, type);
	        this._renderable = renderable;
	    }
	    Object.defineProperty(RenderableEvent.prototype, "renderable", {
	        /**
	         * The renderobject owner of the renderable owner.
	         */
	        get: function () {
	            return this._renderable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    RenderableEvent.prototype.clone = function () {
	        return new RenderableEvent(this.type, this._renderable);
	    };
	    /**
	     * Dispatched when a Renderable owners's render object owner has been updated.
	     */
	    RenderableEvent.INVALIDATE_RENDER_OWNER = "invalidateRenderable";
	    /**
	     *
	     */
	    RenderableEvent.INVALIDATE_ELEMENTS = "invalidateElements";
	    return RenderableEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RenderableEvent;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var StyleEvent = (function (_super) {
	    __extends(StyleEvent, _super);
	    function StyleEvent(type, style) {
	        _super.call(this, type);
	        this._style = style;
	    }
	    Object.defineProperty(StyleEvent.prototype, "style", {
	        get: function () {
	            return this._style;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    StyleEvent.prototype.clone = function () {
	        return new StyleEvent(this.type, this._style);
	    };
	    /**
	     *
	     */
	    StyleEvent.INVALIDATE_PROPERTIES = "invalidateProperties";
	    return StyleEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StyleEvent;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * Dispatched to notify changes in a sub geometry object's state.
	 *
	 * @class away.events.ElementsEvent
	 * @see away.core.base.Graphics
	 */
	var ElementsEvent = (function (_super) {
	    __extends(ElementsEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param attributesView An optional data type of the vertex data being updated.
	     */
	    function ElementsEvent(type, attributesView) {
	        _super.call(this, type);
	        this._attributesView = attributesView;
	    }
	    Object.defineProperty(ElementsEvent.prototype, "attributesView", {
	        /**
	         * The attributes view of the vertex data.
	         */
	        get: function () {
	            return this._attributesView;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    ElementsEvent.prototype.clone = function () {
	        return new ElementsEvent(this.type, this._attributesView);
	    };
	    /**
	     * Dispatched when a Elements's index data has been updated.
	     */
	    ElementsEvent.INVALIDATE_INDICES = "invalidateIndices";
	    /**
	     * Dispatched when a Elements's index data has been disposed.
	     */
	    ElementsEvent.CLEAR_INDICES = "clearIndices";
	    /**
	     * Dispatched when a Elements's vertex data has been updated.
	     */
	    ElementsEvent.INVALIDATE_VERTICES = "invalidateVertices";
	    /**
	     * Dispatched when a Elements's vertex data has been disposed.
	     */
	    ElementsEvent.CLEAR_VERTICES = "clearVertices";
	    return ElementsEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ElementsEvent;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AttributesBuffer_1 = __webpack_require__(80);
	var Float3Attributes_1 = __webpack_require__(81);
	var Float4Attributes_1 = __webpack_require__(83);
	var Byte4Attributes_1 = __webpack_require__(84);
	var Vector3D_1 = __webpack_require__(30);
	var Box_1 = __webpack_require__(29);
	var Sphere_1 = __webpack_require__(48);
	var ElementsUtils = (function () {
	    function ElementsUtils() {
	    }
	    ElementsUtils.generateFaceNormals = function (indexAttributes, positionAttributes, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var indices = indexAttributes.get(count, offset);
	        var positions = positionAttributes.get(positionAttributes.count);
	        if (output == null)
	            output = new Float4Attributes_1.default(count + offset);
	        else if (output.count < count + offset)
	            output.count = count + offset;
	        var indexDim = indexAttributes.dimensions;
	        var positionDim = positionAttributes.dimensions;
	        var faceNormals = output.get(count, offset);
	        //multiply by dimension to get index length
	        count *= indexDim;
	        var i = 0;
	        var j = 0;
	        var index;
	        var x1, x2, x3;
	        var y1, y2, y3;
	        var z1, z2, z3;
	        var dx1, dy1, dz1;
	        var dx2, dy2, dz2;
	        var cx, cy, cz;
	        var d;
	        if (positionDim == 3) {
	            while (i < count) {
	                index = indices[i++] * 3;
	                x1 = positions[index];
	                y1 = positions[index + 1];
	                z1 = positions[index + 2];
	                index = indices[i++] * 3;
	                x2 = positions[index];
	                y2 = positions[index + 1];
	                z2 = positions[index + 2];
	                index = indices[i++] * 3;
	                x3 = positions[index];
	                y3 = positions[index + 1];
	                z3 = positions[index + 2];
	                dx1 = x3 - x1;
	                dy1 = y3 - y1;
	                dz1 = z3 - z1;
	                dx2 = x2 - x1;
	                dy2 = y2 - y1;
	                dz2 = z2 - z1;
	                cx = dz1 * dy2 - dy1 * dz2;
	                cy = dx1 * dz2 - dz1 * dx2;
	                cz = dy1 * dx2 - dx1 * dy2;
	                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
	                // length of cross product = 2*triangle area
	                faceNormals[j++] = cx;
	                faceNormals[j++] = cy;
	                faceNormals[j++] = cz;
	                faceNormals[j++] = d;
	            }
	        }
	        else if (positionDim == 2) {
	            while (i < count) {
	                faceNormals[j++] = 0;
	                faceNormals[j++] = 0;
	                faceNormals[j++] = 1;
	                faceNormals[j++] = 1;
	                i += 3;
	            }
	        }
	        output.set(faceNormals, offset);
	        return output;
	    };
	    ElementsUtils.generateNormals = function (indexAttributes, faceNormalAttributes, output, concatenatedBuffer) {
	        var indices = indexAttributes.get(indexAttributes.count);
	        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
	        if (output == null)
	            output = new Float3Attributes_1.default(concatenatedBuffer);
	        var indexDim = indexAttributes.dimensions;
	        var outputDim = output.dimensions;
	        var normals = output.get(output.count);
	        var i = 0;
	        var len = output.count * outputDim;
	        //clear normal values
	        while (i < len) {
	            normals[i++] = 0;
	            normals[i++] = 0;
	            normals[i++] = 0;
	        }
	        i = 0;
	        len = indexAttributes.count * indexDim;
	        var index;
	        var f1 = 0;
	        var f2 = 1;
	        var f3 = 2;
	        //collect face normals
	        while (i < len) {
	            index = indices[i++] * outputDim;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            index = indices[i++] * outputDim;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            index = indices[i++] * outputDim;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            f1 += 4;
	            f2 += 4;
	            f3 += 4;
	        }
	        i = 0;
	        len = output.count * outputDim;
	        var vx;
	        var vy;
	        var vz;
	        var d;
	        //normalise normals collections
	        while (i < len) {
	            vx = normals[i];
	            vy = normals[i + 1];
	            vz = normals[i + 2];
	            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
	            normals[i++] = vx * d;
	            normals[i++] = vy * d;
	            normals[i++] = vz * d;
	        }
	        output.set(normals);
	        return output;
	    };
	    ElementsUtils.generateFaceTangents = function (indexAttributes, positionAttributes, uvAttributes, output, count, offset, useFaceWeights) {
	        if (offset === void 0) { offset = 0; }
	        if (useFaceWeights === void 0) { useFaceWeights = false; }
	        var indices = indexAttributes.get(count, offset);
	        var positions = positionAttributes.get(positionAttributes.count);
	        var uvs = uvAttributes.get(uvAttributes.count);
	        if (output == null)
	            output = new Float3Attributes_1.default(count + offset);
	        else if (output.count < count + offset)
	            output.count = count + offset;
	        var positionDim = positionAttributes.dimensions;
	        var uvDim = uvAttributes.dimensions;
	        var indexDim = indexAttributes.dimensions;
	        var faceTangents = output.get(count, offset);
	        var i = 0;
	        var index1;
	        var index2;
	        var index3;
	        var v0;
	        var v1;
	        var v2;
	        var dv1;
	        var dv2;
	        var denom;
	        var x0, y0, z0;
	        var dx1, dy1, dz1;
	        var dx2, dy2, dz2;
	        var cx, cy, cz;
	        //multiply by dimension to get index length
	        count *= indexDim;
	        while (i < count) {
	            index1 = indices[i];
	            index2 = indices[i + 1];
	            index3 = indices[i + 2];
	            v0 = uvs[index1 * uvDim + 1];
	            dv1 = uvs[index2 * uvDim + 1] - v0;
	            dv2 = uvs[index3 * uvDim + 1] - v0;
	            v0 = index1 * positionDim;
	            v1 = index2 * positionDim;
	            v2 = index3 * positionDim;
	            x0 = positions[v0];
	            dx1 = positions[v1] - x0;
	            dx2 = positions[v2] - x0;
	            cx = dv2 * dx1 - dv1 * dx2;
	            y0 = positions[v0 + 1];
	            dy1 = positions[v1 + 1] - y0;
	            dy2 = positions[v2 + 1] - y0;
	            cy = dv2 * dy1 - dv1 * dy2;
	            if (positionDim == 3) {
	                z0 = positions[v0 + 2];
	                dz1 = positions[v1 + 2] - z0;
	                dz2 = positions[v2 + 2] - z0;
	                cz = dv2 * dz1 - dv1 * dz2;
	            }
	            else {
	                cz = 0;
	            }
	            denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
	            faceTangents[i++] = denom * cx;
	            faceTangents[i++] = denom * cy;
	            faceTangents[i++] = denom * cz;
	        }
	        output.set(faceTangents, offset);
	        return output;
	    };
	    ElementsUtils.generateTangents = function (indexAttributes, faceTangentAttributes, faceNormalAttributes, output, concatenatedBuffer) {
	        var indices = indexAttributes.get(indexAttributes.count);
	        var faceTangents = faceTangentAttributes.get(faceTangentAttributes.count);
	        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
	        if (output == null)
	            output = new Float3Attributes_1.default(concatenatedBuffer);
	        var indexDim = indexAttributes.dimensions;
	        var outputDim = output.dimensions;
	        var tangents = output.get(output.count);
	        var i = 0;
	        var len = output.count * outputDim;
	        //clear tangent values
	        while (i < len) {
	            tangents[i++] = 0;
	            tangents[i++] = 0;
	            tangents[i++] = 0;
	        }
	        var weight;
	        var index;
	        var f1 = 0;
	        var f2 = 1;
	        var f3 = 2;
	        var f4 = 3;
	        i = 0;
	        len = indexAttributes.count * indexDim;
	        //collect face tangents
	        while (i < len) {
	            weight = faceNormals[f4];
	            index = indices[i++] * outputDim;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            index = indices[i++] * outputDim;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            index = indices[i++] * outputDim;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            f1 += 3;
	            f2 += 3;
	            f3 += 3;
	            f4 += 4;
	        }
	        i = 0;
	        len = output.count * outputDim;
	        var vx;
	        var vy;
	        var vz;
	        var d;
	        //normalise tangents collections
	        while (i < len) {
	            vx = tangents[i];
	            vy = tangents[i + 1];
	            vz = tangents[i + 2];
	            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
	            tangents[i++] = vx * d;
	            tangents[i++] = vy * d;
	            tangents[i++] = vz * d;
	        }
	        output.set(tangents);
	        return output;
	    };
	    ElementsUtils.generateColors = function (indexAttributes, output, concatenatedBuffer, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (output == null)
	            output = new Byte4Attributes_1.default(concatenatedBuffer);
	        var index = 0;
	        var colors = new Uint8Array(count * 4);
	        while (index < count * 4) {
	            if (index / 4 & 1) {
	                colors[index] = 0xFF;
	                colors[index + 1] = 0xFF;
	                colors[index + 2] = 0xFF;
	                colors[index + 3] = 0xFF;
	            }
	            else {
	                colors[index] = 0xFF;
	                colors[index + 1] = 0xFF;
	                colors[index + 2] = 0xFF;
	                colors[index + 3] = 0xFF;
	            }
	            index += 4;
	        }
	        output.set(colors, offset);
	        return output;
	    };
	    ElementsUtils.scaleUVs = function (scaleU, scaleV, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (output.count < count + offset)
	            output.count = count + offset;
	        var outputDim = output.dimensions;
	        var uvs = output.get(count, offset);
	        var i = 0;
	        var j = 0;
	        var len = count * outputDim;
	        while (i < len) {
	            uvs[i++] *= scaleU;
	            uvs[i++] *= scaleV;
	        }
	        output.set(uvs, offset);
	    };
	    ElementsUtils.scale = function (scale, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (output.count < count + offset)
	            output.count = count + offset;
	        var outputDim = output.dimensions;
	        var positions = output.get(count, offset);
	        var i = 0;
	        var j = 0;
	        var len = count * outputDim;
	        while (i < len) {
	            positions[i++] *= scale;
	            positions[i++] *= scale;
	            positions[i++] *= scale;
	        }
	        output.set(positions, offset);
	    };
	    ElementsUtils.applyTransformation = function (transform, positionAttributes, normalAttributes, tangentAttributes, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        //todo: make this compatible with 2-dimensional positions
	        var positions = positionAttributes.get(count, offset);
	        var positionDim = positionAttributes.dimensions;
	        var normals;
	        var normalDim;
	        if (normalAttributes) {
	            normals = normalAttributes.get(count, offset);
	            normalDim = normalAttributes.dimensions;
	        }
	        var tangents;
	        var tangentDim;
	        if (tangentAttributes) {
	            tangents = tangentAttributes.get(count, offset);
	            tangentDim = tangentAttributes.dimensions;
	        }
	        var i;
	        var i1;
	        var i2;
	        var vector = new Vector3D_1.default();
	        var invTranspose;
	        if (normalAttributes || tangentAttributes) {
	            invTranspose = transform.clone();
	            invTranspose.invert();
	            invTranspose.transpose();
	        }
	        var vi0 = 0;
	        var ni0 = 0;
	        var ti0 = 0;
	        for (i = 0; i < count; ++i) {
	            // bake position
	            i1 = vi0 + 1;
	            i2 = vi0 + 2;
	            vector.x = positions[vi0];
	            vector.y = positions[i1];
	            vector.z = positions[i2];
	            vector = transform.transformVector(vector);
	            positions[vi0] = vector.x;
	            positions[i1] = vector.y;
	            positions[i2] = vector.z;
	            vi0 += positionDim;
	            if (normals) {
	                // bake normal
	                i1 = ni0 + 1;
	                i2 = ni0 + 2;
	                vector.x = normals[ni0];
	                vector.y = normals[i1];
	                vector.z = normals[i2];
	                vector = invTranspose.deltaTransformVector(vector);
	                vector.normalize();
	                normals[ni0] = vector.x;
	                normals[i1] = vector.y;
	                normals[i2] = vector.z;
	                ni0 += normalDim;
	            }
	            if (tangents) {
	                // bake tangent
	                i1 = ti0 + 1;
	                i2 = ti0 + 2;
	                vector.x = tangents[ti0];
	                vector.y = tangents[i1];
	                vector.z = tangents[i2];
	                vector = invTranspose.deltaTransformVector(vector);
	                vector.normalize();
	                tangents[ti0] = vector.x;
	                tangents[i1] = vector.y;
	                tangents[i2] = vector.z;
	                ti0 += tangentDim;
	            }
	        }
	        positionAttributes.set(positions, offset);
	        if (normalAttributes)
	            normalAttributes.set(normals, offset);
	        if (tangentAttributes)
	            tangentAttributes.set(tangents, offset);
	    };
	    ElementsUtils.getSubIndices = function (indexAttributes, numVertices, indexMappings, indexOffset) {
	        if (indexOffset === void 0) { indexOffset = 0; }
	        var buffer = indexAttributes.buffer;
	        var numIndices = indexAttributes.length;
	        //reset mappings
	        indexMappings.length = 0;
	        //shortcut for those buffers that fit into the maximum buffer sizes
	        if (numIndices < ElementsUtils.LIMIT_INDICES && numVertices < ElementsUtils.LIMIT_VERTS)
	            return buffer;
	        var i;
	        var indices = indexAttributes.get(indexAttributes.count, indexOffset);
	        var splitIndices = new Array();
	        var indexSwap = ElementsUtils._indexSwap;
	        indexSwap.length = numIndices;
	        for (i = 0; i < numIndices; i++)
	            indexSwap[i] = -1;
	        var originalIndex;
	        var splitIndex;
	        var index = 0;
	        var offsetLength = indexOffset * indexAttributes.dimensions;
	        // Loop over all triangles
	        i = 0;
	        while (i < numIndices + offsetLength && i + 1 < ElementsUtils.LIMIT_INDICES && index + 1 < ElementsUtils.LIMIT_VERTS) {
	            originalIndex = indices[i];
	            if (indexSwap[originalIndex] >= 0) {
	                splitIndex = indexSwap[originalIndex];
	            }
	            else {
	                // This vertex does not yet exist in the split list and
	                // needs to be copied from the long list.
	                splitIndex = index++;
	                indexSwap[originalIndex] = splitIndex;
	                indexMappings[splitIndex] = originalIndex;
	            }
	            // Store new index, which may have come from the swap look-up,
	            // or from copying a new set of vertex data from the original vector
	            splitIndices[i++] = splitIndex;
	        }
	        buffer = new AttributesBuffer_1.default(indexAttributes.size * indexAttributes.dimensions, splitIndices.length / indexAttributes.dimensions);
	        indexAttributes = indexAttributes.clone(buffer);
	        indexAttributes.set(splitIndices);
	        return buffer;
	    };
	    ElementsUtils.getSubVertices = function (vertexBuffer, indexMappings) {
	        if (!indexMappings.length)
	            return vertexBuffer;
	        var stride = vertexBuffer.stride;
	        var vertices = vertexBuffer.bufferView;
	        var splitVerts = new Uint8Array(indexMappings.length * stride);
	        var splitIndex;
	        var originalIndex;
	        var i = 0;
	        var j = 0;
	        var len = indexMappings.length;
	        for (i = 0; i < len; i++) {
	            splitIndex = i * stride;
	            originalIndex = indexMappings[i] * stride;
	            for (j = 0; j < stride; j++)
	                splitVerts[splitIndex + j] = vertices[originalIndex + j];
	        }
	        vertexBuffer = new AttributesBuffer_1.default(stride, len);
	        vertexBuffer.bufferView = splitVerts;
	        return vertexBuffer;
	    };
	    //TODO - generate this dyanamically based on num tris
	    ElementsUtils.hitTestTriangleElements = function (x, y, z, boundingBox, triangleElements) {
	        var positionAttributes = triangleElements.positions;
	        var curveAttributes = triangleElements.getCustomAtributes("curves");
	        var count = triangleElements.numVertices;
	        var posDim = positionAttributes.dimensions;
	        var curveDim = curveAttributes.dimensions;
	        var positions = positionAttributes.get(count);
	        var curves = curveAttributes ? curveAttributes.get(count) : null;
	        var id0;
	        var id1;
	        var id2;
	        var ax;
	        var ay;
	        var bx;
	        var by;
	        var cx;
	        var cy;
	        var index = triangleElements.lastCollisionIndex;
	        if (index != -1 && index < count) {
	            precheck: {
	                id0 = index + 2;
	                id1 = index + 1;
	                id2 = index + 0;
	                ax = positions[id0 * posDim];
	                ay = positions[id0 * posDim + 1];
	                bx = positions[id1 * posDim];
	                by = positions[id1 * posDim + 1];
	                cx = positions[id2 * posDim];
	                cy = positions[id2 * posDim + 1];
	                //console.log(ax, ay, bx, by, cx, cy);
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                //console.log(ax,ay,bx,by,cx,cy);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                if (curves) {
	                    var curvey0 = curves[id0 * curveDim + 2];
	                    var curvey1 = curves[id1 * curveDim + 2];
	                    var curvey2 = curves[id2 * curveDim + 2];
	                    //check if not solid
	                    if (curvey0 || curvey1 || curvey2) {
	                        var v0x = bx - ax;
	                        var v0y = by - ay;
	                        var v1x = cx - ax;
	                        var v1y = cy - ay;
	                        var v2x = x - ax;
	                        var v2y = y - ay;
	                        var den = v0x * v1y - v1x * v0y;
	                        var v = (v2x * v1y - v1x * v2y) / den;
	                        var w = (v0x * v2y - v2x * v0y) / den;
	                        //var u:number = 1 - v - w;	//commented out as inlined away
	                        //here be dragons
	                        var uu = 0.5 * v + w;
	                        var vv = w;
	                        var d = uu * uu - vv;
	                        var az = curves[id0 * curveDim];
	                        if (d > 0 && az == -128) {
	                            break precheck;
	                            ;
	                        }
	                        else if (d < 0 && az == 127) {
	                            break precheck;
	                            ;
	                        }
	                    }
	                }
	                return true;
	            }
	        }
	        //hard coded min vertex count to bother using a grid for
	        if (count > 150) {
	            var cells = triangleElements.cells;
	            var divisions = cells.length ? triangleElements.divisions : (triangleElements.divisions = Math.min(Math.ceil(Math.sqrt(count)), 32));
	            var conversionX = divisions / boundingBox.width;
	            var conversionY = divisions / boundingBox.height;
	            var minx = boundingBox.x;
	            var miny = boundingBox.y;
	            if (!cells.length) {
	                //now we have bounds start creating grid cells and filling
	                cells.length = divisions * divisions;
	                for (var k = 0; k < count; k += 3) {
	                    id0 = k + 2;
	                    id1 = k + 1;
	                    id2 = k + 0;
	                    ax = positions[id0 * posDim];
	                    ay = positions[id0 * posDim + 1];
	                    bx = positions[id1 * posDim];
	                    by = positions[id1 * posDim + 1];
	                    cx = positions[id2 * posDim];
	                    cy = positions[id2 * posDim + 1];
	                    //subtractions to push into positive space
	                    var min_index_x = Math.floor((Math.min(ax, bx, cx) - minx) * conversionX);
	                    var min_index_y = Math.floor((Math.min(ay, by, cy) - miny) * conversionY);
	                    var max_index_x = Math.floor((Math.max(ax, bx, cx) - minx) * conversionX);
	                    var max_index_y = Math.floor((Math.max(ay, by, cy) - miny) * conversionY);
	                    for (var i = min_index_x; i <= max_index_x; i++) {
	                        for (var j = min_index_y; j <= max_index_y; j++) {
	                            var index = i + j * divisions;
	                            var nodes = cells[index] || (cells[index] = new Array());
	                            //push in the triangle ids
	                            nodes.push(id0, id1, id2);
	                        }
	                    }
	                }
	            }
	            var index_x = Math.floor((x - minx) * conversionX);
	            var index_y = Math.floor((y - miny) * conversionY);
	            if ((index_x < 0 || index_x > divisions || index_y < 0 || index_y > divisions))
	                return false;
	            var nodes = cells[index_x + index_y * divisions];
	            if (nodes == null)
	                return false;
	            var nodeCount = nodes.length;
	            for (var k = 0; k < nodeCount; k += 3) {
	                id0 = nodes[k];
	                id1 = nodes[k + 1];
	                id2 = nodes[k + 2];
	                if (id2 == index)
	                    continue;
	                ax = positions[id0 * posDim];
	                ay = positions[id0 * posDim + 1];
	                bx = positions[id1 * posDim];
	                by = positions[id1 * posDim + 1];
	                cx = positions[id2 * posDim];
	                cy = positions[id2 * posDim + 1];
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                if (curves) {
	                    var curvey0 = curves[id0 * curveDim + 2];
	                    var curvey1 = curves[id1 * curveDim + 2];
	                    var curvey2 = curves[id2 * curveDim + 2];
	                    //check if not solid
	                    if (curvey0 || curvey1 || curvey2) {
	                        var v0x = bx - ax;
	                        var v0y = by - ay;
	                        var v1x = cx - ax;
	                        var v1y = cy - ay;
	                        var v2x = x - ax;
	                        var v2y = y - ay;
	                        var den = v0x * v1y - v1x * v0y;
	                        var v = (v2x * v1y - v1x * v2y) / den;
	                        var w = (v0x * v2y - v2x * v0y) / den;
	                        //var u:number = 1 - v - w;	//commented out as inlined away
	                        //here be dragons
	                        var uu = 0.5 * v + w;
	                        var vv = w;
	                        var d = uu * uu - vv;
	                        var az = curves[id0 * curveDim];
	                        if (d > 0 && az == -128)
	                            continue;
	                        else if (d < 0 && az == 127)
	                            continue;
	                    }
	                }
	                triangleElements.lastCollisionIndex = id2;
	                return true;
	            }
	            return false;
	        }
	        //brute force
	        for (var k = 0; k < count; k += 3) {
	            id0 = k + 2;
	            id1 = k + 1;
	            id2 = k + 0;
	            if (id2 == index)
	                continue;
	            ax = positions[id0 * posDim];
	            ay = positions[id0 * posDim + 1];
	            bx = positions[id1 * posDim];
	            by = positions[id1 * posDim + 1];
	            cx = positions[id2 * posDim];
	            cy = positions[id2 * posDim + 1];
	            //console.log(ax, ay, bx, by, cx, cy);
	            //from a to p
	            var dx = ax - x;
	            var dy = ay - y;
	            //edge normal (a-b)
	            var nx = by - ay;
	            var ny = -(bx - ax);
	            //console.log(ax,ay,bx,by,cx,cy);
	            var dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = bx - x;
	            dy = by - y;
	            nx = cy - by;
	            ny = -(cx - bx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = cx - x;
	            dy = cy - y;
	            nx = ay - cy;
	            ny = -(ax - cx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            if (curves) {
	                var curvey0 = curves[id0 * curveDim + 2];
	                var curvey1 = curves[id1 * curveDim + 2];
	                var curvey2 = curves[id2 * curveDim + 2];
	                //check if not solid
	                if (curvey0 || curvey1 || curvey2) {
	                    var v0x = bx - ax;
	                    var v0y = by - ay;
	                    var v1x = cx - ax;
	                    var v1y = cy - ay;
	                    var v2x = x - ax;
	                    var v2y = y - ay;
	                    var den = v0x * v1y - v1x * v0y;
	                    var v = (v2x * v1y - v1x * v2y) / den;
	                    var w = (v0x * v2y - v2x * v0y) / den;
	                    //var u:number = 1 - v - w;	//commented out as inlined away
	                    //here be dragons
	                    var uu = 0.5 * v + w;
	                    var vv = w;
	                    var d = uu * uu - vv;
	                    var az = curves[id0 * curveDim];
	                    if (d > 0 && az == -128) {
	                        continue;
	                    }
	                    else if (d < 0 && az == 127) {
	                        continue;
	                    }
	                }
	            }
	            triangleElements.lastCollisionIndex = id2;
	            return true;
	        }
	        return false;
	    };
	    ElementsUtils.getTriangleGraphicsBoxBounds = function (positionAttributes, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var positions = positionAttributes.get(count, offset);
	        var posDim = positionAttributes.dimensions;
	        if (output == null)
	            output = new Box_1.default();
	        var pos;
	        var minX = 0, minY = 0, minZ = 0;
	        var maxX = 0, maxY = 0, maxZ = 0;
	        var len = count * posDim;
	        for (var i = 0; i < len; i += posDim) {
	            if (i == 0) {
	                maxX = minX = positions[i];
	                maxY = minY = positions[i + 1];
	                maxZ = minZ = (posDim == 3) ? positions[i + 2] : 0;
	            }
	            else {
	                pos = positions[i];
	                if (pos < minX)
	                    minX = pos;
	                else if (pos > maxX)
	                    maxX = pos;
	                pos = positions[i + 1];
	                if (pos < minY)
	                    minY = pos;
	                else if (pos > maxY)
	                    maxY = pos;
	                if (posDim == 3) {
	                    pos = positions[i + 2];
	                    if (pos < minZ)
	                        minZ = pos;
	                    else if (pos > maxZ)
	                        maxZ = pos;
	                }
	            }
	        }
	        if (output.x > minX)
	            output.x = minX;
	        if (output.y > minY)
	            output.y = minY;
	        if (output.z > minZ)
	            output.z = minZ;
	        if (output.right < maxX)
	            output.right = maxX;
	        if (output.bottom < maxY)
	            output.bottom = maxY;
	        if (output.back < maxZ)
	            output.back = maxZ;
	        return output;
	    };
	    ElementsUtils.getTriangleGraphicsSphereBounds = function (positionAttributes, center, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var positions = positionAttributes.get(count, offset);
	        var posDim = positionAttributes.dimensions;
	        if (output == null)
	            output = new Sphere_1.default();
	        var maxRadiusSquared = 0;
	        var radiusSquared;
	        var len = count * posDim;
	        var distanceX;
	        var distanceY;
	        var distanceZ;
	        for (var i = 0; i < len; i += posDim) {
	            distanceX = positions[i] - center.x;
	            distanceY = positions[i + 1] - center.y;
	            distanceZ = (posDim == 3) ? positions[i + 2] - center.z : -center.z;
	            radiusSquared = distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ;
	            if (maxRadiusSquared < radiusSquared)
	                maxRadiusSquared = radiusSquared;
	        }
	        output.x = center.x;
	        output.y = center.y;
	        output.z = center.z;
	        output.radius = Math.sqrt(maxRadiusSquared);
	        return output;
	    };
	    ElementsUtils.tempFloat32x4 = new Float32Array(4);
	    ElementsUtils.LIMIT_VERTS = 0xffff;
	    ElementsUtils.LIMIT_INDICES = 0xffffff;
	    ElementsUtils._indexSwap = new Array();
	    return ElementsUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ElementsUtils;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var AttributesBuffer = (function (_super) {
	    __extends(AttributesBuffer, _super);
	    /**
	     *
	     */
	    function AttributesBuffer(stride, count) {
	        if (stride === void 0) { stride = 0; }
	        if (count === void 0) { count = 0; }
	        _super.call(this);
	        this._count = 0;
	        this._stride = 0;
	        this._newStride = 0;
	        this._viewVOs = new Array();
	        this._stride = this._newStride = stride;
	        this._count = count;
	        this._buffer = new ArrayBuffer(this._stride * this._count);
	        this._bufferView = new Uint8Array(this._buffer, 0, this._buffer.byteLength);
	    }
	    Object.defineProperty(AttributesBuffer.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return AttributesBuffer.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "stride", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            return this._stride;
	        },
	        set: function (value) {
	            if (this._newStride == value)
	                return;
	            this._newStride = value;
	            this.resize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "count", {
	        get: function () {
	            return this._count;
	        },
	        set: function (value) {
	            if (this._count == value)
	                return;
	            this._count = value;
	            this.resize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "buffer", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            this._contentDirty = false;
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "bufferView", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            this._contentDirty = false;
	            return this._bufferView;
	        },
	        set: function (value) {
	            this._bufferView = value;
	            this._buffer = this._bufferView.buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "length", {
	        get: function () {
	            return this._count * this.stride;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AttributesBuffer.prototype.invalidate = function () {
	        if (this._contentDirty)
	            return;
	        _super.prototype.invalidate.call(this);
	        this._contentDirty = true;
	    };
	    /**
	     *
	     * @private
	     */
	    AttributesBuffer.prototype.resize = function () {
	        if (this._lengthDirty)
	            return;
	        this.clear();
	        this._lengthDirty = true;
	        //dispose buffer if stride is 0
	        if (!this._newStride) {
	            this._buffer = null;
	            this._bufferView = null;
	        }
	    };
	    AttributesBuffer.prototype.clone = function () {
	        var attributesBuffer = new AttributesBuffer(this._stride, this._count);
	        attributesBuffer.bufferView.set(this.bufferView);
	        var len = this._viewVOs.length;
	        for (var i = 0; i < len; i++)
	            this._viewVOs[i].view._internalClone(attributesBuffer);
	        return attributesBuffer;
	    };
	    AttributesBuffer.prototype.getView = function (index) {
	        if (index < this._viewVOs.length)
	            return this._viewVOs[index].view;
	        return null;
	    };
	    AttributesBuffer.prototype._setAttributes = function (viewIndex, arrayBufferView, offset) {
	        if (offset === void 0) { offset = 0; }
	        var array = (arrayBufferView instanceof Uint8Array) ? arrayBufferView : new Uint8Array(arrayBufferView.buffer);
	        var viewVO = this._viewVOs[viewIndex];
	        var vLength = viewVO.length;
	        var vOffset = viewVO.offset;
	        var vCount = array.length / vLength;
	        //make sure there is enough space in the buffer
	        if (this.count < vCount + offset)
	            this.count = vCount + offset;
	        if (this._lengthDirty)
	            this._updateLength();
	        //fast path for separate buffers
	        if (this._viewVOs.length == 1) {
	            this._bufferView.set(array);
	        }
	        else {
	            for (var i = 0; i < vCount; i++)
	                this._bufferView.set(array.subarray(i * vLength, (i + 1) * vLength), (i + offset) * this._stride + vOffset);
	        }
	        this.invalidate();
	    };
	    AttributesBuffer.prototype._getLocalArrayBuffer = function (viewIndex) {
	        var viewVO = this._viewVOs[viewIndex];
	        var vLength = viewVO.length;
	        var vOffset = viewVO.offset;
	        if (this._lengthDirty)
	            this._updateLength();
	        //fast path for separate buffers
	        if (this._viewVOs.length == 1)
	            return this._buffer;
	        var localBuffer = new ArrayBuffer(this._count * vLength);
	        var localBufferView = new Uint8Array(localBuffer);
	        for (var i = 0; i < this._count; i++)
	            localBufferView.set(this._bufferView.subarray(i * this._stride + vOffset, i * this._stride + vOffset + vLength), i * vLength);
	        return localBuffer;
	    };
	    AttributesBuffer.prototype._addView = function (view) {
	        var viewVO = new ViewVO(view);
	        var len = this._viewVOs.length;
	        viewVO.offset = len ? this._viewVOs[len - 1].offset + this._viewVOs[len - 1].length : 0;
	        this._viewVOs.push(viewVO);
	        if (this._newStride < viewVO.offset + viewVO.length) {
	            this._newStride = viewVO.offset + viewVO.length;
	            this.resize();
	        }
	        view._index = len;
	    };
	    AttributesBuffer.prototype._removeView = function (view) {
	        var viewIndex = view._index;
	        var viewVO = this._viewVOs.splice(viewIndex, 1)[0];
	        var len = this._viewVOs.length;
	        viewVO.dispose();
	        for (var i = viewIndex; i < len; i++) {
	            viewVO = this._viewVOs[i];
	            viewVO.offset = i ? this._viewVOs[i - 1].offset + this._viewVOs[i - 1].length : 0;
	            viewVO.view._index = i;
	        }
	        this._newStride = viewVO.offset + viewVO.length;
	        this.resize();
	    };
	    AttributesBuffer.prototype._getOffset = function (viewIndex) {
	        return this._viewVOs[viewIndex].offset;
	    };
	    AttributesBuffer.prototype._updateLength = function () {
	        this._lengthDirty = false;
	        var i;
	        var j;
	        var len = this._viewVOs.length;
	        var newLength = this._newStride * this._count;
	        if (!this._buffer || this._buffer.byteLength != newLength) {
	            var newBuffer = new ArrayBuffer(newLength);
	            var newView = new Uint8Array(newBuffer, 0, newBuffer.byteLength);
	            var viewVO;
	            var vLength;
	            var vOffset;
	            var vOldOffset;
	            if (this._stride != this._newStride) {
	                for (i = 0; i < len; i++) {
	                    viewVO = this._viewVOs[i];
	                    vLength = viewVO.length;
	                    vOffset = viewVO.offset;
	                    vOldOffset = viewVO.oldOffset;
	                    for (j = 0; j < this._count; j++)
	                        if (vOldOffset != null)
	                            newView.set(new Uint8Array(this._buffer, j * this._stride + vOldOffset, vLength), j * this._newStride + vOffset);
	                    viewVO.oldOffset = viewVO.offset;
	                }
	                this._stride = this._newStride;
	            }
	            else {
	                newView.set(new Uint8Array(this._buffer, 0, Math.min(newLength, this._buffer.byteLength))); //TODO: bypass quantisation of bytearray on instantiation
	            }
	            this._buffer = newBuffer;
	            this._bufferView = newView;
	        }
	    };
	    AttributesBuffer.assetType = "[assets AttributesBuffer]";
	    return AttributesBuffer;
	}(AssetBase_1.default));
	var ViewVO = (function () {
	    function ViewVO(view) {
	        this.view = view;
	        this.length = view.size * view.dimensions;
	    }
	    ViewVO.prototype.dispose = function () {
	        this.view = null;
	    };
	    ViewVO.prototype.clone = function () {
	        return new ViewVO(this.view);
	    };
	    return ViewVO;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AttributesBuffer;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float3Attributes = (function (_super) {
	    __extends(Float3Attributes, _super);
	    function Float3Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 3, attributesBufferLength);
	    }
	    Object.defineProperty(Float3Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float3Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float3Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float3Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float3Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float3Attributes(attributesBuffer));
	    };
	    Float3Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float3Attributes.assetType = "[attributes Float3Attributes]";
	    return Float3Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Float3Attributes;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(80);
	var AssetBase_1 = __webpack_require__(24);
	var AttributesView = (function (_super) {
	    __extends(AttributesView, _super);
	    function AttributesView(arrayClass, dimensions, attributesBufferCount, unsigned) {
	        if (attributesBufferCount === void 0) { attributesBufferCount = 0; }
	        if (unsigned === void 0) { unsigned = false; }
	        _super.call(this);
	        this._arrayClass = arrayClass;
	        this._size = arrayClass.BYTES_PER_ELEMENT;
	        this._dimensions = dimensions;
	        this._attributesBuffer = (attributesBufferCount instanceof AttributesBuffer_1.default) ? attributesBufferCount : new AttributesBuffer_1.default(this._dimensions * this._size, attributesBufferCount);
	        this._attributesBuffer._addView(this);
	        this._unsigned = unsigned;
	    }
	    Object.defineProperty(AttributesView.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return AttributesView.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "buffer", {
	        get: function () {
	            return this._attributesBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "size", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._size;
	        },
	        set: function (value) {
	            if (this._size == value)
	                return;
	            this._size = value;
	            this._attributesBuffer._removeView(this);
	            this._attributesBuffer._addView(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "dimensions", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._dimensions;
	        },
	        set: function (value) {
	            if (this._dimensions == value)
	                return;
	            this._dimensions = value;
	            //reset view
	            this._attributesBuffer._removeView(this);
	            this._attributesBuffer._addView(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "unsigned", {
	        get: function () {
	            return this._unsigned;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "count", {
	        get: function () {
	            return this._attributesBuffer.count;
	        },
	        set: function (value) {
	            this._attributesBuffer.count = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "offset", {
	        get: function () {
	            return this._attributesBuffer._getOffset(this._index);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "length", {
	        get: function () {
	            return this._attributesBuffer.count * this._dimensions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AttributesView.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        this._attributesBuffer._setAttributes(this._index, (values instanceof Array) ? new (this._arrayClass)(values) : values, offset);
	        this._localArrayBuffer = null;
	    };
	    AttributesView.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (!this._localArrayBuffer)
	            this._localArrayBuffer = this._attributesBuffer._getLocalArrayBuffer(this._index);
	        var len = this._dimensions * this._size;
	        return new (this._arrayClass)(this._localArrayBuffer, offset * len, count * this._dimensions);
	    };
	    AttributesView.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new AttributesView(this._arrayClass, this._dimensions, attributesBuffer));
	    };
	    AttributesView.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        if (attributesBuffer)
	            this._internalClone(attributesBuffer);
	        if (!this._cloneCache)
	            this._attributesBuffer.clone();
	        var cloneCache = this._cloneCache;
	        this._cloneCache = null;
	        return cloneCache;
	    };
	    /**
	     * @inheritDoc
	     */
	    AttributesView.prototype.dispose = function () {
	        if (!this._attributesBuffer)
	            return;
	        this._attributesBuffer._removeView(this);
	        this._attributesBuffer = null;
	        this._localArrayBuffer = null;
	    };
	    AttributesView.assetType = "[attributes AttributesView]";
	    return AttributesView;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AttributesView;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float4Attributes = (function (_super) {
	    __extends(Float4Attributes, _super);
	    function Float4Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 4, attributesBufferLength);
	    }
	    Object.defineProperty(Float4Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float4Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float4Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float4Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float4Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float4Attributes(attributesBuffer));
	    };
	    Float4Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float4Attributes.assetType = "[attributes Float4Attributes]";
	    return Float4Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Float4Attributes;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Byte4Attributes = (function (_super) {
	    __extends(Byte4Attributes, _super);
	    function Byte4Attributes(attributesBufferLength, unsigned) {
	        if (unsigned === void 0) { unsigned = true; }
	        _super.call(this, unsigned ? Uint8Array : Int8Array, 4, attributesBufferLength, unsigned);
	    }
	    Object.defineProperty(Byte4Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Byte4Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Byte4Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Byte4Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Byte4Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Byte4Attributes(attributesBuffer, this._arrayClass == Uint8Array));
	    };
	    Byte4Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Byte4Attributes.assetType = "[attributes Byte4Attributes]";
	    return Byte4Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Byte4Attributes;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MathConsts_1 = __webpack_require__(31);
	var Vector3D_1 = __webpack_require__(30);
	var LookAtController_1 = __webpack_require__(86);
	/**
	 * Extended camera used to hover round a specified target object.
	 *
	 * @see    away.containers.View
	 */
	var HoverController = (function (_super) {
	    __extends(HoverController, _super);
	    /**
	     * Creates a new <code>HoverController</code> object.
	     */
	    function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        if (panAngle === void 0) { panAngle = 0; }
	        if (tiltAngle === void 0) { tiltAngle = 90; }
	        if (distance === void 0) { distance = 1000; }
	        if (minTiltAngle === void 0) { minTiltAngle = -90; }
	        if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
	        if (minPanAngle === void 0) { minPanAngle = null; }
	        if (maxPanAngle === void 0) { maxPanAngle = null; }
	        if (steps === void 0) { steps = 8; }
	        if (yFactor === void 0) { yFactor = 2; }
	        if (wrapPanAngle === void 0) { wrapPanAngle = false; }
	        _super.call(this, targetObject, lookAtObject);
	        this._iCurrentPanAngle = 0;
	        this._iCurrentTiltAngle = 90;
	        this._panAngle = 0;
	        this._tiltAngle = 90;
	        this._distance = 1000;
	        this._minPanAngle = -Infinity;
	        this._maxPanAngle = Infinity;
	        this._minTiltAngle = -90;
	        this._maxTiltAngle = 90;
	        this._steps = 8;
	        this._yFactor = 2;
	        this._wrapPanAngle = false;
	        this._upAxis = new Vector3D_1.default();
	        this.distance = distance;
	        this.panAngle = panAngle;
	        this.tiltAngle = tiltAngle;
	        this.minPanAngle = (minPanAngle != null) ? minPanAngle : -Infinity;
	        this.maxPanAngle = (maxPanAngle != null) ? maxPanAngle : Infinity;
	        this.minTiltAngle = minTiltAngle;
	        this.maxTiltAngle = maxTiltAngle;
	        this.steps = steps;
	        this.yFactor = yFactor;
	        this.wrapPanAngle = wrapPanAngle;
	        //values passed in contrustor are applied immediately
	        this._iCurrentPanAngle = this._panAngle;
	        this._iCurrentTiltAngle = this._tiltAngle;
	    }
	    Object.defineProperty(HoverController.prototype, "steps", {
	        /**
	         * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
	         *
	         * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
	         *
	         * @see    #tiltAngle
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._steps;
	        },
	        set: function (val) {
	            val = (val < 1) ? 1 : val;
	            if (this._steps == val)
	                return;
	            this._steps = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "panAngle", {
	        /**
	         * Rotation of the camera in degrees around the y axis. Defaults to 0.
	         */
	        get: function () {
	            return this._panAngle;
	        },
	        set: function (val) {
	            val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
	            if (this._panAngle == val)
	                return;
	            this._panAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "tiltAngle", {
	        /**
	         * Elevation angle of the camera in degrees. Defaults to 90.
	         */
	        get: function () {
	            return this._tiltAngle;
	        },
	        set: function (val) {
	            val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
	            if (this._tiltAngle == val)
	                return;
	            this._tiltAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "distance", {
	        /**
	         * Distance between the camera and the specified target. Defaults to 1000.
	         */
	        get: function () {
	            return this._distance;
	        },
	        set: function (val) {
	            if (this._distance == val)
	                return;
	            this._distance = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "minPanAngle", {
	        /**
	         * Minimum bounds for the <code>panAngle</code>. Defaults to -Infinity.
	         *
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._minPanAngle;
	        },
	        set: function (val) {
	            if (this._minPanAngle == val)
	                return;
	            this._minPanAngle = val;
	            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "maxPanAngle", {
	        /**
	         * Maximum bounds for the <code>panAngle</code>. Defaults to Infinity.
	         *
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._maxPanAngle;
	        },
	        set: function (val) {
	            if (this._maxPanAngle == val)
	                return;
	            this._maxPanAngle = val;
	            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "minTiltAngle", {
	        /**
	         * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._minTiltAngle;
	        },
	        set: function (val) {
	            if (this._minTiltAngle == val)
	                return;
	            this._minTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
	        /**
	         * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._maxTiltAngle;
	        },
	        set: function (val) {
	            if (this._maxTiltAngle == val)
	                return;
	            this._maxTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "yFactor", {
	        /**
	         * Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
	         *
	         * @see    #distance
	         */
	        get: function () {
	            return this._yFactor;
	        },
	        set: function (val) {
	            if (this._yFactor == val)
	                return;
	            this._yFactor = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
	        /**
	         * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
	         */
	        get: function () {
	            return this._wrapPanAngle;
	        },
	        set: function (val) {
	            if (this._wrapPanAngle == val)
	                return;
	            this._wrapPanAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates the current tilt angle and pan angle values.
	     *
	     * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
	     *
	     * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
	     *
	     * @see    #tiltAngle
	     * @see    #panAngle
	     * @see    #steps
	     */
	    HoverController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
	            this._pControllerDirty = true;
	            if (this._wrapPanAngle) {
	                if (this._panAngle < 0) {
	                    this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360 + 360;
	                }
	                else {
	                    this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360;
	                }
	                while (this._panAngle - this._iCurrentPanAngle < -180)
	                    this._iCurrentPanAngle -= 360;
	                while (this._panAngle - this._iCurrentPanAngle > 180)
	                    this._iCurrentPanAngle += 360;
	            }
	            if (interpolate) {
	                this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
	                this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
	            }
	            else {
	                this._iCurrentPanAngle = this._panAngle;
	                this._iCurrentTiltAngle = this._tiltAngle;
	            }
	            //snap coords if angle differences are close
	            if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
	                this._iCurrentTiltAngle = this._tiltAngle;
	                this._iCurrentPanAngle = this._panAngle;
	            }
	        }
	        var pos = (this.lookAtObject) ? this.lookAtObject.transform.position : (this.lookAtPosition) ? this.lookAtPosition : this._pOrigin;
	        this.targetObject.x = pos.x + this.distance * Math.sin(this._iCurrentPanAngle * MathConsts_1.default.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS);
	        this.targetObject.y = pos.y + this.distance * Math.sin(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS) * this.yFactor;
	        this.targetObject.z = pos.z + this.distance * Math.cos(this._iCurrentPanAngle * MathConsts_1.default.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS);
	        this._upAxis.x = -Math.sin(this._iCurrentPanAngle * MathConsts_1.default.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS);
	        this._upAxis.y = Math.cos(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS);
	        this._upAxis.z = -Math.cos(this._iCurrentPanAngle * MathConsts_1.default.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * MathConsts_1.default.DEGREES_TO_RADIANS);
	        if (this._pTargetObject) {
	            if (this._pLookAtPosition)
	                this._pTargetObject.lookAt(this._pLookAtPosition, this._upAxis);
	            else if (this._pLookAtObject)
	                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position, this._upAxis);
	        }
	    };
	    return HoverController;
	}(LookAtController_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = HoverController;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(30);
	var ControllerBase_1 = __webpack_require__(87);
	var DisplayObjectEvent_1 = __webpack_require__(56);
	var LookAtController = (function (_super) {
	    __extends(LookAtController, _super);
	    function LookAtController(targetObject, lookAtObject) {
	        var _this = this;
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        _super.call(this, targetObject);
	        this._pOrigin = new Vector3D_1.default(0.0, 0.0, 0.0);
	        this._onLookAtObjectChangedDelegate = function (event) { return _this.onLookAtObjectChanged(event); };
	        if (lookAtObject)
	            this.lookAtObject = lookAtObject;
	        else
	            this.lookAtPosition = new Vector3D_1.default();
	    }
	    Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
	        get: function () {
	            return this._pLookAtPosition;
	        },
	        set: function (val) {
	            if (this._pLookAtObject) {
	                this._pLookAtObject.removeEventListener(DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	                this._pLookAtObject = null;
	            }
	            this._pLookAtPosition = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LookAtController.prototype, "lookAtObject", {
	        get: function () {
	            return this._pLookAtObject;
	        },
	        set: function (val) {
	            if (this._pLookAtPosition)
	                this._pLookAtPosition = null;
	            if (this._pLookAtObject == val)
	                return;
	            if (this._pLookAtObject)
	                this._pLookAtObject.removeEventListener(DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	            this._pLookAtObject = val;
	            if (this._pLookAtObject)
	                this._pLookAtObject.addEventListener(DisplayObjectEvent_1.default.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    LookAtController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (this._pTargetObject) {
	            if (this._pLookAtPosition)
	                this._pTargetObject.lookAt(this._pLookAtPosition);
	            else if (this._pLookAtObject)
	                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position);
	        }
	    };
	    LookAtController.prototype.onLookAtObjectChanged = function (event) {
	        this.pNotifyUpdate();
	    };
	    return LookAtController;
	}(ControllerBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LookAtController;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(20);
	var ControllerBase = (function () {
	    function ControllerBase(targetObject) {
	        if (targetObject === void 0) { targetObject = null; }
	        this._pAutoUpdate = true;
	        this.targetObject = targetObject;
	    }
	    ControllerBase.prototype.pNotifyUpdate = function () {
	        if (this._pTargetObject)
	            this._pTargetObject.invalidatePartitionBounds();
	    };
	    Object.defineProperty(ControllerBase.prototype, "targetObject", {
	        get: function () {
	            return this._pTargetObject;
	        },
	        set: function (val) {
	            if (this._pTargetObject == val)
	                return;
	            if (this._pTargetObject && this._pAutoUpdate)
	                this._pTargetObject._iController = null;
	            this._pTargetObject = val;
	            if (this._pTargetObject && this._pAutoUpdate)
	                this._pTargetObject._iController = this;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
	        get: function () {
	            return this._pAutoUpdate;
	        },
	        set: function (val) {
	            if (this._pAutoUpdate == val)
	                return;
	            this._pAutoUpdate = val;
	            if (this._pTargetObject) {
	                if (this._pAutoUpdate)
	                    this._pTargetObject._iController = this;
	                else
	                    this._pTargetObject._iController = null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ControllerBase.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        throw new AbstractMethodError_1.default();
	    };
	    ControllerBase.prototype.updateController = function () {
	        if (this._pControllerDirty && this._pAutoUpdate) {
	            this._pControllerDirty = false;
	            this.pNotifyUpdate();
	        }
	    };
	    return ControllerBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ControllerBase;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(89);
	var Matrix3D_1 = __webpack_require__(28);
	var Vector3D_1 = __webpack_require__(30);
	var ContextGLCompareMode_1 = __webpack_require__(98);
	var ContextGLClearMask_1 = __webpack_require__(99);
	var RendererBase_1 = __webpack_require__(100);
	var DepthRenderer_1 = __webpack_require__(146);
	var DistanceRenderer_1 = __webpack_require__(177);
	var Filter3DRenderer_1 = __webpack_require__(179);
	var GL_SkyboxElements_1 = __webpack_require__(182);
	var RTTBufferManager_1 = __webpack_require__(181);
	var SurfacePool_1 = __webpack_require__(143);
	/**
	 * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
	 * materials assigned to them.
	 *
	 * @class away.render.DefaultRenderer
	 */
	var DefaultRenderer = (function (_super) {
	    __extends(DefaultRenderer, _super);
	    /**
	     * Creates a new DefaultRenderer object.
	     *
	     * @param antiAlias The amount of anti-aliasing to use.
	     * @param renderMode The render mode to use.
	     */
	    function DefaultRenderer(stage, forceSoftware, profile, mode) {
	        if (stage === void 0) { stage = null; }
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        _super.call(this, stage, null, forceSoftware, profile, mode);
	        this._skyboxProjection = new Matrix3D_1.default();
	        this._antiAlias = 0;
	        this._directionalLights = new Array();
	        this._pointLights = new Array();
	        this._lightProbes = new Array();
	        if (stage)
	            this.shareContext = true;
	        this._pRttBufferManager = RTTBufferManager_1.default.getInstance(this._pStage);
	        this._pDepthRenderer = new DepthRenderer_1.default(this._pStage);
	        this._pDistanceRenderer = new DistanceRenderer_1.default(this._pStage);
	        if (this._width == 0)
	            this.width = window.innerWidth;
	        else
	            this._pRttBufferManager.viewWidth = this._width;
	        if (this._height == 0)
	            this.height = window.innerHeight;
	        else
	            this._pRttBufferManager.viewHeight = this._height;
	        this._skyBoxSurfacePool = new SurfacePool_1.default(GL_SkyboxElements_1.default, this._pStage);
	    }
	    Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
	        get: function () {
	            return this._antiAlias;
	        },
	        set: function (value) {
	            if (this._antiAlias == value)
	                return;
	            this._antiAlias = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
	        /**
	         *
	         */
	        get: function () {
	            return this._depthPrepass;
	        },
	        set: function (value) {
	            this._depthPrepass = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
	        /**
	         *
	         * @returns {*}
	         */
	        get: function () {
	            return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
	        },
	        set: function (value) {
	            if (value && value.length == 0)
	                value = null;
	            if (this._pFilter3DRenderer && !value) {
	                this._pFilter3DRenderer.dispose();
	                this._pFilter3DRenderer = null;
	            }
	            else if (!this._pFilter3DRenderer && value) {
	                this._pFilter3DRenderer = new Filter3DRenderer_1.default(this._pStage);
	                this._pFilter3DRenderer.filters = value;
	            }
	            if (this._pFilter3DRenderer) {
	                this._pFilter3DRenderer.filters = value;
	                this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
	            }
	            else {
	                this._pRequireDepthRender = false;
	                if (this._pDepthRender) {
	                    this._pDepthRender.dispose();
	                    this._pDepthRender = null;
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    DefaultRenderer.prototype.enterNode = function (node) {
	        var enter = _super.prototype.enterNode.call(this, node);
	        if (enter && node.debugVisible)
	            this.applyEntity(node.bounds.boundsPrimitive);
	        return enter;
	    };
	    DefaultRenderer.prototype.render = function (camera, scene) {
	        _super.prototype.render.call(this, camera, scene);
	        if (!this._pStage.recoverFromDisposal()) {
	            this._pBackBufferInvalid = true;
	            return;
	        }
	        if (this._pBackBufferInvalid)
	            this.pUpdateBackBuffer();
	        if (this.shareContext && this._pContext)
	            this._pContext.clear(0, 0, 0, 1, 1, 0, ContextGLClearMask_1.default.DEPTH);
	        if (this._pFilter3DRenderer) {
	            this.textureRatioX = this._pRttBufferManager.textureRatioX;
	            this.textureRatioY = this._pRttBufferManager.textureRatioY;
	        }
	        else {
	            this.textureRatioX = 1;
	            this.textureRatioY = 1;
	        }
	        if (this._pRequireDepthRender)
	            this.pRenderSceneDepthToTexture(camera, scene);
	        if (this._depthPrepass)
	            this.pRenderDepthPrepass(camera, scene);
	        //reset lights
	        this._directionalLights.length = 0;
	        this._pointLights.length = 0;
	        this._lightProbes.length = 0;
	        if (this._pFilter3DRenderer && this._pContext) {
	            this._iRender(camera, scene, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pRttBufferManager.renderToTextureRect);
	            this._pFilter3DRenderer.render(this._pStage, camera, this._pDepthRender);
	        }
	        else {
	            if (this.shareContext)
	                this._iRender(camera, scene, null, this._pScissorRect);
	            else
	                this._iRender(camera, scene);
	        }
	        if (!this.shareContext && this._pContext)
	            this._pContext.present();
	        // register that a view has been rendered
	        this._pStage.bufferClear = false;
	    };
	    DefaultRenderer.prototype.pExecuteRender = function (camera, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        this.updateLights(camera);
	        _super.prototype.pExecuteRender.call(this, camera, target, scissorRect, surfaceSelector);
	    };
	    DefaultRenderer.prototype.updateLights = function (camera) {
	        var len, i;
	        var light;
	        var shadowMapper;
	        len = this._directionalLights.length;
	        for (i = 0; i < len; ++i) {
	            light = this._directionalLights[i];
	            shadowMapper = light.shadowMapper;
	            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
	                shadowMapper.iRenderDepthMap(camera, light.scene, this._pDepthRenderer);
	        }
	        len = this._pointLights.length;
	        for (i = 0; i < len; ++i) {
	            light = this._pointLights[i];
	            shadowMapper = light.shadowMapper;
	            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
	                shadowMapper.iRenderDepthMap(camera, light.scene, this._pDistanceRenderer);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    DefaultRenderer.prototype.pDraw = function (camera) {
	        if (this._skybox) {
	            this._pContext.setDepthTest(false, ContextGLCompareMode_1.default.ALWAYS);
	            this.drawSkybox(camera);
	        }
	        _super.prototype.pDraw.call(this, camera);
	    };
	    /**
	     * Draw the skybox if present.
	     **/
	    DefaultRenderer.prototype.drawSkybox = function (camera) {
	        var renderable = this.getAbstraction(this._skybox);
	        renderable.renderSceneTransform = this._skybox.getRenderSceneTransform(this._cameraTransform);
	        this.updateSkyboxProjection(camera);
	        var pass = this._skyBoxSurfacePool.getAbstraction(renderable.surfaceGL.surface).passes[0];
	        this.activatePass(renderable, pass, camera);
	        renderable._iRender(pass, camera, this._skyboxProjection);
	        this.deactivatePass(renderable, pass);
	    };
	    DefaultRenderer.prototype.updateSkyboxProjection = function (camera) {
	        var near = new Vector3D_1.default();
	        this._skyboxProjection.copyFrom(this._pRttViewProjectionMatrix);
	        this._skyboxProjection.copyRowTo(2, near);
	        var camPos = camera.scenePosition;
	        var cx = near.x;
	        var cy = near.y;
	        var cz = near.z;
	        var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));
	        var signX = cx >= 0 ? 1 : -1;
	        var signY = cy >= 0 ? 1 : -1;
	        var p = new Vector3D_1.default(signX, signY, 1, 1);
	        var inverse = this._skyboxProjection.clone();
	        inverse.invert();
	        var q = inverse.transformVector(p);
	        this._skyboxProjection.copyRowTo(3, p);
	        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
	        this._skyboxProjection.copyRowFrom(2, new Vector3D_1.default(cx * a, cy * a, cz * a, cw * a));
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyDirectionalLight = function (entity) {
	        this._directionalLights.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyLightProbe = function (entity) {
	        this._lightProbes.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyPointLight = function (entity) {
	        this._pointLights.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applySkybox = function (entity) {
	        this._skybox = entity;
	    };
	    DefaultRenderer.prototype.dispose = function () {
	        if (!this.shareContext)
	            this._pStage.dispose();
	        this._pRttBufferManager.dispose();
	        this._pRttBufferManager = null;
	        this._pDepthRenderer.dispose();
	        this._pDistanceRenderer.dispose();
	        this._pDepthRenderer = null;
	        this._pDistanceRenderer = null;
	        this._pDepthRender = null;
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.pRenderDepthPrepass = function (camera, scene) {
	        this._pDepthRenderer.disableColor = true;
	        if (this._pFilter3DRenderer) {
	            this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
	            this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
	            this._pDepthRenderer._iRender(camera, scene, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pRttBufferManager.renderToTextureRect);
	        }
	        else {
	            this._pDepthRenderer.textureRatioX = 1;
	            this._pDepthRenderer.textureRatioY = 1;
	            this._pDepthRenderer._iRender(camera, scene);
	        }
	        this._pDepthRenderer.disableColor = false;
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (camera, scene) {
	        if (this._pDepthTextureInvalid || !this._pDepthRender)
	            this.initDepthTexture(this._pStage.context);
	        this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
	        this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
	        this._pDepthRenderer._iRender(camera, scene, this._pDepthRender);
	    };
	    /**
	     * Updates the backbuffer dimensions.
	     */
	    DefaultRenderer.prototype.pUpdateBackBuffer = function () {
	        // No reason trying to configure back buffer if there is no context available.
	        // Doing this anyway (and relying on _stage to cache width/height for
	        // context does get available) means usesSoftwareRendering won't be reliable.
	        if (this._pStage.context && !this.shareContext) {
	            if (this._width && this._height) {
	                this._pStage.configureBackBuffer(this._width, this._height, this._antiAlias, true);
	                this._pBackBufferInvalid = false;
	            }
	        }
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.initDepthTexture = function (context) {
	        this._pDepthTextureInvalid = false;
	        if (this._pDepthRender)
	            this._pDepthRender.dispose();
	        this._pDepthRender = new BitmapImage2D_1.default(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight);
	    };
	    return DefaultRenderer;
	}(RendererBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DefaultRenderer;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(90);
	var ColorUtils_1 = __webpack_require__(47);
	var BitmapImageUtils_1 = __webpack_require__(93);
	var CPUCanvas_1 = __webpack_require__(94);
	/**
	 * The BitmapImage2D class lets you work with the data(pixels) of a Bitmap
	 * object. You can use the methods of the BitmapImage2D class to create
	 * arbitrarily sized transparent or opaque bitmap images and manipulate them
	 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
	 * image that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes.
	 *
	 * <p>This class lets you separate bitmap rendering operations from the
	 * internal display updating routines of flash. By manipulating a
	 * BitmapImage2D object directly, you can create complex images without incurring
	 * the per-frame overhead of constantly redrawing the content from vector
	 * data.</p>
	 *
	 * <p>The methods of the BitmapImage2D class support effects that are not
	 * available through the filters available to non-bitmap display objects.</p>
	 *
	 * <p>A BitmapImage2D object contains an array of pixel data. This data can
	 * represent either a fully opaque bitmap or a transparent bitmap that
	 * contains alpha channel data. Either type of BitmapImage2D object is stored as
	 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
	 * of a single pixel in the bitmap.</p>
	 *
	 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
	 * 0 to 255) that describe the alpha transparency and the red, green, and blue
	 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
	 * represents the alpha channel value, followed by red, green, and blue.)</p>
	 *
	 * <p>The four channels(alpha, red, green, and blue) are represented as
	 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
	 * method or the <code>DisplacementMapFilter.componentX</code> and
	 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
	 * are represented by the following constants in the BitmapImage2DChannel
	 * class:</p>
	 *
	 * <ul>
	 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	 *   <li><code>BitmapImage2DChannel.RED</code></li>
	 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	 * </ul>
	 *
	 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
	 * <code>bitmapData</code> property of the Bitmap object.</p>
	 *
	 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
	 * <code>Graphics.beginBitmapFill()</code> method.</p>
	 *
	 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
	 * using the <code>flash.display.Tilesheet</code> class.</p>
	 *
	 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
	 * is 8,191 pixels in width or height, and the total number of pixels cannot
	 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
	 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
	 * is 2,880 pixels in height and 2,880 in width.</p>
	 */
	var BitmapImage2D = (function (_super) {
	    __extends(BitmapImage2D, _super);
	    /**
	     * Creates a BitmapImage2D object with a specified width and height. If you
	     * specify a value for the <code>fillColor</code> parameter, every pixel in
	     * the bitmap is set to that color.
	     *
	     * <p>By default, the bitmap is created as transparent, unless you pass
	     * the value <code>false</code> for the transparent parameter. After you
	     * create an opaque bitmap, you cannot change it to a transparent bitmap.
	     * Every pixel in an opaque bitmap uses only 24 bits of color channel
	     * information. If you define the bitmap as transparent, every pixel uses 32
	     * bits of color channel information, including an alpha transparency
	     * channel.</p>
	     *
	     * @param width       The width of the bitmap image in pixels.
	     * @param height      The height of the bitmap image in pixels.
	     * @param transparent Specifies whether the bitmap image supports per-pixel
	     *                    transparency. The default value is <code>true</code>
	     *                    (transparent). To create a fully transparent bitmap,
	     *                    set the value of the <code>transparent</code>
	     *                    parameter to <code>true</code> and the value of the
	     *                    <code>fillColor</code> parameter to 0x00000000(or to
	     *                    0). Setting the <code>transparent</code> property to
	     *                    <code>false</code> can result in minor improvements
	     *                    in rendering performance.
	     * @param fillColor   A 32-bit ARGB color value that you use to fill the
	     *                    bitmap image area. The default value is
	     *                    0xFFFFFFFF(solid white).
	     */
	    function BitmapImage2D(width, height, transparent, fillColor, powerOfTwo) {
	        if (transparent === void 0) { transparent = true; }
	        if (fillColor === void 0) { fillColor = null; }
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        _super.call(this, width, height, powerOfTwo);
	        this._locked = false;
	        this._transparent = transparent;
	        if (document) {
	            this._imageCanvas = document.createElement("canvas");
	        }
	        else {
	            this._imageCanvas = new CPUCanvas_1.default();
	        }
	        this._imageCanvas.width = width;
	        this._imageCanvas.height = height;
	        this._context = this._imageCanvas.getContext("2d");
	        if (fillColor != null)
	            this.fillRect(this._rect, fillColor);
	    }
	    Object.defineProperty(BitmapImage2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return BitmapImage2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapImage2D.prototype, "transparent", {
	        /**
	         * Defines whether the bitmap image supports per-pixel transparency. You can
	         * set this value only when you construct a BitmapImage2D object by passing in
	         * <code>true</code> for the <code>transparent</code> parameter of the
	         * constructor. Then, after you create a BitmapImage2D object, you can check
	         * whether it supports per-pixel transparency by determining if the value of
	         * the <code>transparent</code> property is <code>true</code>.
	         */
	        get: function () {
	            return this._transparent;
	        },
	        set: function (value) {
	            this._transparent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new BitmapImage2D object that is a clone of the original instance
	     * with an exact copy of the contained bitmap.
	     *
	     * @return A new BitmapImage2D object that is identical to the original.
	     */
	    BitmapImage2D.prototype.clone = function () {
	        var t = new BitmapImage2D(this.width, this.height, this.transparent, null, this.powerOfTwo);
	        t.draw(this);
	        return t;
	    };
	    /**
	     * Adjusts the color values in a specified area of a bitmap image by using a
	     * <code>ColorTransform</code> object. If the rectangle matches the
	     * boundaries of the bitmap image, this method transforms the color values of
	     * the entire image.
	     *
	     * @param rect           A Rectangle object that defines the area of the
	     *                       image in which the ColorTransform object is applied.
	     * @param colorTransform A ColorTransform object that describes the color
	     *                       transformation values to apply.
	     */
	    BitmapImage2D.prototype.colorTransform = function (rect, colorTransform) {
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var data = this._imageData.data;
	        var i /*uint*/, j /*uint*/, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this.width) * 4;
	                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
	                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
	                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
	                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
	            }
	        }
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Transfers data from one channel of another BitmapImage2D object or the
	     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
	     * All of the data in the other channels in the destination BitmapImage2D object
	     * are preserved.
	     *
	     * <p>The source channel value and destination channel value can be one of
	     * following values: </p>
	     *
	     * <ul>
	     *   <li><code>BitmapImage2DChannel.RED</code></li>
	     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	     * </ul>
	     *
	     * @param sourceBitmapImage2D The input bitmap image to use. The source image
	     *                         can be a different BitmapImage2D object or it can
	     *                         refer to the current BitmapImage2D object.
	     * @param sourceRect       The source Rectangle object. To copy only channel
	     *                         data from a smaller area within the bitmap,
	     *                         specify a source rectangle that is smaller than
	     *                         the overall size of the BitmapImage2D object.
	     * @param destPoint        The destination Point object that represents the
	     *                         upper-left corner of the rectangular area where
	     *                         the new channel data is placed. To copy only
	     *                         channel data from one area to a different area in
	     *                         the destination image, specify a point other than
	     *                        (0,0).
	     * @param sourceChannel    The source channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @param destChannel      The destination channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
	     */
	    BitmapImage2D.prototype.copyChannel = function (sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
	        var imageData = sourceBitmap.getImageData();
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var sourceData = sourceBitmap.getImageData().data;
	        var destData = this._imageData.data;
	        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
	        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
	        var i /*uint*/, j /*uint*/, sourceIndex /*uint*/, destIndex;
	        for (i = 0; i < sourceRect.width; ++i) {
	            for (j = 0; j < sourceRect.height; ++j) {
	                sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
	                destIndex = (i + destPoint.x + (j + destPoint.y) * this.width) * 4;
	                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
	            }
	        }
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    BitmapImage2D.prototype.copyPixels = function (source, sourceRect, destRect) {
	        if (source instanceof BitmapImage2D)
	            source = source.getCanvas();
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._copyPixels(this._context, source, sourceRect, destRect);
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        }
	        else {
	            BitmapImageUtils_1.default._copyPixels(this._context, source, sourceRect, destRect);
	        }
	        this.invalidate();
	    };
	    /**
	     * Frees memory that is used to store the BitmapImage2D object.
	     *
	     * <p>When the <code>dispose()</code> method is called on an image, the width
	     * and height of the image are set to 0. All subsequent calls to methods or
	     * properties of this BitmapImage2D instance fail, and an exception is thrown.
	     * </p>
	     *
	     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
	     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
	     * object is no longer usable and an exception may be thrown if
	     * you call functions on the BitmapImage2D object. However,
	     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
	     * object(approximately 128 bytes); the memory occupied by the actual
	     * BitmapImage2D object is released at the time the BitmapImage2D object is
	     * collected by the garbage collector.</p>
	     *
	     */
	    BitmapImage2D.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._context = null;
	        this._imageCanvas = null;
	        this._imageData = null;
	        this._rect = null;
	        this._transparent = null;
	        this._locked = null;
	    };
	    BitmapImage2D.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        if (source instanceof BitmapImage2D && source.getCanvas()) {
	            source = source.getCanvas();
	        }
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._draw(this._context, source, matrix, colorTransform, blendMode, clipRect, smoothing);
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        }
	        else {
	            BitmapImageUtils_1.default._draw(this._context, source, matrix, colorTransform, blendMode, clipRect, smoothing);
	        }
	        this.invalidate();
	    };
	    /**
	     * Fills a rectangular area of pixels with a specified ARGB color.
	     *
	     * @param rect  The rectangular area to fill.
	     * @param color The ARGB color value that fills the area. ARGB colors are
	     *              often specified in hexadecimal format; for example,
	     *              0xFF336699.
	     * @throws TypeError The rect is null.
	     */
	    BitmapImage2D.prototype.fillRect = function (rect, color) {
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) apply fill
	            //      3) read _imageData back out
	            if (this._imageData)
	                this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._fillRect(this._context, rect, color, this._transparent);
	            if (this._imageData)
	                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        }
	        else {
	            BitmapImageUtils_1.default._fillRect(this._context, rect, color, this._transparent);
	        }
	        this.invalidate();
	    };
	    /**
	     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
	     * object at a specific point(<i>x</i>, <i>y</i>). The
	     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	     * alpha information is returned.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, the
	     *         method returns 0.
	     */
	    BitmapImage2D.prototype.getPixel = function (x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context.getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._imageData.width) * 4;
	            r = this._imageData.data[index + 0];
	            g = this._imageData.data[index + 1];
	            b = this._imageData.data[index + 2];
	            a = this._imageData.data[index + 3];
	        }
	        //returns black if fully transparent
	        if (!a)
	            return 0x0;
	        return (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Returns an ARGB color value that contains alpha channel data and RGB data.
	     * This method is similar to the <code>getPixel()</code> method, which
	     * returns an RGB color without alpha channel data.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	     *         returned.
	     */
	    BitmapImage2D.prototype.getPixel32 = function (x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context.getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._imageData.width) * 4;
	            r = this._imageData.data[index + 0];
	            g = this._imageData.data[index + 1];
	            b = this._imageData.data[index + 2];
	            a = this._imageData.data[index + 3];
	        }
	        return (a << 24) | (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Locks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are not updated when this BitmapImage2D object
	     * changes. To improve performance, use this method along with the
	     * <code>unlock()</code> method before and after numerous calls to the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method.
	     *
	     */
	    BitmapImage2D.prototype.lock = function () {
	        if (this._locked)
	            return;
	        this._locked = true;
	        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	    };
	    /**
	     * Converts an Array into a rectangular region of pixel data. For each pixel,
	     * an Array element is read and written into the BitmapImage2D pixel. The data
	     * in the Array is expected to be 32-bit ARGB pixel values.
	     *
	     * @param rect        Specifies the rectangular region of the BitmapImage2D
	     *                    object.
	     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
	     *                    values to be used in the rectangular region.
	     * @throws RangeError The vector array is not large enough to read all the
	     *                    pixel data.
	     */
	    BitmapImage2D.prototype.setArray = function (rect, inputArray) {
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var i /*uint*/, j /*uint*/, index /*uint*/, argb;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                argb = ColorUtils_1.default.float32ColorToARGB(inputArray[i + j * rect.width]);
	                index = (i + rect.x + (j + rect.y) * this._imageData.width) * 4;
	                this._imageData.data[index + 0] = argb[1];
	                this._imageData.data[index + 1] = argb[2];
	                this._imageData.data[index + 2] = argb[3];
	                this._imageData.data[index + 3] = argb[0];
	            }
	        }
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
	     * value of the image pixel is preserved during this operation. The value of
	     * the RGB color parameter is treated as an unmultiplied color value.
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting RGB color for the pixel.
	     */
	    BitmapImage2D.prototype.setPixel = function (x, y, color) {
	        var argb = ColorUtils_1.default.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        this._imageData.data[index + 0] = argb[1];
	        this._imageData.data[index + 1] = argb[2];
	        this._imageData.data[index + 2] = argb[3];
	        this._imageData.data[index + 3] = 255;
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets the color and alpha transparency values of a single pixel of a
	     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
	     * method; the main difference is that the <code>setPixel32()</code> method
	     * takes an ARGB color value that contains alpha channel information.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting ARGB color for the pixel. If the bitmap is
	     *              opaque(not transparent), the alpha transparency portion of
	     *              this color value is ignored.
	     */
	    BitmapImage2D.prototype.setPixel32 = function (x, y, color) {
	        var argb = ColorUtils_1.default.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        this._imageData.data[index + 0] = argb[1];
	        this._imageData.data[index + 1] = argb[2];
	        this._imageData.data[index + 2] = argb[3];
	        this._imageData.data[index + 3] = argb[0];
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Converts a byte array into a rectangular region of pixel data. For each
	     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	     * the return value is written into the pixel. If the byte array ends before
	     * the full rectangle is written, the function returns. The data in the byte
	     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	     * on the byte array before or after the pixels are read.
	     *
	     * @param rect           Specifies the rectangular region of the BitmapImage2D
	     *                       object.
	     * @param inputByteArray A ByteArray object that consists of 32-bit
	     *                       unmultiplied pixel values to be used in the
	     *                       rectangular region.
	     * @throws EOFError  The <code>inputByteArray</code> object does not include
	     *                   enough data to fill the area of the <code>rect</code>
	     *                   rectangle. The method fills as many pixels as possible
	     *                   before throwing the exception.
	     * @throws TypeError The rect or inputByteArray are null.
	     */
	    BitmapImage2D.prototype.setPixels = function (rect, inputByteArray) {
	        if (!this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        inputByteArray.position = 0;
	        var i /*uint*/, j /*uint*/, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this._imageData.width) * 4;
	                this._imageData.data[index + 0] = inputByteArray.readUnsignedInt();
	                this._imageData.data[index + 1] = inputByteArray.readUnsignedInt();
	                this._imageData.data[index + 2] = inputByteArray.readUnsignedInt();
	                this._imageData.data[index + 3] = inputByteArray.readUnsignedInt();
	            }
	        }
	        if (!this._locked) {
	            this._context.putImageData(this._imageData, 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Unlocks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
	     * To improve performance, use this method along with the <code>lock()</code>
	     * method before and after numerous calls to the <code>setPixel()</code> or
	     * <code>setPixel32()</code> method.
	     *
	     * @param changeRect The area of the BitmapImage2D object that has changed. If
	     *                   you do not specify a value for this parameter, the
	     *                   entire area of the BitmapImage2D object is considered
	     *                   changed.
	     */
	    BitmapImage2D.prototype.unlock = function () {
	        if (!this._locked)
	            return;
	        this._locked = false;
	        this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	        this._imageData = null;
	    };
	    /**
	     *
	     * @returns {ImageData}
	     */
	    BitmapImage2D.prototype.getImageData = function () {
	        if (!this._locked)
	            return this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        return this._imageData;
	    };
	    /**
	     *
	     * @returns {HTMLCanvasElement}
	     */
	    BitmapImage2D.prototype.getCanvas = function () {
	        return this._imageCanvas;
	    };
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    BitmapImage2D.prototype._setSize = function (width, height) {
	        if (this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        if (this._imageCanvas) {
	            this._imageCanvas.width = width;
	            this._imageCanvas.height = height;
	        }
	        _super.prototype._setSize.call(this, width, height);
	        if (this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	    };
	    BitmapImage2D.assetType = "[image BitmapImage2D]";
	    return BitmapImage2D;
	}(Image2D_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BitmapImage2D;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageBase_1 = __webpack_require__(91);
	var Rectangle_1 = __webpack_require__(35);
	var ImageUtils_1 = __webpack_require__(92);
	var Image2D = (function (_super) {
	    __extends(Image2D, _super);
	    /**
	     *
	     */
	    function Image2D(width, height, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        _super.call(this);
	        this._powerOfTwo = true;
	        this._rect = new Rectangle_1.default(0, 0, width, height);
	        this._powerOfTwo = powerOfTwo;
	        this._testDimensions();
	    }
	    Object.defineProperty(Image2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Image2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "height", {
	        /**
	         * The height of the image in pixels.
	         */
	        get: function () {
	            return this._rect.height;
	        },
	        set: function (value) {
	            if (this._rect.height == value)
	                return;
	            this._setSize(this._rect.width, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "rect", {
	        /**
	         * The rectangle that defines the size and location of the bitmap image. The
	         * top and left of the rectangle are 0; the width and height are equal to the
	         * width and height in pixels of the BitmapData object.
	         */
	        get: function () {
	            return this._rect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "width", {
	        /**
	         * The width of the bitmap image in pixels.
	         */
	        get: function () {
	            return this._rect.width;
	        },
	        set: function (value) {
	            if (this._rect.width == value)
	                return;
	            this._setSize(value, this._rect.height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    Image2D.prototype._setSize = function (width, height) {
	        if (this._rect.width != width || this._rect.height != height)
	            this.clear();
	        this._rect.width = width;
	        this._rect.height = height;
	        this._testDimensions();
	    };
	    /**
	     *
	     * @private
	     */
	    Image2D.prototype._testDimensions = function () {
	        if (this._powerOfTwo && (!ImageUtils_1.default.isDimensionValid(this._rect.width) || !ImageUtils_1.default.isDimensionValid(this._rect.height)))
	            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
	    };
	    Object.defineProperty(Image2D.prototype, "powerOfTwo", {
	        /**
	         * Enable POT texture size validation
	         * @returns {boolean}
	         */
	        get: function () {
	            return this._powerOfTwo;
	        },
	        set: function (value) {
	            if (this._powerOfTwo == value)
	                return;
	            this._powerOfTwo = value;
	            this._testDimensions();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Image2D.assetType = "[image Image2D]";
	    return Image2D;
	}(ImageBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Image2D;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var ImageBase = (function (_super) {
	    __extends(ImageBase, _super);
	    /**
	     *
	     */
	    function ImageBase() {
	        _super.call(this);
	        this._pFormat = "bgra";
	    }
	    Object.defineProperty(ImageBase.prototype, "format", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._pFormat;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ImageBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageBase;


/***/ },
/* 92 */
/***/ function(module, exports) {

	"use strict";
	var ImageUtils = (function () {
	    function ImageUtils() {
	    }
	    ImageUtils.isImage2DValid = function (image2D) {
	        if (image2D == null)
	            return true;
	        return ImageUtils.isDimensionValid(image2D.width, image2D.powerOfTwo) && ImageUtils.isDimensionValid(image2D.height, image2D.powerOfTwo);
	    };
	    ImageUtils.isHTMLImageElementValid = function (image) {
	        if (image == null)
	            return true;
	        return ImageUtils.isDimensionValid(image.width) && ImageUtils.isDimensionValid(image.height);
	    };
	    ImageUtils.isDimensionValid = function (d, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        return d >= 1 && d <= ImageUtils.MAX_SIZE && (!powerOfTwo || ImageUtils.isPowerOfTwo(d));
	    };
	    ImageUtils.isPowerOfTwo = function (value) {
	        return value ? ((value & -value) == value) : false;
	    };
	    ImageUtils.getBestPowerOf2 = function (value) {
	        var p = 1;
	        while (p < value)
	            p <<= 1;
	        if (p > ImageUtils.MAX_SIZE)
	            p = ImageUtils.MAX_SIZE;
	        return p;
	    };
	    ImageUtils.MAX_SIZE = 2048;
	    return ImageUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageUtils;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorUtils_1 = __webpack_require__(47);
	var BitmapImageUtils = (function () {
	    function BitmapImageUtils() {
	    }
	    BitmapImageUtils._fillRect = function (context, rect, color, transparent) {
	        if (color == 0x0 && transparent) {
	            context.clearRect(rect.x, rect.y, rect.width, rect.height);
	        }
	        else {
	            var argb = ColorUtils_1.default.float32ColorToARGB(color);
	            if (transparent)
	                context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] / 255 + ')';
	            else
	                context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',1)';
	            context.fillRect(rect.x, rect.y, rect.width, rect.height);
	        }
	    };
	    BitmapImageUtils._copyPixels = function (context, bmpd, sourceRect, destRect) {
	        context.drawImage(bmpd, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
	    };
	    BitmapImageUtils._draw = function (context, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        context.save();
	        if (matrix != null)
	            context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	        if (clipRect != null)
	            context.drawImage(source, clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	        else
	            context.drawImage(source, 0, 0);
	        context.restore();
	    };
	    return BitmapImageUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BitmapImageUtils;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CPURenderingContext2D_1 = __webpack_require__(95);
	var ImageData_1 = __webpack_require__(97);
	var CPUCanvas = (function () {
	    function CPUCanvas() {
	        this.width = 1;
	        this.height = 1;
	        this.reset();
	    }
	    CPUCanvas.prototype.getContext = function (contextId) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        return new CPURenderingContext2D_1.default(this);
	    };
	    CPUCanvas.prototype.reset = function () {
	        if (!this.imageData) {
	            this.imageData = new ImageData_1.default(this.width, this.height);
	        }
	        else {
	            this.imageData.width = this.width;
	            this.imageData.height = this.height;
	            if (this.imageData.data) {
	                this.imageData.data.length = 0;
	                this.imageData.data = null;
	            }
	            this.imageData.data = new Uint8Array(this.width * this.height * 4);
	        }
	        for (var i = 0; i < this.width * this.height * 4; i += 4) {
	            this.imageData.data[i] = 255;
	            this.imageData.data[i + 1] = 255;
	            this.imageData.data[i + 2] = 255;
	            this.imageData.data[i + 3] = 255;
	        }
	    };
	    CPUCanvas.prototype.getImageData = function () {
	        if (this.imageData.width != this.width || this.imageData.height != this.height) {
	            this.reset();
	        }
	        return this.imageData;
	    };
	    return CPUCanvas;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CPUCanvas;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(89);
	var Matrix_1 = __webpack_require__(96);
	var Point_1 = __webpack_require__(36);
	//TODO: implement all methods
	var CPURenderingContext2D = (function () {
	    function CPURenderingContext2D(cpuCanvas) {
	        this.point = new Point_1.default();
	        this.point2 = new Point_1.default();
	        this.cpuCanvas = cpuCanvas;
	    }
	    CPURenderingContext2D.prototype.restore = function () {
	        this.matrix = null;
	    };
	    CPURenderingContext2D.prototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
	        this.matrix = new Matrix_1.default(m11, m12, m21, m22, dx, dy);
	    };
	    CPURenderingContext2D.prototype.save = function () {
	    };
	    CPURenderingContext2D.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
	    };
	    CPURenderingContext2D.prototype.measureText = function (text) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.isPointInPath = function (x, y, fillRule) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
	    };
	    CPURenderingContext2D.prototype.putImageData = function (imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
	    };
	    CPURenderingContext2D.prototype.rotate = function (angle) {
	    };
	    CPURenderingContext2D.prototype.fillText = function (text, x, y, maxWidth) {
	    };
	    CPURenderingContext2D.prototype.translate = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.scale = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.lineTo = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.getLineDash = function () {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.fill = function (fillRule) {
	    };
	    CPURenderingContext2D.prototype.createImageData = function (imageDataOrSw, sh) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.createPattern = function (image, repetition) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.closePath = function () {
	    };
	    CPURenderingContext2D.prototype.rect = function (x, y, w, h) {
	    };
	    CPURenderingContext2D.prototype.clip = function (fillRule) {
	    };
	    CPURenderingContext2D.prototype.clearRect = function (x, y, w, h) {
	        var imageData = this.cpuCanvas.getImageData();
	        for (var i = x; i < x + w; i++) {
	            for (var j = y; j < y + h; j++) {
	                var index = (i + j * imageData.width) * 4;
	                imageData.data[index] = 0;
	                imageData.data[index + 1] = 0;
	                imageData.data[index + 2] = 0;
	                imageData.data[index + 3] = 0;
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.moveTo = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.getImageData = function (sx, sy, sw, sh) {
	        //var result:ImageData = new ImageData(sw, sh);
	        //var i:number = 0;
	        //
	        //for (i = 0; i < sw * sh * 4; i += 4) {
	        //    result.data[i] = 255;
	        //    result.data[i + 1] = 255;
	        //    result.data[i + 2] = 255;
	        //    result.data[i + 3] = 255;
	        //}
	        //
	        //var imageData:ImageData = this.cpuCanvas.getImageData();
	        //for (i = sx; i < sx + sw; i++) {
	        //    for (var j:number = sy; j < sy + sh; j++) {
	        //        this.copyPixel32(result, i - sx, i - sy, imageData, i, j);
	        //    }
	        //}
	        return this.cpuCanvas.getImageData();
	    };
	    CPURenderingContext2D.prototype.applyPixel32 = function (target, x, y, color) {
	        //todo: blending support
	        x = Math.floor(x);
	        y = Math.floor(y);
	        if (x < 0 || x >= target.width || y >= target.height || y < 0)
	            return;
	        var index = (x + y * target.width) * 4;
	        //var alpha:number = color[3] / 255;
	        target.data[index] += color[0];
	        target.data[index + 1] += color[1];
	        target.data[index + 2] += color[2];
	        target.data[index + 3] += color[3];
	        //target.data[index] = color[0];
	        //target.data[index + 1] = color[1];
	        //target.data[index + 2] = color[2];
	        //target.data[index + 3] = color[3];
	        target.data[index] = target.data[index] & 0xFF;
	        target.data[index + 1] = target.data[index + 1] & 0xFF;
	        target.data[index + 2] = target.data[index + 2] & 0xFF;
	        target.data[index + 3] = target.data[index + 3] & 0xFF;
	    };
	    CPURenderingContext2D.prototype.copyPixel32 = function (target, x, y, source, fromX, fromY) {
	        x = Math.floor(x);
	        y = Math.floor(y);
	        fromX = Math.floor(fromX);
	        fromY = Math.floor(fromY);
	        if (x < 0 || x >= target.width || y >= target.height || y < 0)
	            return;
	        if (fromX < 0 || fromX >= source.width || fromY >= source.height || fromY < 0)
	            return;
	        var index = (x + y * target.width) * 4;
	        var fromIndex = (fromX + fromY * source.width) * 4;
	        target.data[index] = source.data[fromIndex];
	        target.data[index + 1] = source.data[fromIndex + 1];
	        target.data[index + 2] = source.data[fromIndex + 2];
	        target.data[index + 3] = source.data[fromIndex + 3];
	    };
	    CPURenderingContext2D.prototype.fillRect = function (x, y, w, h) {
	        if (this.fillStyle) {
	            if (this.parsedFillStyle != this.fillStyle) {
	                var colorStrings = this.fillStyle.substring(5, this.fillStyle.lastIndexOf(")")).split(",");
	                this.parsedA = parseFloat(colorStrings[3]) * 255;
	                this.parsedR = parseInt(colorStrings[0]);
	                this.parsedG = parseInt(colorStrings[1]);
	                this.parsedB = parseInt(colorStrings[2]);
	                this.parsedFillStyle = this.fillStyle;
	            }
	            var imageData = this.cpuCanvas.getImageData();
	            for (var i = x; i < x + w; i++) {
	                for (var j = y; j < y + h; j++) {
	                    var index = (i + j * imageData.width) * 4;
	                    imageData.data[index] = this.parsedR;
	                    imageData.data[index + 1] = this.parsedG;
	                    imageData.data[index + 2] = this.parsedB;
	                    imageData.data[index + 3] = this.parsedA;
	                }
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
	    };
	    CPURenderingContext2D.prototype.drawImage = function (image, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
	        var b = image;
	        if (image.constructor.toString().indexOf("BitmapImage2D") > -1) {
	            var bitmap = b;
	            bitmap.lock();
	            this.drawBitmap(bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	            bitmap.unlock();
	        }
	        else if (image.constructor.toString().indexOf("HTMLImage") > -1) {
	            var htmlImage = image;
	            var htmlCanvas = document.createElement("canvas");
	            htmlCanvas.width = htmlImage.width;
	            htmlCanvas.height = htmlImage.height;
	            var htmlContext = htmlCanvas.getContext("2d");
	            htmlContext.drawImage(htmlImage, 0, 0);
	            var htmlImageData = htmlContext.getImageData(0, 0, htmlImage.width, htmlImage.height);
	            var resultBitmap = new BitmapImage2D_1.default(htmlImage.width, htmlImage.height, true, 0, false);
	            resultBitmap.getImageData().data = htmlImageData.data;
	            var passBitmap = resultBitmap;
	            this.drawImage(passBitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	        }
	        else if (image.constructor.toString().indexOf("CPUCanvas") > -1) {
	            //
	            var canvas = b;
	            this.drawBitmap(canvas, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	        }
	    };
	    CPURenderingContext2D.prototype.drawBitmap = function (bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
	        if (!width || width == 0) {
	            width = bitmap.width;
	            height = bitmap.height;
	        }
	        if (!canvasOffsetX || canvasOffsetX == 0) {
	            canvasOffsetX = 0;
	            canvasOffsetY = 0;
	        }
	        if (!canvasImageWidth || canvasImageWidth == 0 || this.matrix) {
	            canvasImageWidth = width;
	            canvasImageHeight = height;
	        }
	        //console.log("CPURenderingContext2D:drawBitmap(width: " + width + " height: " + height + " canvasImageWidth: " + canvasImageWidth + " canvasImageHeight: " + canvasImageHeight);
	        var sourceData = bitmap.getImageData();
	        var canvasImageData = this.cpuCanvas.getImageData();
	        if (this.matrix || (canvasImageWidth != width || canvasImageHeight != height)) {
	            var matrix = this.matrix;
	            if (!matrix) {
	                matrix = new Matrix_1.default();
	                matrix.scale(canvasImageWidth / width, canvasImageHeight / height);
	            }
	            var scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
	            var scaleY = Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
	            canvasImageWidth = width * scaleX;
	            canvasImageHeight = height * scaleY;
	            matrix.tx += canvasOffsetX;
	            matrix.ty += canvasOffsetY;
	            canvasOffsetX = Math.floor(matrix.tx);
	            canvasOffsetY = Math.floor(matrix.ty);
	            matrix.invert();
	            if (scaleX >= 1 || scaleY >= 1) {
	                var p = new Point_1.default();
	                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                        p.x = i;
	                        p.y = j;
	                        p = matrix.transformPoint(p);
	                        var color = CPURenderingContext2D.sampleBilinear(p.x, p.y, sourceData);
	                        this.applyPixel32(canvasImageData, i, j, color);
	                    }
	                }
	            }
	            else {
	                //decimate
	                var p1 = this.point;
	                var p2 = this.point2;
	                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                        p1.x = i;
	                        p1.y = j;
	                        p1 = matrix.transformPoint(p1);
	                        p2.x = i + 1;
	                        p2.y = j + 1;
	                        p2 = matrix.transformPoint(p2);
	                        var color = CPURenderingContext2D.sampleBox(p1.x + offsetX, p1.y + offsetY, p2.x + offsetX, p2.y + offsetY, sourceData);
	                        this.applyPixel32(canvasImageData, i, j, color);
	                    }
	                }
	            }
	            matrix.invert();
	        }
	        else {
	            for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                    var color = CPURenderingContext2D.sample(i - canvasOffsetX + offsetX, j - canvasOffsetY + offsetY, sourceData);
	                    this.applyPixel32(canvasImageData, i, j, color);
	                }
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.transform = function (m11, m12, m21, m22, dx, dy) {
	    };
	    CPURenderingContext2D.prototype.stroke = function () {
	    };
	    CPURenderingContext2D.prototype.strokeRect = function (x, y, w, h) {
	    };
	    CPURenderingContext2D.prototype.setLineDash = function (segments) {
	    };
	    CPURenderingContext2D.prototype.strokeText = function (text, x, y, maxWidth) {
	    };
	    CPURenderingContext2D.prototype.beginPath = function () {
	    };
	    CPURenderingContext2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {
	    };
	    CPURenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
	        return undefined;
	    };
	    CPURenderingContext2D.sampleBilinear = function (u, v, texture, texelSizeX, texelSizeY) {
	        if (texelSizeX === void 0) { texelSizeX = 1; }
	        if (texelSizeY === void 0) { texelSizeY = 1; }
	        var color00 = CPURenderingContext2D.sample(u, v, texture);
	        var color10 = CPURenderingContext2D.sample(u + texelSizeX, v, texture);
	        var color01 = CPURenderingContext2D.sample(u, v + texelSizeY, texture);
	        var color11 = CPURenderingContext2D.sample(u + texelSizeX, v + texelSizeY, texture);
	        var a = u;
	        a = a - Math.floor(a);
	        var interColor0 = CPURenderingContext2D.interpolateColor(color00, color10, a);
	        var interColor1 = CPURenderingContext2D.interpolateColor(color01, color11, a);
	        var b = v;
	        b = b - Math.floor(b);
	        return CPURenderingContext2D.interpolateColor(interColor0, interColor1, b);
	    };
	    CPURenderingContext2D.sample = function (u, v, imageData) {
	        u = Math.floor(u);
	        v = Math.floor(v);
	        var result = [0, 0, 0, 0];
	        if (u < 0 || u >= imageData.width || v < 0 || v >= imageData.height) {
	            return result;
	        }
	        var index = (u + v * imageData.width) * 4;
	        result[0] = imageData.data[index];
	        result[1] = imageData.data[index + 1];
	        result[2] = imageData.data[index + 2];
	        result[3] = imageData.data[index + 3];
	        return result;
	    };
	    CPURenderingContext2D.sampleBox = function (x0, y0, x1, y1, texture) {
	        var area = 0; // -- total area accumulated in pixels
	        var result = [0, 0, 0, 0];
	        var x;
	        var y;
	        var xsize;
	        var ysize;
	        var fromY = Math.floor(y0);
	        var toY = Math.ceil(y1);
	        fromY = Math.max(Math.min(fromY, texture.height - 1), 0);
	        toY = Math.max(Math.min(toY, texture.height - 1), 0);
	        for (y = fromY; y < toY; y++) {
	            ysize = 1;
	            if (y < y0) {
	                ysize = ysize * (1.0 - (y0 - y));
	            }
	            if (y > y1) {
	                ysize = ysize * (1.0 - (y - y1));
	            }
	            var fromX = Math.floor(x0);
	            var toX = Math.ceil(x1);
	            fromX = Math.max(Math.min(fromX, texture.width - 1), 0);
	            toX = Math.max(Math.min(toX, texture.width - 1), 0);
	            for (x = fromX; x < toX; x++) {
	                xsize = ysize;
	                var color = CPURenderingContext2D.sample(x, y, texture);
	                if (x < x0) {
	                    xsize = xsize * (1.0 - (x0 - x));
	                }
	                if (x > x1) {
	                    xsize = xsize * (1.0 - (x - x1));
	                }
	                result[0] += color[0] * xsize;
	                result[1] += color[1] * xsize;
	                result[2] += color[2] * xsize;
	                result[3] += color[3] * xsize;
	                area = area + xsize;
	            }
	        }
	        result[0] /= area;
	        result[1] /= area;
	        result[2] /= area;
	        result[3] /= area;
	        result[0] = result[0] & 0xFF;
	        result[1] = result[1] & 0xFF;
	        result[2] = result[2] & 0xFF;
	        result[3] = result[3] & 0xFF;
	        return result;
	    };
	    CPURenderingContext2D.interpolateColor = function (source, target, a) {
	        var result = [];
	        result[0] = source[0] + (target[0] - source[0]) * a;
	        result[1] = source[1] + (target[1] - source[1]) * a;
	        result[2] = source[2] + (target[2] - source[2]) * a;
	        result[3] = source[3] + (target[3] - source[3]) * a;
	        return result;
	    };
	    return CPURenderingContext2D;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CPURenderingContext2D;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Point_1 = __webpack_require__(36);
	var ArgumentError_1 = __webpack_require__(33);
	/**
	 * The Matrix class represents a transformation matrix that determines how to
	 * map points from one coordinate space to another. You can perform various
	 * graphical transformations on a display object by setting the properties of
	 * a Matrix object, applying that Matrix object to the <code>matrix</code>
	 * property of a Transform object, and then applying that Transform object as
	 * the <code>transform</code> property of the display object. These
	 * transformation functions include translation(<i>x</i> and <i>y</i>
	 * repositioning), rotation, scaling, and skewing.
	 *
	 * <p>Together these types of transformations are known as <i>affine
	 * transformations</i>. Affine transformations preserve the straightness of
	 * lines while transforming, so that parallel lines stay parallel.</p>
	 *
	 * <p>To apply a transformation matrix to a display object, you create a
	 * Transform object, set its <code>matrix</code> property to the
	 * transformation matrix, and then set the <code>transform</code> property of
	 * the display object to the Transform object. Matrix objects are also used as
	 * parameters of some methods, such as the following:</p>
	 *
	 * <ul>
	 *   <li>The <code>draw()</code> method of a BitmapData object</li>
	 *   <li>The <code>beginBitmapFill()</code> method,
	 * <code>beginGradientFill()</code> method, or
	 * <code>lineGradientStyle()</code> method of a Graphics object</li>
	 * </ul>
	 *
	 * <p>A transformation matrix object is a 3 x 3 matrix with the following
	 * contents:</p>
	 *
	 * <p>In traditional transformation matrixes, the <code>u</code>,
	 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
	 * The Matrix class can only operate in two-dimensional space, so it always
	 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
	 * and that the property value <code>w</code> is 1.0. The effective values of
	 * the matrix are as follows:</p>
	 *
	 * <p>You can get and set the values of all six of the other properties in a
	 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
	 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
	 *
	 * <p>The Matrix class supports the four major types of transformations:
	 * translation, scaling, rotation, and skewing. You can set three of these
	 * transformations by using specialized methods, as described in the following
	 * table: </p>
	 *
	 * <p>Each transformation function alters the current matrix properties so
	 * that you can effectively combine multiple transformations. To do this, you
	 * call more than one transformation function before applying the matrix to
	 * its display object target(by using the <code>transform</code> property of
	 * that display object).</p>
	 *
	 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
	 * before you can call the methods of the Matrix object.</p>
	 */
	var Matrix = (function () {
	    /**
	     * Creates a new Matrix object with the specified parameters. In matrix
	     * notation, the properties are organized like this:
	     *
	     * <p>If you do not provide any parameters to the <code>new Matrix()</code>
	     * constructor, it creates an <i>identity matrix</i> with the following
	     * values:</p>
	     *
	     * <p>In matrix notation, the identity matrix looks like this:</p>
	     *
	     * @param a  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when scaling or rotating an image.
	     * @param b  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when rotating or skewing an image.
	     * @param c  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when rotating or skewing an image.
	     * @param d  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when scaling or rotating an image..
	     * @param tx The distance by which to translate each point along the <i>x</i>
	     *           axis.
	     * @param ty The distance by which to translate each point along the <i>y</i>
	     *           axis.
	     */
	    function Matrix(a, b, c, d, tx, ty) {
	        if (a === void 0) { a = 1; }
	        if (b === void 0) { b = 0; }
	        if (c === void 0) { c = 0; }
	        if (d === void 0) { d = 1; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.d = d;
	        this.tx = tx;
	        this.ty = ty;
	    }
	    /**
	     * Returns a new Matrix object that is a clone of this matrix, with an exact
	     * copy of the contained object.
	     *
	     * @return A Matrix object.
	     */
	    Matrix.prototype.clone = function () {
	        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
	    };
	    /**
	     * Concatenates a matrix with the current matrix, effectively combining the
	     * geometric effects of the two. In mathematical terms, concatenating two
	     * matrixes is the same as combining them using matrix multiplication.
	     *
	     * <p>For example, if matrix <code>m1</code> scales an object by a factor of
	     * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
	     * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
	     * transforms <code>m1</code> into a matrix that scales an object by a factor
	     * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
	     *
	     * <p>This method replaces the source matrix with the concatenated matrix. If
	     * you want to concatenate two matrixes without altering either of the two
	     * source matrixes, first copy the source matrix by using the
	     * <code>clone()</code> method, as shown in the Class Examples section.</p>
	     *
	     * @param matrix The matrix to be concatenated to the source matrix.
	     */
	    Matrix.prototype.concat = function (matrix) {
	        var a1 = this.a * matrix.a + this.b * matrix.c;
	        this.b = this.a * matrix.b + this.b * matrix.d;
	        this.a = a1;
	        var c1 = this.c * matrix.a + this.d * matrix.c;
	        this.d = this.c * matrix.b + this.d * matrix.d;
	        this.c = c1;
	        var tx1 = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
	        this.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
	        this.tx = tx1;
	    };
	    /**
	     * Copies a Vector3D object into specific column of the calling Matrix3D
	     * object.
	     *
	     * @param column   The column from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyColumnFrom = function (column, vector3D) {
	        if (column > 2) {
	            throw "Column " + column + " out of bounds (2)";
	        }
	        else if (column == 0) {
	            this.a = vector3D.x;
	            this.c = vector3D.y;
	        }
	        else if (column == 1) {
	            this.b = vector3D.x;
	            this.d = vector3D.y;
	        }
	        else {
	            this.tx = vector3D.x;
	            this.ty = vector3D.y;
	        }
	    };
	    /**
	     * Copies specific column of the calling Matrix object into the Vector3D
	     * object. The w element of the Vector3D object will not be changed.
	     *
	     * @param column   The column from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyColumnTo = function (column, vector3D) {
	        if (column > 2) {
	            throw new ArgumentError_1.default("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
	        }
	        else if (column == 0) {
	            vector3D.x = this.a;
	            vector3D.y = this.c;
	            vector3D.z = 0;
	        }
	        else if (column == 1) {
	            vector3D.x = this.b;
	            vector3D.y = this.d;
	            vector3D.z = 0;
	        }
	        else {
	            vector3D.x = this.tx;
	            vector3D.y = this.ty;
	            vector3D.z = 1;
	        }
	    };
	    /**
	     * Copies all of the matrix data from the source Point object into the
	     * calling Matrix object.
	     *
	     * @param sourceMatrix The Matrix object from which to copy the data.
	     */
	    Matrix.prototype.copyFrom = function (sourceMatrix) {
	        this.a = sourceMatrix.a;
	        this.b = sourceMatrix.b;
	        this.c = sourceMatrix.c;
	        this.d = sourceMatrix.d;
	        this.tx = sourceMatrix.tx;
	        this.ty = sourceMatrix.ty;
	    };
	    /**
	     * Copies a Vector3D object into specific row of the calling Matrix object.
	     *
	     * @param row      The row from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyRowFrom = function (row, vector3D) {
	        if (row > 2) {
	            throw new ArgumentError_1.default("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
	        }
	        else if (row == 0) {
	            this.a = vector3D.x;
	            this.c = vector3D.y;
	        }
	        else if (row == 1) {
	            this.b = vector3D.x;
	            this.d = vector3D.y;
	        }
	        else {
	            this.tx = vector3D.x;
	            this.ty = vector3D.y;
	        }
	    };
	    /**
	     * Copies specific row of the calling Matrix object into the Vector3D object.
	     * The w element of the Vector3D object will not be changed.
	     *
	     * @param row      The row from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyRowTo = function (row, vector3D) {
	        if (row > 2) {
	            throw new ArgumentError_1.default("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
	        }
	        else if (row == 0) {
	            vector3D.x = this.a;
	            vector3D.y = this.b;
	            vector3D.z = this.tx;
	        }
	        else if (row == 1) {
	            vector3D.x = this.c;
	            vector3D.y = this.d;
	            vector3D.z = this.ty;
	        }
	        else {
	            vector3D.setTo(0, 0, 1);
	        }
	    };
	    /**
	     * Includes parameters for scaling, rotation, and translation. When applied
	     * to a matrix it sets the matrix's values based on those parameters.
	     *
	     * <p>Using the <code>createBox()</code> method lets you obtain the same
	     * matrix as you would if you applied the <code>identity()</code>,
	     * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
	     * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
	     * 100, 100)</code> has the same effect as the following:</p>
	     *
	     * @param scaleX   The factor by which to scale horizontally.
	     * @param scaleY   The factor by which scale vertically.
	     * @param rotation The amount to rotate, in radians.
	     * @param tx       The number of pixels to translate(move) to the right
	     *                 along the <i>x</i> axis.
	     * @param ty       The number of pixels to translate(move) down along the
	     *                 <i>y</i> axis.
	     */
	    Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
	        if (rotation === void 0) { rotation = 0; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.a = scaleX;
	        this.d = scaleY;
	        this.b = rotation;
	        this.tx = tx;
	        this.ty = ty;
	    };
	    /**
	     * Creates the specific style of matrix expected by the
	     * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
	     * methods of the Graphics class. Width and height are scaled to a
	     * <code>scaleX</code>/<code>scaleY</code> pair and the
	     * <code>tx</code>/<code>ty</code> values are offset by half the width and
	     * height.
	     *
	     * <p>For example, consider a gradient with the following
	     * characteristics:</p>
	     *
	     * <ul>
	     *   <li><code>GradientType.LINEAR</code></li>
	     *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
	     * 255]</code></li>
	     *   <li><code>SpreadMethod.PAD</code></li>
	     *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
	     * </ul>
	     *
	     * <p>The following illustrations show gradients in which the matrix was
	     * defined using the <code>createGradientBox()</code> method with different
	     * parameter settings:</p>
	     *
	     * @param width    The width of the gradient box.
	     * @param height   The height of the gradient box.
	     * @param rotation The amount to rotate, in radians.
	     * @param tx       The distance, in pixels, to translate to the right along
	     *                 the <i>x</i> axis. This value is offset by half of the
	     *                 <code>width</code> parameter.
	     * @param ty       The distance, in pixels, to translate down along the
	     *                 <i>y</i> axis. This value is offset by half of the
	     *                 <code>height</code> parameter.
	     */
	    Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
	        if (rotation === void 0) { rotation = 0; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.a = width / 1638.4;
	        this.d = height / 1638.4;
	        if (rotation != 0.0) {
	            var cos = Math.cos(rotation);
	            var sin = Math.sin(rotation);
	            this.b = sin * this.d;
	            this.c = -sin * this.a;
	            this.a *= cos;
	            this.d *= cos;
	        }
	        else {
	            this.b = this.c = 0;
	        }
	        this.tx = tx + width / 2;
	        this.ty = ty + height / 2;
	    };
	    /**
	     * Given a point in the pretransform coordinate space, returns the
	     * coordinates of that point after the transformation occurs. Unlike the
	     * standard transformation applied using the <code>transformPoint()</code>
	     * method, the <code>deltaTransformPoint()</code> method's transformation
	     * does not consider the translation parameters <code>tx</code> and
	     * <code>ty</code>.
	     *
	     * @param point The point for which you want to get the result of the matrix
	     *              transformation.
	     * @return The point resulting from applying the matrix transformation.
	     */
	    Matrix.prototype.deltaTransformPoint = function (point) {
	        return new Point_1.default(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
	    };
	    /**
	     * Sets each matrix property to a value that causes a null transformation. An
	     * object transformed by applying an identity matrix will be identical to the
	     * original.
	     *
	     * <p>After calling the <code>identity()</code> method, the resulting matrix
	     * has the following properties: <code>a</code>=1, <code>b</code>=0,
	     * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
	     * <code>ty</code>=0.</p>
	     *
	     * <p>In matrix notation, the identity matrix looks like this:</p>
	     *
	     */
	    Matrix.prototype.identity = function () {
	        this.a = 1;
	        this.b = 0;
	        this.c = 0;
	        this.d = 1;
	        this.tx = 0;
	        this.ty = 0;
	    };
	    /**
	     * Performs the opposite transformation of the original matrix. You can apply
	     * an inverted matrix to an object to undo the transformation performed when
	     * applying the original matrix.
	     */
	    Matrix.prototype.invert = function () {
	        var norm = this.a * this.d - this.b * this.c;
	        if (norm == 0) {
	            this.a = this.b = this.c = this.d = 0;
	            this.tx = -this.tx;
	            this.ty = -this.ty;
	        }
	        else {
	            norm = 1.0 / norm;
	            var a1 = this.d * norm;
	            this.d = this.a * norm;
	            this.a = a1;
	            this.b *= -norm;
	            this.c *= -norm;
	            var tx1 = -this.a * this.tx - this.c * this.ty;
	            this.ty = -this.b * this.tx - this.d * this.ty;
	            this.tx = tx1;
	        }
	    };
	    /**
	     * Returns a new Matrix object that is a clone of this matrix, with an exact
	     * copy of the contained object.
	     *
	     * @param matrix The matrix for which you want to get the result of the matrix
	     *               transformation.
	     * @return A Matrix object.
	     */
	    Matrix.prototype.multiply = function (matrix) {
	        var result = new Matrix();
	        result.a = this.a * matrix.a + this.b * matrix.c;
	        result.b = this.a * matrix.b + this.b * matrix.d;
	        result.c = this.c * matrix.a + this.d * matrix.c;
	        result.d = this.c * matrix.b + this.d * matrix.d;
	        result.tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
	        result.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
	        return result;
	    };
	    /**
	     * Applies a rotation transformation to the Matrix object.
	     *
	     * <p>The <code>rotate()</code> method alters the <code>a</code>,
	     * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
	     * Matrix object. In matrix notation, this is the same as concatenating the
	     * current matrix with the following:</p>
	     *
	     * @param angle The rotation angle in radians.
	     */
	    Matrix.prototype.rotate = function (angle) {
	        var cos = Math.cos(angle);
	        var sin = Math.sin(angle);
	        var a1 = this.a * cos - this.b * sin;
	        this.b = this.a * sin + this.b * cos;
	        this.a = a1;
	        var c1 = this.c * cos - this.d * sin;
	        this.d = this.c * sin + this.d * cos;
	        this.c = c1;
	        var tx1 = this.tx * cos - this.ty * sin;
	        this.ty = this.tx * sin + this.ty * cos;
	        this.tx = tx1;
	    };
	    /**
	     * Applies a scaling transformation to the matrix. The <i>x</i> axis is
	     * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
	     * <code>sy</code>.
	     *
	     * <p>The <code>scale()</code> method alters the <code>a</code> and
	     * <code>d</code> properties of the Matrix object. In matrix notation, this
	     * is the same as concatenating the current matrix with the following
	     * matrix:</p>
	     *
	     * @param sx A multiplier used to scale the object along the <i>x</i> axis.
	     * @param sy A multiplier used to scale the object along the <i>y</i> axis.
	     */
	    Matrix.prototype.scale = function (sx, sy) {
	        this.a *= sx;
	        this.b *= sy;
	        this.c *= sx;
	        this.d *= sy;
	        this.tx *= sx;
	        this.ty *= sy;
	    };
	    /**
	     * Sets the members of Matrix to the specified values.
	     *
	     * @param a  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when scaling or rotating an image.
	     * @param b  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when rotating or skewing an image.
	     * @param c  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when rotating or skewing an image.
	     * @param d  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when scaling or rotating an image..
	     * @param tx The distance by which to translate each point along the <i>x</i>
	     *           axis.
	     * @param ty The distance by which to translate each point along the <i>y</i>
	     *           axis.
	     */
	    Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.d = d;
	        this.tx = tx;
	        this.ty = ty;
	    };
	    /**
	     * Returns a text value listing the properties of the Matrix object.
	     *
	     * @return A string containing the values of the properties of the Matrix
	     *         object: <code>a</code>, <code>b</code>, <code>c</code>,
	     *         <code>d</code>, <code>tx</code>, and <code>ty</code>.
	     */
	    Matrix.prototype.toString = function () {
	        return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
	    };
	    /**
	     * Returns the result of applying the geometric transformation represented by
	     * the Matrix object to the specified point.
	     *
	     * @param point The point for which you want to get the result of the Matrix
	     *              transformation.
	     * @return The point resulting from applying the Matrix transformation.
	     */
	    Matrix.prototype.transformPoint = function (point) {
	        return new Point_1.default(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
	    };
	    /**
	     * Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
	     * by the <code>dx</code> and <code>dy</code> parameters.
	     *
	     * @param dx The amount of movement along the <i>x</i> axis to the right, in
	     *           pixels.
	     * @param dy The amount of movement down along the <i>y</i> axis, in pixels.
	     */
	    Matrix.prototype.translate = function (dx, dy) {
	        this.tx += dx;
	        this.ty += dy;
	    };
	    return Matrix;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Matrix;


/***/ },
/* 97 */
/***/ function(module, exports) {

	"use strict";
	var ImageData = (function () {
	    function ImageData(width, height) {
	        this.width = width;
	        this.height = height;
	        this.data = new Uint8Array(width * height * 4);
	    }
	    return ImageData;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageData;


/***/ },
/* 98 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLCompareMode = (function () {
	    function ContextGLCompareMode() {
	    }
	    ContextGLCompareMode.ALWAYS = "always";
	    ContextGLCompareMode.EQUAL = "equal";
	    ContextGLCompareMode.GREATER = "greater";
	    ContextGLCompareMode.GREATER_EQUAL = "greaterEqual";
	    ContextGLCompareMode.LESS = "less";
	    ContextGLCompareMode.LESS_EQUAL = "lessEqual";
	    ContextGLCompareMode.NEVER = "never";
	    ContextGLCompareMode.NOT_EQUAL = "notEqual";
	    return ContextGLCompareMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLCompareMode;


/***/ },
/* 99 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLClearMask = (function () {
	    function ContextGLClearMask() {
	    }
	    ContextGLClearMask.COLOR = 1;
	    ContextGLClearMask.DEPTH = 2;
	    ContextGLClearMask.STENCIL = 4;
	    ContextGLClearMask.ALL = ContextGLClearMask.COLOR | ContextGLClearMask.DEPTH | ContextGLClearMask.STENCIL;
	    return ContextGLClearMask;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLClearMask;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(28);
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Point_1 = __webpack_require__(36);
	var Rectangle_1 = __webpack_require__(35);
	var Vector3D_1 = __webpack_require__(30);
	var EventDispatcher_1 = __webpack_require__(12);
	var RendererEvent_1 = __webpack_require__(69);
	var AGALMiniAssembler_1 = __webpack_require__(101);
	var ContextGLBlendFactor_1 = __webpack_require__(112);
	var ContextGLCompareMode_1 = __webpack_require__(98);
	var StageEvent_1 = __webpack_require__(113);
	var StageManager_1 = __webpack_require__(114);
	var SurfacePool_1 = __webpack_require__(143);
	var ElementsPool_1 = __webpack_require__(144);
	var RenderableMergeSort_1 = __webpack_require__(145);
	/**
	 * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
	 * contents of a partition
	 *
	 * @class away.render.RendererBase
	 */
	var RendererBase = (function (_super) {
	    __extends(RendererBase, _super);
	    /**
	     * Creates a new RendererBase object.
	     */
	    function RendererBase(stage, surfaceClassGL, forceSoftware, profile, mode) {
	        var _this = this;
	        if (stage === void 0) { stage = null; }
	        if (surfaceClassGL === void 0) { surfaceClassGL = null; }
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        _super.call(this);
	        this._objectPools = new Object();
	        this._abstractionPool = new Object();
	        this._activeMasksConfig = new Array();
	        this._registeredMasks = new Array();
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._cameraForward = new Vector3D_1.default();
	        this._viewPort = new Rectangle_1.default();
	        this._pBackBufferInvalid = true;
	        this._pDepthTextureInvalid = true;
	        this._depthPrepass = false;
	        this._backgroundR = 0;
	        this._backgroundG = 0;
	        this._backgroundB = 0;
	        this._backgroundAlpha = 1;
	        this.textureRatioX = 1;
	        this.textureRatioY = 1;
	        this._pRttViewProjectionMatrix = new Matrix3D_1.default();
	        this._localPos = new Point_1.default();
	        this._globalPos = new Point_1.default();
	        this._pScissorRect = new Rectangle_1.default();
	        this._pNumElements = 0;
	        this._disableColor = false;
	        this._renderBlended = true;
	        this._numCullPlanes = 0;
	        this._onViewportUpdatedDelegate = function (event) { return _this.onViewportUpdated(event); };
	        this._onContextUpdateDelegate = function (event) { return _this.onContextUpdate(event); };
	        //default sorting algorithm
	        this.renderableSorter = new RenderableMergeSort_1.default();
	        //set stage
	        this._pStage = stage || StageManager_1.default.getInstance().getFreeStage(forceSoftware, profile, mode);
	        this._pStage.addEventListener(StageEvent_1.default.CONTEXT_CREATED, this._onContextUpdateDelegate);
	        this._pStage.addEventListener(StageEvent_1.default.CONTEXT_RECREATED, this._onContextUpdateDelegate);
	        this._pStage.addEventListener(StageEvent_1.default.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	        /*
	         if (_backgroundImageRenderer)
	         _backgroundImageRenderer.stage = value;
	         */
	        if (this._pStage.context)
	            this._pContext = this._pStage.context;
	        for (var i in ElementsPool_1.default._abstractionClassPool)
	            this._objectPools[i] = new SurfacePool_1.default(ElementsPool_1.default._abstractionClassPool[i], this._pStage, surfaceClassGL);
	    }
	    Object.defineProperty(RendererBase.prototype, "cullPlanes", {
	        /**
	         *
	         */
	        get: function () {
	            return this._customCullPlanes;
	        },
	        set: function (value) {
	            this._customCullPlanes = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "renderBlended", {
	        get: function () {
	            return this._renderBlended;
	        },
	        set: function (value) {
	            this._renderBlended = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "disableColor", {
	        get: function () {
	            return this._disableColor;
	        },
	        set: function (value) {
	            this._disableColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "numElements", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pNumElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "viewPort", {
	        /**
	         * A viewPort rectangle equivalent of the Stage size and position.
	         */
	        get: function () {
	            return this._viewPort;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "scissorRect", {
	        /**
	         * A scissor rectangle equivalent of the view size and position.
	         */
	        get: function () {
	            return this._pScissorRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "x", {
	        /**
	         *
	         */
	        get: function () {
	            return this._localPos.x;
	        },
	        set: function (value) {
	            if (this.x == value)
	                return;
	            this._globalPos.x = this._localPos.x = value;
	            this.updateGlobalPos();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "y", {
	        /**
	         *
	         */
	        get: function () {
	            return this._localPos.y;
	        },
	        set: function (value) {
	            if (this.y == value)
	                return;
	            this._globalPos.y = this._localPos.y = value;
	            this.updateGlobalPos();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "width", {
	        /**
	         *
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            if (this._width == value)
	                return;
	            this._width = value;
	            this._pScissorRect.width = value;
	            if (this._pRttBufferManager)
	                this._pRttBufferManager.viewWidth = value;
	            this._pBackBufferInvalid = true;
	            this._pDepthTextureInvalid = true;
	            this.notifyScissorUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "height", {
	        /**
	         *
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            if (this._height == value)
	                return;
	            this._height = value;
	            this._pScissorRect.height = value;
	            if (this._pRttBufferManager)
	                this._pRttBufferManager.viewHeight = value;
	            this._pBackBufferInvalid = true;
	            this._pDepthTextureInvalid = true;
	            this.notifyScissorUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RendererBase.prototype.getAbstraction = function (renderable) {
	        return this._abstractionPool[renderable.id] || (this._abstractionPool[renderable.id] = new RendererBase._abstractionClassPool[renderable.assetType](renderable, this));
	    };
	    /**
	     *
	     * @param image
	     */
	    RendererBase.prototype.clearAbstraction = function (renderable) {
	        this._abstractionPool[renderable.id] = null;
	    };
	    /**
	     * //TODO
	     *
	     * @param elementsClass
	     * @returns SurfacePool
	     */
	    RendererBase.prototype.getSurfacePool = function (elements) {
	        return this._objectPools[elements.assetType];
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    RendererBase.registerAbstraction = function (renderableClass, assetClass) {
	        RendererBase._abstractionClassPool[assetClass.assetType] = renderableClass;
	    };
	    RendererBase.prototype.activatePass = function (renderableGL, pass, camera) {
	        //clear unused vertex streams
	        for (var i = pass.shader.numUsedStreams; i < this._numUsedStreams; i++)
	            this._pContext.setVertexBufferAt(i, null);
	        //clear unused texture streams
	        for (var i = pass.shader.numUsedTextures; i < this._numUsedTextures; i++)
	            this._pContext.setTextureAt(i, null);
	        //check program data is uploaded
	        var programData = pass.shader.programData;
	        if (!programData.program) {
	            programData.program = this._pContext.createProgram();
	            var vertexByteCode = (new AGALMiniAssembler_1.default().assemble("part vertex 1\n" + programData.vertexString + "endpart"))['vertex'].data;
	            var fragmentByteCode = (new AGALMiniAssembler_1.default().assemble("part fragment 1\n" + programData.fragmentString + "endpart"))['fragment'].data;
	            programData.program.upload(vertexByteCode, fragmentByteCode);
	        }
	        //set program data
	        this._pContext.setProgram(programData.program);
	        //activate shader object through renderableGL
	        renderableGL._iActivate(pass, camera);
	    };
	    RendererBase.prototype.deactivatePass = function (renderableGL, pass) {
	        //deactivate shader object
	        renderableGL._iDeactivate(pass);
	        this._numUsedStreams = pass.shader.numUsedStreams;
	        this._numUsedTextures = pass.shader.numUsedTextures;
	    };
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
	        /**
	         * The background color's red component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundR;
	        },
	        set: function (value) {
	            if (this._backgroundR == value)
	                return;
	            this._backgroundR = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
	        /**
	         * The background color's green component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundG;
	        },
	        set: function (value) {
	            if (this._backgroundG == value)
	                return;
	            this._backgroundG = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
	        /**
	         * The background color's blue component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundB;
	        },
	        set: function (value) {
	            if (this._backgroundB == value)
	                return;
	            this._backgroundB = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "context", {
	        get: function () {
	            return this._pContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "stage", {
	        /**
	         * The Stage that will provide the ContextGL used for rendering.
	         */
	        get: function () {
	            return this._pStage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Disposes the resources used by the RendererBase.
	     */
	    RendererBase.prototype.dispose = function () {
	        for (var id in this._abstractionPool)
	            this._abstractionPool[id].clear();
	        this._abstractionPool = null;
	        this._pStage.removeEventListener(StageEvent_1.default.CONTEXT_CREATED, this._onContextUpdateDelegate);
	        this._pStage.removeEventListener(StageEvent_1.default.CONTEXT_RECREATED, this._onContextUpdateDelegate);
	        this._pStage.removeEventListener(StageEvent_1.default.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	        this._pStage = null;
	        this._pContext = null;
	        /*
	         if (_backgroundImageRenderer) {
	         _backgroundImageRenderer.dispose();
	         _backgroundImageRenderer = null;
	         }
	         */
	    };
	    RendererBase.prototype.render = function (camera, scene) {
	        this._viewportDirty = false;
	        this._scissorDirty = false;
	    };
	    /**
	     * Renders the potentially visible geometry to the back buffer or texture.
	     * @param target An option target texture to render to.
	     * @param surfaceSelector The index of a CubeTexture's face to render to.
	     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
	     */
	    RendererBase.prototype._iRender = function (camera, scene, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        //TODO refactor setTarget so that rendertextures are created before this check
	        if (!this._pStage || !this._pContext)
	            return;
	        //reset head values
	        this._pBlendedRenderableHead = null;
	        this._pOpaqueRenderableHead = null;
	        this._pNumElements = 0;
	        this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : camera.frustumPlanes;
	        this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
	        this._cameraPosition = camera.scenePosition;
	        this._cameraTransform = camera.sceneTransform;
	        this._cameraForward = Matrix3DUtils_1.default.getForward(camera.sceneTransform, this._cameraForward);
	        RendererBase._iCollectionMark++;
	        scene.traversePartitions(this);
	        //sort the resulting renderables
	        if (this.renderableSorter) {
	            this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
	            this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
	        }
	        this._pRttViewProjectionMatrix.copyFrom(camera.viewProjection);
	        this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);
	        this.pExecuteRender(camera, target, scissorRect, surfaceSelector);
	        // generate mip maps on target (if target exists) //TODO
	        //if (target)
	        //	(<Texture>target).generateMipmaps();
	        // clear buffers
	        for (var i = 0; i < 8; ++i) {
	            this._pContext.setVertexBufferAt(i, null);
	            this._pContext.setTextureAt(i, null);
	        }
	    };
	    RendererBase.prototype._iRenderCascades = function (camera, scene, target, numCascades, scissorRects, cameras) {
	        this._pStage.setRenderTarget(target, true, 0);
	        this._pContext.clear(1, 1, 1, 1, 1, 0);
	        this._pContext.setBlendFactors(ContextGLBlendFactor_1.default.ONE, ContextGLBlendFactor_1.default.ZERO);
	        this._pContext.setDepthTest(true, ContextGLCompareMode_1.default.LESS);
	        var head = this._pOpaqueRenderableHead;
	        var first = true;
	        //TODO cascades must have separate collectors, rather than separate draw commands
	        for (var i = numCascades - 1; i >= 0; --i) {
	            this._pStage.scissorRect = scissorRects[i];
	            //this.drawCascadeRenderables(head, cameras[i], first? null : cameras[i].frustumPlanes);
	            first = false;
	        }
	        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
	        this._pContext.setDepthTest(false, ContextGLCompareMode_1.default.LESS_EQUAL);
	        this._pStage.scissorRect = null;
	    };
	    /**
	     * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
	     *
	     * @param target An option target texture to render to.
	     * @param surfaceSelector The index of a CubeTexture's face to render to.
	     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
	     */
	    RendererBase.prototype.pExecuteRender = function (camera, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        this._pStage.setRenderTarget(target, true, surfaceSelector);
	        if ((target || !this.shareContext) && !this._depthPrepass)
	            this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
	        this._pStage.scissorRect = scissorRect;
	        /*
	         if (_backgroundImageRenderer)
	         _backgroundImageRenderer.render();
	         */
	        this._pContext.setBlendFactors(ContextGLBlendFactor_1.default.ONE, ContextGLBlendFactor_1.default.ZERO);
	        this.pDraw(camera);
	        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
	        //this._pContext.setDepthTest(false, ContextGLCompareMode.LESS_EQUAL); //oopsie
	        if (!this.shareContext) {
	            if (this._snapshotRequired && this._snapshotBitmapImage2D) {
	                this._pContext.drawToBitmapImage2D(this._snapshotBitmapImage2D);
	                this._snapshotRequired = false;
	            }
	        }
	        this._pStage.scissorRect = null;
	    };
	    /*
	     * Will draw the renderer's output on next render to the provided bitmap data.
	     * */
	    RendererBase.prototype.queueSnapshot = function (bmd) {
	        this._snapshotRequired = true;
	        this._snapshotBitmapImage2D = bmd;
	    };
	    /**
	     * Performs the actual drawing of geometry to the target.
	     */
	    RendererBase.prototype.pDraw = function (camera) {
	        this._pContext.setDepthTest(true, ContextGLCompareMode_1.default.LESS_EQUAL);
	        if (this._disableColor)
	            this._pContext.setColorMask(false, false, false, false);
	        this.drawRenderables(camera, this._pOpaqueRenderableHead);
	        if (this._renderBlended)
	            this.drawRenderables(camera, this._pBlendedRenderableHead);
	        if (this._disableColor)
	            this._pContext.setColorMask(true, true, true, true);
	    };
	    //private drawCascadeRenderables(renderableGL:GL_RenderableBase, camera:Camera, cullPlanes:Array<Plane3D>)
	    //{
	    //	var renderableGL2:GL_RenderableBase;
	    //	var render:GL_SurfaceBase;
	    //	var pass:IPass;
	    //
	    //	while (renderableGL) {
	    //		renderableGL2 = renderableGL;
	    //		render = renderableGL.render;
	    //		pass = render.passes[0] //assuming only one pass per material
	    //
	    //		this.activatePass(renderableGL, pass, camera);
	    //
	    //		do {
	    //			// if completely in front, it will fall in a different cascade
	    //			// do not use near and far planes
	    //			if (!cullPlanes || renderableGL2.sourceEntity.worldBounds.isInFrustum(cullPlanes, 4)) {
	    //				renderableGL2._iRender(pass, camera, this._pRttViewProjectionMatrix);
	    //			} else {
	    //				renderableGL2.cascaded = true;
	    //			}
	    //
	    //			renderableGL2 = renderableGL2.next;
	    //
	    //		} while (renderableGL2 && renderableGL2.render == render && !renderableGL2.cascaded);
	    //
	    //		this.deactivatePass(renderableGL, pass);
	    //
	    //		renderableGL = renderableGL2;
	    //	}
	    //}
	    /**
	     * Draw a list of renderables.
	     *
	     * @param renderables The renderables to draw.
	     */
	    RendererBase.prototype.drawRenderables = function (camera, renderableGL) {
	        var i;
	        var len;
	        var renderableGL2;
	        var surfaceGL;
	        var passes;
	        var pass;
	        this._pContext.setStencilActions("frontAndBack", "always", "keep", "keep", "keep");
	        this._registeredMasks.length = 0;
	        var gl = this._pContext["_gl"];
	        if (gl) {
	            gl.disable(gl.STENCIL_TEST);
	        }
	        this._maskConfig = 0;
	        while (renderableGL) {
	            surfaceGL = renderableGL.surfaceGL;
	            passes = surfaceGL.passes;
	            // otherwise this would result in depth rendered anyway because fragment shader kil is ignored
	            if (this._disableColor && surfaceGL._surface.alphaThreshold != 0) {
	                renderableGL2 = renderableGL;
	                // fast forward
	                do {
	                    renderableGL2 = renderableGL2.next;
	                } while (renderableGL2 && renderableGL2.surfaceGL == surfaceGL);
	            }
	            else {
	                if (this._activeMasksDirty || this._checkMasksConfig(renderableGL.masksConfig)) {
	                    this._activeMasksConfig = renderableGL.masksConfig;
	                    if (!this._activeMasksConfig.length) {
	                        // disable stencil
	                        if (gl) {
	                            gl.disable(gl.STENCIL_TEST);
	                            gl.stencilFunc(gl.ALWAYS, 0, 0xff);
	                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	                        }
	                    }
	                    else {
	                        this._renderMasks(camera, renderableGL.sourceEntity._iAssignedMasks());
	                    }
	                    this._activeMasksDirty = false;
	                }
	                //iterate through each shader object
	                len = passes.length;
	                for (i = 0; i < len; i++) {
	                    renderableGL2 = renderableGL;
	                    pass = passes[i];
	                    this.activatePass(renderableGL, pass, camera);
	                    do {
	                        if (renderableGL2.maskId !== -1) {
	                            if (i == 0)
	                                this._registerMask(renderableGL2);
	                        }
	                        else {
	                            renderableGL2._iRender(pass, camera, this._pRttViewProjectionMatrix);
	                        }
	                        renderableGL2 = renderableGL2.next;
	                    } while (renderableGL2 && renderableGL2.surfaceGL == surfaceGL && !(this._activeMasksDirty = this._checkMasksConfig(renderableGL2.masksConfig)));
	                    this.deactivatePass(renderableGL, pass);
	                }
	            }
	            renderableGL = renderableGL2;
	        }
	    };
	    /**
	     * Assign the context once retrieved
	     */
	    RendererBase.prototype.onContextUpdate = function (event) {
	        this._pContext = this._pStage.context;
	    };
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
	        get: function () {
	            return this._backgroundAlpha;
	        },
	        set: function (value) {
	            if (this._backgroundAlpha == value)
	                return;
	            this._backgroundAlpha = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /*
	     public get iBackground():Texture2DBase
	     {
	     return this._background;
	     }
	     */
	    /*
	     public set iBackground(value:Texture2DBase)
	     {
	     if (this._backgroundImageRenderer && !value) {
	     this._backgroundImageRenderer.dispose();
	     this._backgroundImageRenderer = null;
	     }

	     if (!this._backgroundImageRenderer && value)
	     {

	     this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStage);

	     }


	     this._background = value;

	     if (this._backgroundImageRenderer)
	     this._backgroundImageRenderer.texture = value;
	     }
	     */
	    /*
	     public get backgroundImageRenderer():BackgroundImageRenderer
	     {
	     return _backgroundImageRenderer;
	     }
	     */
	    /**
	     * @private
	     */
	    RendererBase.prototype.notifyScissorUpdate = function () {
	        if (this._scissorDirty)
	            return;
	        this._scissorDirty = true;
	        if (!this._scissorUpdated)
	            this._scissorUpdated = new RendererEvent_1.default(RendererEvent_1.default.SCISSOR_UPDATED);
	        this.dispatchEvent(this._scissorUpdated);
	    };
	    /**
	     * @private
	     */
	    RendererBase.prototype.notifyViewportUpdate = function () {
	        if (this._viewportDirty)
	            return;
	        this._viewportDirty = true;
	        if (!this._viewPortUpdated)
	            this._viewPortUpdated = new RendererEvent_1.default(RendererEvent_1.default.VIEWPORT_UPDATED);
	        this.dispatchEvent(this._viewPortUpdated);
	    };
	    /**
	     *
	     */
	    RendererBase.prototype.onViewportUpdated = function (event) {
	        this._viewPort = this._pStage.viewPort;
	        //TODO stop firing viewport updated for every stagegl viewport change
	        if (this.shareContext) {
	            this._pScissorRect.x = this._globalPos.x - this._pStage.x;
	            this._pScissorRect.y = this._globalPos.y - this._pStage.y;
	            this.notifyScissorUpdate();
	        }
	        this.notifyViewportUpdate();
	    };
	    /**
	     *
	     */
	    RendererBase.prototype.updateGlobalPos = function () {
	        if (this.shareContext) {
	            this._pScissorRect.x = this._globalPos.x - this._viewPort.x;
	            this._pScissorRect.y = this._globalPos.y - this._viewPort.y;
	        }
	        else {
	            this._pScissorRect.x = 0;
	            this._pScissorRect.y = 0;
	            this._viewPort.x = this._globalPos.x;
	            this._viewPort.y = this._globalPos.y;
	        }
	        this.notifyScissorUpdate();
	    };
	    /**
	     *
	     * @param node
	     * @returns {boolean}
	     */
	    RendererBase.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase._iCollectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
	        node._iCollectionMark = RendererBase._iCollectionMark;
	        return enter;
	    };
	    RendererBase.prototype.applyEntity = function (entity) {
	        this._sourceEntity = entity;
	        // project onto camera's z-axis
	        this._zIndex = entity.zOffset + this._cameraPosition.subtract(entity.scenePosition).dotProduct(this._cameraForward);
	        //save sceneTransform
	        this._renderSceneTransform = entity.getRenderSceneTransform(this._cameraTransform);
	        //collect renderables
	        entity._acceptTraverser(this);
	    };
	    RendererBase.prototype.applyRenderable = function (renderable) {
	        var renderableGL = this.getAbstraction(renderable);
	        var surfaceGL = renderableGL.surfaceGL;
	        //set local vars for faster referencing
	        renderableGL.surfaceID = surfaceGL.surfaceID;
	        renderableGL.renderOrderId = surfaceGL.renderOrderId;
	        renderableGL.cascaded = false;
	        renderableGL.sourceEntity = this._sourceEntity;
	        renderableGL.zIndex = this._zIndex;
	        renderableGL.maskId = this._sourceEntity._iAssignedMaskId();
	        renderableGL.masksConfig = this._sourceEntity._iMasksConfig();
	        //store reference to scene transform
	        renderableGL.renderSceneTransform = this._renderSceneTransform;
	        if (surfaceGL.requiresBlending) {
	            renderableGL.next = this._pBlendedRenderableHead;
	            this._pBlendedRenderableHead = renderableGL;
	        }
	        else {
	            renderableGL.next = this._pOpaqueRenderableHead;
	            this._pOpaqueRenderableHead = renderableGL;
	        }
	        this._pNumElements += renderableGL.elements.numElements;
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyDirectionalLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyLightProbe = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyPointLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applySkybox = function (entity) {
	        //don't do anything here
	    };
	    RendererBase.prototype._registerMask = function (obj) {
	        //console.log("registerMask");
	        this._registeredMasks.push(obj);
	    };
	    RendererBase.prototype._renderMasks = function (camera, masks) {
	        var gl = this._pContext["_gl"];
	        //var oldRenderTarget = this._stage.renderTarget;
	        //this._stage.setRenderTarget(this._image);
	        //this._stage.clear();
	        this._pContext.setColorMask(false, false, false, false);
	        // TODO: Could we create masks within masks by providing a previous configID, and supply "clear/keep" on stencil fail
	        //context.setStencilActions("frontAndBack", "always", "set", "set", "set");
	        gl.enable(gl.STENCIL_TEST);
	        this._maskConfig++;
	        gl.stencilFunc(gl.ALWAYS, this._maskConfig, 0xff);
	        gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
	        var numLayers = masks.length;
	        var numRenderables = this._registeredMasks.length;
	        var renderableGL;
	        var children;
	        var numChildren;
	        var mask;
	        for (var i = 0; i < numLayers; ++i) {
	            if (i != 0) {
	                gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
	                gl.stencilOp(gl.KEEP, gl.INCR, gl.INCR);
	                this._maskConfig++;
	            }
	            children = masks[i];
	            numChildren = children.length;
	            for (var j = 0; j < numChildren; ++j) {
	                mask = children[j];
	                for (var k = 0; k < numRenderables; ++k) {
	                    renderableGL = this._registeredMasks[k];
	                    //console.log("testing for " + mask["hierarchicalMaskID"] + ", " + mask.name);
	                    if (renderableGL.maskId == mask.id) {
	                        //console.log("Rendering hierarchicalMaskID " + mask["hierarchicalMaskID"]);
	                        this._drawMask(camera, renderableGL);
	                    }
	                }
	            }
	        }
	        gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
	        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	        this._pContext.setColorMask(true, true, true, true);
	        //this._stage.setRenderTarget(oldRenderTarget);
	    };
	    RendererBase.prototype._drawMask = function (camera, renderableGL) {
	        var surfaceGL = renderableGL.surfaceGL;
	        var passes = surfaceGL.passes;
	        var len = passes.length;
	        var pass = passes[len - 1];
	        this.activatePass(renderableGL, pass, camera);
	        // only render last pass for now
	        renderableGL._iRender(pass, camera, this._pRttViewProjectionMatrix);
	        this.deactivatePass(renderableGL, pass);
	    };
	    RendererBase.prototype._checkMasksConfig = function (masksConfig) {
	        if (this._activeMasksConfig.length != masksConfig.length)
	            return true;
	        var numLayers = masksConfig.length;
	        var numChildren;
	        var childConfig;
	        var activeNumChildren;
	        var activeChildConfig;
	        for (var i = 0; i < numLayers; i++) {
	            childConfig = masksConfig[i];
	            numChildren = childConfig.length;
	            activeChildConfig = this._activeMasksConfig[i];
	            activeNumChildren = activeChildConfig.length;
	            if (activeNumChildren != numChildren)
	                return true;
	            for (var j = 0; j < numChildren; j++) {
	                if (activeChildConfig[j] != childConfig[j])
	                    return true;
	            }
	        }
	        return false;
	    };
	    RendererBase._iCollectionMark = 0;
	    RendererBase._abstractionClassPool = new Object();
	    return RendererBase;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RendererBase;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var OpcodeMap_1 = __webpack_require__(102);
	var Part_1 = __webpack_require__(106);
	var RegMap_1 = __webpack_require__(109);
	var SamplerMap_1 = __webpack_require__(110);
	var AGALMiniAssembler = (function () {
	    function AGALMiniAssembler() {
	        this.r = {};
	        this.cur = new Part_1.default();
	    }
	    AGALMiniAssembler.prototype.assemble = function (source, ext_part, ext_version) {
	        if (ext_part === void 0) { ext_part = null; }
	        if (ext_version === void 0) { ext_version = null; }
	        if (!ext_version) {
	            ext_version = 1;
	        }
	        if (ext_part) {
	            this.addHeader(ext_part, ext_version);
	        }
	        var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n"); // handle breaks, then split into lines
	        for (var i in lines) {
	            this.processLine(lines[i], i);
	        }
	        return this.r;
	    };
	    AGALMiniAssembler.prototype.processLine = function (line, linenr) {
	        var startcomment = line.search("//"); // remove comments
	        if (startcomment != -1) {
	            line = line.slice(0, startcomment);
	        }
	        line = line.replace(/^\s+|\s+$/g, ""); // remove outer space
	        if (!(line.length > 0)) {
	            return;
	        }
	        var optsi = line.search(/<.*>/g); // split of options part <*> if there
	        var opts = null;
	        if (optsi != -1) {
	            opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
	            line = line.slice(0, optsi);
	        }
	        // get opcode/command				            
	        var tokens = line.match(/([\w\.\+\[\]]+)/gi); // get tokens in line
	        if (!tokens || tokens.length < 1) {
	            if (line.length >= 3) {
	                console.log("Warning: bad line " + linenr + ": " + line);
	            }
	            return;
	        }
	        //console.log ( linenr, line, cur, tokens ); 
	        switch (tokens[0]) {
	            case "part":
	                this.addHeader(tokens[1], Number(tokens[2]));
	                break;
	            case "endpart":
	                if (!this.cur) {
	                    throw "Unexpected endpart";
	                }
	                this.cur.data.position = 0;
	                this.cur = null;
	                return;
	            default:
	                if (!this.cur) {
	                    console.log("Warning: bad line " + linenr + ": " + line + " (Outside of any part definition)");
	                    return;
	                }
	                if (this.cur.name == "comment") {
	                    return;
	                }
	                var op = OpcodeMap_1.default.map[tokens[0]];
	                if (!op) {
	                    throw "Bad opcode " + tokens[0] + " " + linenr + ": " + line;
	                }
	                // console.log( 'AGALMiniAssembler' , 'op' , op );
	                this.emitOpcode(this.cur, op.opcode);
	                var ti = 1;
	                if (op.dest && op.dest != "none") {
	                    if (!this.emitDest(this.cur, tokens[ti++], op.dest)) {
	                        throw "Bad destination register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                    }
	                }
	                else {
	                    this.emitZeroDword(this.cur);
	                }
	                if (op.a && op.a.format != "none") {
	                    if (!this.emitSource(this.cur, tokens[ti++], op.a))
	                        throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                }
	                else {
	                    this.emitZeroQword(this.cur);
	                }
	                if (op.b && op.b.format != "none") {
	                    if (op.b.format == "sampler") {
	                        if (!this.emitSampler(this.cur, tokens[ti++], op.b, opts)) {
	                            throw "Bad sampler register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                        }
	                    }
	                    else {
	                        if (!this.emitSource(this.cur, tokens[ti++], op.b)) {
	                            throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                        }
	                    }
	                }
	                else {
	                    this.emitZeroQword(this.cur);
	                }
	                break;
	        }
	    };
	    AGALMiniAssembler.prototype.emitHeader = function (pr) {
	        pr.data.writeUnsignedByte(0xa0); // tag version
	        pr.data.writeUnsignedInt(pr.version);
	        if (pr.version >= 0x10) {
	            pr.data.writeUnsignedByte(0); // align, for higher versions
	        }
	        pr.data.writeUnsignedByte(0xa1); // tag program id
	        switch (pr.name) {
	            case "fragment":
	                pr.data.writeUnsignedByte(1);
	                break;
	            case "vertex":
	                pr.data.writeUnsignedByte(0);
	                break;
	            case "cpu":
	                pr.data.writeUnsignedByte(2);
	                break;
	            default:
	                pr.data.writeUnsignedByte(0xff);
	                break; // unknown/comment
	        }
	    };
	    AGALMiniAssembler.prototype.emitOpcode = function (pr, opcode) {
	        pr.data.writeUnsignedInt(opcode);
	        //console.log ( "Emit opcode: ", opcode ); 
	    };
	    AGALMiniAssembler.prototype.emitZeroDword = function (pr) {
	        pr.data.writeUnsignedInt(0);
	    };
	    AGALMiniAssembler.prototype.emitZeroQword = function (pr) {
	        pr.data.writeUnsignedInt(0);
	        pr.data.writeUnsignedInt(0);
	    };
	    AGALMiniAssembler.prototype.emitDest = function (pr, token, opdest) {
	        //console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map' , RegMap.map);
	        var reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:mask
	        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'reg' , reg , reg[1] , RegMap.map[reg[1]] );
	        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map[reg[1]]' , RegMap.map[reg[1]] , 'bool' , !RegMap.map[reg[1]] ) ;
	        if (!RegMap_1.default.map[reg[1]])
	            return false;
	        var em = { num: reg[2] ? reg[2] : 0, code: RegMap_1.default.map[reg[1]].code, mask: this.stringToMask(reg[3]) };
	        pr.data.writeUnsignedShort(em.num);
	        pr.data.writeUnsignedByte(em.mask);
	        pr.data.writeUnsignedByte(em.code);
	        //console.log ( "  Emit dest: ", em );
	        return true;
	    };
	    AGALMiniAssembler.prototype.stringToMask = function (s) {
	        if (!s)
	            return 0xf;
	        var r = 0;
	        if (s.indexOf("x") != -1)
	            r |= 1;
	        if (s.indexOf("y") != -1)
	            r |= 2;
	        if (s.indexOf("z") != -1)
	            r |= 4;
	        if (s.indexOf("w") != -1)
	            r |= 8;
	        return r;
	    };
	    AGALMiniAssembler.prototype.stringToSwizzle = function (s) {
	        if (!s) {
	            return 0xe4;
	        }
	        var chartoindex = { x: 0, y: 1, z: 2, w: 3 };
	        var sw = 0;
	        if (s.charAt(0) != ".") {
	            throw "Missing . for swizzle";
	        }
	        if (s.length > 1) {
	            sw |= chartoindex[s.charAt(1)];
	        }
	        if (s.length > 2) {
	            sw |= chartoindex[s.charAt(2)] << 2;
	        }
	        else {
	            sw |= (sw & 3) << 2;
	        }
	        if (s.length > 3) {
	            sw |= chartoindex[s.charAt(3)] << 4;
	        }
	        else {
	            sw |= (sw & (3 << 2)) << 2;
	        }
	        if (s.length > 4) {
	            sw |= chartoindex[s.charAt(4)] << 6;
	        }
	        else {
	            sw |= (sw & (3 << 4)) << 2;
	        }
	        return sw;
	    };
	    AGALMiniAssembler.prototype.emitSampler = function (pr, token, opsrc, opts) {
	        var reg = token.match(/fs(\d*)/i); // g1:regnum
	        if (!reg || !reg[1]) {
	            return false;
	        }
	        pr.data.writeUnsignedShort(parseInt(reg[1]));
	        pr.data.writeUnsignedByte(0); // bias
	        pr.data.writeUnsignedByte(0);
	        /*
	         pr.data.writeUnsignedByte ( 0x5 );
	         pr.data.writeUnsignedByte ( 0 );   // readmode, dim
	         pr.data.writeUnsignedByte ( 0 );   // special, wrap
	         pr.data.writeUnsignedByte ( 0 );   // mip, filter
	         */
	        var samplerbits = 0x5;
	        var sampleroptset = 0;
	        for (var i = 0; i < opts.length; i++) {
	            var o = SamplerMap_1.default.map[opts[i].toLowerCase()];
	            //console.log( 'AGALMiniAssembler' , 'emitSampler' , 'SampleMap opt:' , o , '<-------- WATCH FOR THIS');
	            if (o) {
	                if (((sampleroptset >> o.shift) & o.mask) != 0) {
	                    console.log("Warning, duplicate sampler option");
	                }
	                sampleroptset |= o.mask << o.shift;
	                samplerbits &= ~(o.mask << o.shift);
	                samplerbits |= o.value << o.shift;
	            }
	            else {
	                console.log("Warning, unknown sampler option: ", opts[i]);
	            }
	        }
	        pr.data.writeUnsignedInt(samplerbits);
	        return true;
	    };
	    AGALMiniAssembler.prototype.emitSource = function (pr, token, opsrc) {
	        var indexed = token.match(/vc\[(v[tcai])(\d+)\.([xyzw])([\+\-]\d+)?\](\.[xyzw]{1,4})?/i); // g1: indexregname, g2:indexregnum, g3:select, [g4:offset], [g5:swizzle]
	        var reg;
	        if (indexed) {
	            if (!RegMap_1.default.map[indexed[1]]) {
	                return false;
	            }
	            var selindex = { x: 0, y: 1, z: 2, w: 3 };
	            var em = { num: indexed[2] | 0, code: RegMap_1.default.map[indexed[1]].code, swizzle: this.stringToSwizzle(indexed[5]), select: selindex[indexed[3]], offset: indexed[4] | 0 };
	            pr.data.writeUnsignedShort(em.num);
	            pr.data.writeByte(em.offset);
	            pr.data.writeUnsignedByte(em.swizzle);
	            pr.data.writeUnsignedByte(0x1); // constant reg
	            pr.data.writeUnsignedByte(em.code);
	            pr.data.writeUnsignedByte(em.select);
	            pr.data.writeUnsignedByte(1 << 7);
	        }
	        else {
	            reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:swizzle
	            if (!RegMap_1.default.map[reg[1]]) {
	                return false;
	            }
	            var em = { num: reg[2] | 0, code: RegMap_1.default.map[reg[1]].code, swizzle: this.stringToSwizzle(reg[3]) };
	            pr.data.writeUnsignedShort(em.num);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(em.swizzle);
	            pr.data.writeUnsignedByte(em.code);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(0);
	        }
	        return true;
	    };
	    AGALMiniAssembler.prototype.addHeader = function (partname, version) {
	        if (!version) {
	            version = 1;
	        }
	        if (this.r[partname] == undefined) {
	            this.r[partname] = new Part_1.default(partname, version);
	            this.emitHeader(this.r[partname]);
	        }
	        else if (this.r[partname].version != version) {
	            throw "Multiple versions for part " + partname;
	        }
	        this.cur = this.r[partname];
	    };
	    return AGALMiniAssembler;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AGALMiniAssembler;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Opcode_1 = __webpack_require__(103);
	var OpcodeMap = (function () {
	    function OpcodeMap() {
	    }
	    Object.defineProperty(OpcodeMap, "map", {
	        get: function () {
	            if (!OpcodeMap._map) {
	                OpcodeMap._map = new Array();
	                OpcodeMap._map['mov'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x00, true, null, null, null); //0
	                OpcodeMap._map['add'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x01, true, null, null, null); //1
	                OpcodeMap._map['sub'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x02, true, null, null, null); //2
	                OpcodeMap._map['mul'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x03, true, null, null, null); //3
	                OpcodeMap._map['div'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x04, true, null, null, null); //4
	                OpcodeMap._map['rcp'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x05, true, null, null, null); //5
	                OpcodeMap._map['min'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x06, true, null, null, null); //6
	                OpcodeMap._map['max'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x07, true, null, null, null); //7
	                OpcodeMap._map['frc'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x08, true, null, null, null); //8
	                OpcodeMap._map['sqt'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x09, true, null, null, null); //9
	                OpcodeMap._map['rsq'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x0a, true, null, null, null); //10
	                OpcodeMap._map['pow'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x0b, true, null, null, null); //11
	                OpcodeMap._map['log'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x0c, true, null, null, null); //12
	                OpcodeMap._map['exp'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x0d, true, null, null, null); //13
	                OpcodeMap._map['nrm'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x0e, true, null, null, null); //14
	                OpcodeMap._map['sin'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x0f, true, null, null, null); //15
	                OpcodeMap._map['cos'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x10, true, null, null, null); //16
	                OpcodeMap._map['crs'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x11, true, true, null, null); //17
	                OpcodeMap._map['dp3'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x12, true, true, null, null); //18
	                OpcodeMap._map['dp4'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x13, true, true, null, null); //19
	                OpcodeMap._map['abs'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x14, true, null, null, null); //20
	                OpcodeMap._map['neg'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x15, true, null, null, null); //21
	                OpcodeMap._map['sat'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x16, true, null, null, null); //22
	                OpcodeMap._map['ted'] = new Opcode_1.default("vector", "vector", 4, "sampler", 1, 0x26, true, null, true, null); //38
	                OpcodeMap._map['kil'] = new Opcode_1.default("none", "scalar", 1, "none", 0, 0x27, true, null, true, null); //39
	                OpcodeMap._map['tex'] = new Opcode_1.default("vector", "vector", 4, "sampler", 1, 0x28, true, null, true, null); //40
	                OpcodeMap._map['m33'] = new Opcode_1.default("vector", "matrix", 3, "vector", 3, 0x17, true, null, null, true); //23
	                OpcodeMap._map['m44'] = new Opcode_1.default("vector", "matrix", 4, "vector", 4, 0x18, true, null, null, true); //24
	                OpcodeMap._map['m43'] = new Opcode_1.default("vector", "matrix", 3, "vector", 4, 0x19, true, null, null, true); //25
	                OpcodeMap._map['ddx'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x1a, true, null, true, null); //26
	                OpcodeMap._map['ddy'] = new Opcode_1.default("vector", "vector", 4, "none", 0, 0x1b, true, null, true, null); //27
	                OpcodeMap._map['sge'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x29, true, null, null, null); //41
	                OpcodeMap._map['slt'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x2a, true, null, null, null); //42
	                OpcodeMap._map['sgn'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x2b, true, null, null, null); //43
	                OpcodeMap._map['seq'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x2c, true, null, null, null); //44
	                OpcodeMap._map['sne'] = new Opcode_1.default("vector", "vector", 4, "vector", 4, 0x2d, true, null, null, null); //45
	            }
	            return OpcodeMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return OpcodeMap;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OpcodeMap;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Flags_1 = __webpack_require__(104);
	var FS_1 = __webpack_require__(105);
	/**
	 *
	 */
	var Opcode = (function () {
	    function Opcode(dest, aformat, asize, bformat, bsize, opcode, simple, horizontal, fragonly, matrix) {
	        this.a = new FS_1.default();
	        this.b = new FS_1.default();
	        this.flags = new Flags_1.default();
	        this.dest = dest;
	        this.a.format = aformat;
	        this.a.size = asize;
	        this.b.format = bformat;
	        this.b.size = bsize;
	        this.opcode = opcode;
	        this.flags.simple = simple;
	        this.flags.horizontal = horizontal;
	        this.flags.fragonly = fragonly;
	        this.flags.matrix = matrix;
	    }
	    return Opcode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Opcode;


/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";
	var Flags = (function () {
	    function Flags() {
	    }
	    return Flags;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Flags;


/***/ },
/* 105 */
/***/ function(module, exports) {

	"use strict";
	var FS = (function () {
	    function FS() {
	    }
	    return FS;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FS;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ByteArray_1 = __webpack_require__(107);
	var Part = (function () {
	    function Part(name, version) {
	        if (name === void 0) { name = null; }
	        if (version === void 0) { version = null; }
	        this.name = "";
	        this.version = 0;
	        this.name = name;
	        this.version = version;
	        this.data = new ByteArray_1.default();
	    }
	    return Part;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Part;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ByteArrayBase_1 = __webpack_require__(108);
	var ByteArray = (function (_super) {
	    __extends(ByteArray, _super);
	    function ByteArray(maxlength) {
	        if (maxlength === void 0) { maxlength = 4; }
	        _super.call(this);
	        this._mode = "Typed array";
	        this.maxlength = Math.max((maxlength + 255) & (~255), 4);
	        this.arraybytes = new ArrayBuffer(this.maxlength);
	        this.unalignedarraybytestemp = new ArrayBuffer(16);
	    }
	    ByteArray.prototype.ensureWriteableSpace = function (n) {
	        this.ensureSpace(n + this.position);
	    };
	    ByteArray.prototype.setArrayBuffer = function (aBuffer) {
	        this.ensureSpace(aBuffer.byteLength);
	        this.length = aBuffer.byteLength;
	        var inInt8AView = new Int8Array(aBuffer);
	        var localInt8View = new Int8Array(this.arraybytes, 0, this.length);
	        localInt8View.set(inInt8AView);
	        this.position = 0;
	    };
	    ByteArray.prototype.getBytesAvailable = function () {
	        return (this.length) - (this.position);
	    };
	    ByteArray.prototype.ensureSpace = function (n) {
	        if (n > this.maxlength) {
	            var newmaxlength = (n + 255) & (~255);
	            var newarraybuffer = new ArrayBuffer(newmaxlength);
	            var view = new Uint8Array(this.arraybytes, 0, this.length);
	            var newview = new Uint8Array(newarraybuffer, 0, this.length);
	            newview.set(view); // memcpy
	            this.arraybytes = newarraybuffer;
	            this.maxlength = newmaxlength;
	        }
	    };
	    ByteArray.prototype.writeByte = function (b) {
	        this.ensureWriteableSpace(1);
	        var view = new Int8Array(this.arraybytes);
	        view[this.position++] = (~~b); // ~~ is cast to int in js...
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArray.prototype.readByte = function () {
	        if (this.position >= this.length)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        var view = new Int8Array(this.arraybytes);
	        return view[this.position++];
	    };
	    ByteArray.prototype.readBytes = function (bytes, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = 0; }
	        if (length == null)
	            length = bytes.length;
	        bytes.ensureWriteableSpace(offset + length);
	        var byteView = new Int8Array(bytes.arraybytes);
	        var localByteView = new Int8Array(this.arraybytes);
	        byteView.set(localByteView.subarray(this.position, this.position + length), offset);
	        this.position += length;
	        if (length + offset > bytes.length)
	            bytes.length += (length + offset) - bytes.length;
	    };
	    ByteArray.prototype.writeUnsignedByte = function (b) {
	        this.ensureWriteableSpace(1);
	        var view = new Uint8Array(this.arraybytes);
	        view[this.position++] = (~~b) & 0xff; // ~~ is cast to int in js...
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUnsignedByte = function () {
	        if (this.position >= this.length)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        var view = new Uint8Array(this.arraybytes);
	        return view[this.position++];
	    };
	    ByteArray.prototype.writeUnsignedShort = function (b) {
	        this.ensureWriteableSpace(2);
	        if ((this.position & 1) == 0) {
	            var view = new Uint16Array(this.arraybytes);
	            view[this.position >> 1] = (~~b) & 0xffff; // ~~ is cast to int in js...
	        }
	        else {
	            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = (~~b) & 0xffff;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
	            view2.set(view3);
	        }
	        this.position += 2;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUTFBytes = function (len) {
	        var value = "";
	        var max = this.position + len;
	        var data = new DataView(this.arraybytes);
	        // utf8-encode
	        while (this.position < max) {
	            var c = data.getUint8(this.position++);
	            if (c < 0x80) {
	                if (c == 0)
	                    break;
	                value += String.fromCharCode(c);
	            }
	            else if (c < 0xE0) {
	                value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.position++) & 0x7F));
	            }
	            else if (c < 0xF0) {
	                var c2 = data.getUint8(this.position++);
	                value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.position++) & 0x7F));
	            }
	            else {
	                var c2 = data.getUint8(this.position++);
	                var c3 = data.getUint8(this.position++);
	                value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.position++) & 0x7F));
	            }
	        }
	        return value;
	    };
	    ByteArray.prototype.readInt = function () {
	        var data = new DataView(this.arraybytes);
	        var int = data.getInt32(this.position, true);
	        this.position += 4;
	        return int;
	    };
	    ByteArray.prototype.readShort = function () {
	        var data = new DataView(this.arraybytes);
	        var short = data.getInt16(this.position, true);
	        this.position += 2;
	        return short;
	    };
	    ByteArray.prototype.readDouble = function () {
	        var data = new DataView(this.arraybytes);
	        var double = data.getFloat64(this.position, true);
	        this.position += 8;
	        return double;
	    };
	    ByteArray.prototype.readUnsignedShort = function () {
	        if (this.position > this.length + 2)
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        if ((this.position & 1) == 0) {
	            var view = new Uint16Array(this.arraybytes);
	            var pa = this.position >> 1;
	            this.position += 2;
	            return view[pa];
	        }
	        else {
	            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
	            view3.set(view2);
	            this.position += 2;
	            return view[0];
	        }
	    };
	    ByteArray.prototype.writeUnsignedInt = function (b) {
	        this.ensureWriteableSpace(4);
	        if ((this.position & 3) == 0) {
	            var view = new Uint32Array(this.arraybytes);
	            view[this.position >> 2] = (~~b) & 0xffffffff; // ~~ is cast to int in js...
	        }
	        else {
	            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = (~~b) & 0xffffffff;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view2.set(view3);
	        }
	        this.position += 4;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUnsignedInt = function () {
	        if (this.position > this.length + 4)
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        if ((this.position & 3) == 0) {
	            var view = new Uint32Array(this.arraybytes);
	            var pa = this.position >> 2;
	            this.position += 4;
	            return view[pa];
	        }
	        else {
	            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view3.set(view2);
	            this.position += 4;
	            return view[0];
	        }
	    };
	    ByteArray.prototype.writeFloat = function (b) {
	        this.ensureWriteableSpace(4);
	        if ((this.position & 3) == 0) {
	            var view = new Float32Array(this.arraybytes);
	            view[this.position >> 2] = b;
	        }
	        else {
	            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = b;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view2.set(view3);
	        }
	        this.position += 4;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readFloat = function () {
	        if (this.position > this.length + 4)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        if ((this.position & 3) == 0) {
	            var view = new Float32Array(this.arraybytes);
	            var pa = this.position >> 2;
	            this.position += 4;
	            return view[pa];
	        }
	        else {
	            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view3.set(view2);
	            this.position += 4;
	            return view[0];
	        }
	    };
	    return ByteArray;
	}(ByteArrayBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ByteArray;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(20);
	var ByteArrayBase = (function () {
	    function ByteArrayBase() {
	        this.position = 0;
	        this.length = 0;
	        this._mode = "";
	    }
	    ByteArrayBase.prototype.writeByte = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readByte = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedByte = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedByte = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedShort = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedShort = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedInt = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedInt = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeFloat = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.toFloatBits = function (x) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readFloat = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.fromFloatBits = function (x) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.getBytesAvailable = function () {
	        throw new AbstractMethodError_1.default('ByteArrayBase, getBytesAvailable() not implemented ');
	    };
	    ByteArrayBase.prototype.toString = function () {
	        return "[ByteArray] ( " + this._mode + " ) position=" + this.position + " length=" + this.length;
	    };
	    ByteArrayBase.prototype.compareEqual = function (other, count) {
	        if (count == undefined || count > this.length - this.position)
	            count = this.length - this.position;
	        if (count > other.length - other.position)
	            count = other.length - other.position;
	        var co0 = count;
	        var r = true;
	        while (r && count >= 4) {
	            count -= 4;
	            if (this.readUnsignedInt() != other.readUnsignedInt())
	                r = false;
	        }
	        while (r && count >= 1) {
	            count--;
	            if (this.readUnsignedByte() != other.readUnsignedByte())
	                r = false;
	        }
	        var c0;
	        this.position -= (c0 - count);
	        other.position -= (c0 - count);
	        return r;
	    };
	    ByteArrayBase.prototype.writeBase64String = function (s) {
	        for (var i = 0; i < s.length; i++) {
	            var v = s.charAt(i);
	        }
	    };
	    ByteArrayBase.prototype.dumpToConsole = function () {
	        var oldpos = this.position;
	        this.position = 0;
	        var nstep = 8;
	        function asHexString(x, digits) {
	            var lut = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
	            var sh = "";
	            for (var d = 0; d < digits; d++) {
	                sh = lut[(x >> (d << 2)) & 0xf] + sh;
	            }
	            return sh;
	        }
	        for (var i = 0; i < this.length; i += nstep) {
	            var s = asHexString(i, 4) + ":";
	            for (var j = 0; j < nstep && i + j < this.length; j++) {
	                s += " " + asHexString(this.readUnsignedByte(), 2);
	            }
	            console.log(s);
	        }
	        this.position = oldpos;
	    };
	    ByteArrayBase.prototype.readBase64String = function (count) {
	        if (count == undefined || count > this.length - this.position)
	            count = this.length - this.position;
	        if (!(count > 0))
	            return "";
	        return ByteArrayBase.internalGetBase64String(count, this.readUnsignedByte, this);
	    };
	    ByteArrayBase.internalGetBase64String = function (count, getUnsignedByteFunc, self) {
	        var r = "";
	        var b0, b1, b2, enc1, enc2, enc3, enc4;
	        var base64Key = ByteArrayBase.Base64Key;
	        while (count >= 3) {
	            b0 = getUnsignedByteFunc.apply(self);
	            b1 = getUnsignedByteFunc.apply(self);
	            b2 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
	            enc3 = ((b1 & 15) << 2) | (b2 >> 6);
	            enc4 = b2 & 63;
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + base64Key.charAt(enc4);
	            count -= 3;
	        }
	        // pad
	        if (count == 2) {
	            b0 = getUnsignedByteFunc.apply(self);
	            b1 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
	            enc3 = ((b1 & 15) << 2);
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + "=";
	        }
	        else if (count == 1) {
	            b0 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4);
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + "==";
	        }
	        return r;
	    };
	    ByteArrayBase.Base64Key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	    return ByteArrayBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ByteArrayBase;


/***/ },
/* 109 */
/***/ function(module, exports) {

	"use strict";
	var Reg = (function () {
	    function Reg(code, desc) {
	        this.code = code;
	        this.desc = desc;
	    }
	    return Reg;
	}());
	var RegMap = (function () {
	    /*
	     public static va:Reg = new Reg( 0x00, "vertex attribute" );
	     public static fc:Reg = new Reg( 0x01, "fragment constant" );
	     public static vc:Reg = new Reg( 0x01, "vertex constant" );
	     public static ft:Reg = new Reg( 0x02, "fragment temporary" );
	     public static vt:Reg = new Reg( 0x02, "vertex temporary" );
	     public static vo:Reg = new Reg( 0x03, "vertex output" );
	     public static op:Reg = new Reg( 0x03, "vertex output" );
	     public static fd:Reg = new Reg( 0x03, "fragment depth output" );
	     public static fo:Reg = new Reg( 0x03, "fragment output" );
	     public static oc:Reg = new Reg( 0x03, "fragment output" );
	     public static v: Reg = new Reg( 0x04, "varying" );
	     public static vi:Reg = new Reg( 0x04, "varying output" );
	     public static fi:Reg = new Reg( 0x04, "varying input" );
	     public static fs:Reg = new Reg( 0x05, "sampler" );
	     */
	    function RegMap() {
	    }
	    Object.defineProperty(RegMap, "map", {
	        get: function () {
	            if (!RegMap._map) {
	                RegMap._map = new Array();
	                RegMap._map['va'] = new Reg(0x00, "vertex attribute");
	                RegMap._map['fc'] = new Reg(0x01, "fragment constant");
	                RegMap._map['vc'] = new Reg(0x01, "vertex constant");
	                RegMap._map['ft'] = new Reg(0x02, "fragment temporary");
	                RegMap._map['vt'] = new Reg(0x02, "vertex temporary");
	                RegMap._map['vo'] = new Reg(0x03, "vertex output");
	                RegMap._map['op'] = new Reg(0x03, "vertex output");
	                RegMap._map['fd'] = new Reg(0x03, "fragment depth output");
	                RegMap._map['fo'] = new Reg(0x03, "fragment output");
	                RegMap._map['oc'] = new Reg(0x03, "fragment output");
	                RegMap._map['v'] = new Reg(0x04, "varying");
	                RegMap._map['vi'] = new Reg(0x04, "varying output");
	                RegMap._map['fi'] = new Reg(0x04, "varying input");
	                RegMap._map['fs'] = new Reg(0x05, "sampler");
	            }
	            return RegMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RegMap;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RegMap;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Sampler_1 = __webpack_require__(111);
	var SamplerMap = (function () {
	    /*
	     public static map =     [ new Sampler( 8, 0xf, 0 ),
	     new Sampler( 8, 0xf, 5 ),
	     new Sampler( 8, 0xf, 4 ),
	     new Sampler( 8, 0xf, 1 ),
	     new Sampler( 8, 0xf, 2 ),
	     new Sampler( 8, 0xf, 1 ),
	     new Sampler( 8, 0xf, 2 ),

	     // dimension
	     new Sampler( 12, 0xf, 0 ),
	     new Sampler( 12, 0xf, 1 ),
	     new Sampler( 12, 0xf, 2 ),

	     // special
	     new Sampler( 16, 1, 1 ),
	     new Sampler( 16, 4, 4 ),

	     // repeat
	     new Sampler( 20, 0xf, 0 ),
	     new Sampler( 20, 0xf, 1 ),
	     new Sampler( 20, 0xf, 1 ),

	     // mip
	     new Sampler( 24, 0xf, 0 ),
	     new Sampler( 24, 0xf, 0 ),
	     new Sampler( 24, 0xf, 1 ),
	     new Sampler( 24, 0xf, 2 ),

	     // filter
	     new Sampler( 28, 0xf, 0 ),
	     new Sampler( 28, 0xf, 1 ) ]
	     */
	    /*
	     public static rgba: Sampler = new Sampler( 8, 0xf, 0 );
	     public static rg: Sampler = new Sampler( 8, 0xf, 5 );
	     public static r: Sampler = new Sampler( 8, 0xf, 4 );
	     public static compressed: Sampler = new Sampler( 8, 0xf, 1 );
	     public static compressed_alpha: Sampler = new Sampler( 8, 0xf, 2 );
	     public static dxt1: Sampler = new Sampler( 8, 0xf, 1 );
	     public static dxt5: Sampler = new Sampler( 8, 0xf, 2 );

	     // dimension
	     public static sampler2d: Sampler = new Sampler( 12, 0xf, 0 );
	     public static cube: Sampler = new Sampler( 12, 0xf, 1 );
	     public static sampler3d: Sampler = new Sampler( 12, 0xf, 2 );

	     // special
	     public static centroid: Sampler = new Sampler( 16, 1, 1 );
	     public static ignoresampler: Sampler = new Sampler( 16, 4, 4 );

	     // repeat
	     public static clamp: Sampler = new Sampler( 20, 0xf, 0 );
	     public static repeat: Sampler = new Sampler( 20, 0xf, 1 );
	     public static wrap: Sampler = new Sampler( 20, 0xf, 1 );

	     // mip
	     public static nomip: Sampler = new Sampler( 24, 0xf, 0 );
	     public static mipnone: Sampler = new Sampler( 24, 0xf, 0 );
	     public static mipnearest: Sampler = new Sampler( 24, 0xf, 1 );
	     public static miplinear: Sampler = new Sampler( 24, 0xf, 2 );

	     // filter
	     public static nearest: Sampler = new Sampler( 28, 0xf, 0 );
	     public static linear: Sampler = new Sampler( 28, 0xf, 1 );
	     */
	    function SamplerMap() {
	    }
	    Object.defineProperty(SamplerMap, "map", {
	        get: function () {
	            if (!SamplerMap._map) {
	                SamplerMap._map = new Array();
	                SamplerMap._map['rgba'] = new Sampler_1.default(8, 0xf, 0);
	                SamplerMap._map['rg'] = new Sampler_1.default(8, 0xf, 5);
	                SamplerMap._map['r'] = new Sampler_1.default(8, 0xf, 4);
	                SamplerMap._map['compressed'] = new Sampler_1.default(8, 0xf, 1);
	                SamplerMap._map['compressed_alpha'] = new Sampler_1.default(8, 0xf, 2);
	                SamplerMap._map['dxt1'] = new Sampler_1.default(8, 0xf, 1);
	                SamplerMap._map['dxt5'] = new Sampler_1.default(8, 0xf, 2);
	                // dimension
	                SamplerMap._map['2d'] = new Sampler_1.default(12, 0xf, 0);
	                SamplerMap._map['cube'] = new Sampler_1.default(12, 0xf, 1);
	                SamplerMap._map['3d'] = new Sampler_1.default(12, 0xf, 2);
	                // special
	                SamplerMap._map['centroid'] = new Sampler_1.default(16, 1, 1);
	                SamplerMap._map['ignoresampler'] = new Sampler_1.default(16, 4, 4);
	                // repeat
	                SamplerMap._map['clamp'] = new Sampler_1.default(20, 0xf, 0);
	                SamplerMap._map['repeat'] = new Sampler_1.default(20, 0xf, 1);
	                SamplerMap._map['wrap'] = new Sampler_1.default(20, 0xf, 1);
	                // mip
	                SamplerMap._map['nomip'] = new Sampler_1.default(24, 0xf, 0);
	                SamplerMap._map['mipnone'] = new Sampler_1.default(24, 0xf, 0);
	                SamplerMap._map['mipnearest'] = new Sampler_1.default(24, 0xf, 1);
	                SamplerMap._map['miplinear'] = new Sampler_1.default(24, 0xf, 2);
	                // filter
	                SamplerMap._map['nearest'] = new Sampler_1.default(28, 0xf, 0);
	                SamplerMap._map['linear'] = new Sampler_1.default(28, 0xf, 1);
	            }
	            return SamplerMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SamplerMap;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SamplerMap;


/***/ },
/* 111 */
/***/ function(module, exports) {

	"use strict";
	var Sampler = (function () {
	    function Sampler(shift, mask, value) {
	        this.shift = shift;
	        this.mask = mask;
	        this.value = value;
	    }
	    return Sampler;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Sampler;


/***/ },
/* 112 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLBlendFactor = (function () {
	    function ContextGLBlendFactor() {
	    }
	    ContextGLBlendFactor.DESTINATION_ALPHA = "destinationAlpha";
	    ContextGLBlendFactor.DESTINATION_COLOR = "destinationColor";
	    ContextGLBlendFactor.ONE = "one";
	    ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA = "oneMinusDestinationAlpha";
	    ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR = "oneMinusDestinationColor";
	    ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA = "oneMinusSourceAlpha";
	    ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR = "oneMinusSourceColor";
	    ContextGLBlendFactor.SOURCE_ALPHA = "sourceAlpha";
	    ContextGLBlendFactor.SOURCE_COLOR = "sourceColor";
	    ContextGLBlendFactor.ZERO = "zero";
	    return ContextGLBlendFactor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLBlendFactor;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var StageEvent = (function (_super) {
	    __extends(StageEvent, _super);
	    function StageEvent(type, stage) {
	        _super.call(this, type);
	        this._stage = stage;
	    }
	    Object.defineProperty(StageEvent.prototype, "stage", {
	        /**
	         *
	         */
	        get: function () {
	            return this._stage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    StageEvent.prototype.clone = function () {
	        return new StageEvent(this.type, this._stage);
	    };
	    /**
	     *
	     */
	    StageEvent.STAGE_ERROR = "stageError";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_CREATED = "contextCreated";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_DISPOSED = "contextDisposed";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_RECREATED = "contextRecreated";
	    /**
	     *
	     */
	    StageEvent.VIEWPORT_UPDATED = "viewportUpdated";
	    return StageEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StageEvent;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(12);
	var ArgumentError_1 = __webpack_require__(33);
	var Stage_1 = __webpack_require__(115);
	var StageEvent_1 = __webpack_require__(113);
	/**
	 * The StageManager class provides a multiton object that handles management for Stage objects.
	 *
	 * @see away.base.Stage
	 */
	var StageManager = (function (_super) {
	    __extends(StageManager, _super);
	    /**
	     * Creates a new StageManager class.
	     * @param stage The Stage object that contains the Stage objects to be managed.
	     * @private
	     */
	    function StageManager() {
	        var _this = this;
	        _super.call(this);
	        this._stages = new Array(StageManager.STAGE_MAX_QUANTITY);
	        this._onContextCreatedDelegate = function (event) { return _this.onContextCreated(event); };
	    }
	    /**
	     * Gets a StageManager instance for the given Stage object.
	     * @param stage The Stage object that contains the Stage objects to be managed.
	     * @return The StageManager instance for the given Stage object.
	     */
	    StageManager.getInstance = function () {
	        if (this._instance == null)
	            this._instance = new StageManager();
	        return this._instance;
	    };
	    /**
	     * Requests the Stage for the given index.
	     *
	     * @param index The index of the requested Stage.
	     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
	     * @param profile The compatibility profile, an enumeration of ContextProfile
	     * @return The Stage for the given index.
	     */
	    StageManager.prototype.getStageAt = function (index, forceSoftware, profile, mode) {
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        if (index < 0 || index >= StageManager.STAGE_MAX_QUANTITY)
	            throw new ArgumentError_1.default("Index is out of bounds [0.." + StageManager.STAGE_MAX_QUANTITY + "]");
	        if (!this._stages[index]) {
	            StageManager._numStages++;
	            if (document) {
	                var canvas = document.createElement("canvas");
	                canvas.id = "stage" + index;
	                document.body.appendChild(canvas);
	            }
	            var stage = this._stages[index] = new Stage_1.default(canvas, index, this, forceSoftware, profile);
	            stage.addEventListener(StageEvent_1.default.CONTEXT_CREATED, this._onContextCreatedDelegate);
	            stage.requestContext(forceSoftware, profile, mode);
	        }
	        return stage;
	    };
	    /**
	     * Removes a Stage from the manager.
	     * @param stage
	     * @private
	     */
	    StageManager.prototype.iRemoveStage = function (stage) {
	        StageManager._numStages--;
	        stage.removeEventListener(StageEvent_1.default.CONTEXT_CREATED, this._onContextCreatedDelegate);
	        this._stages[stage.stageIndex] = null;
	    };
	    /**
	     * Get the next available stage. An error is thrown if there are no StageProxies available
	     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
	     * @param profile The compatibility profile, an enumeration of ContextProfile
	     * @return The allocated stage
	     */
	    StageManager.prototype.getFreeStage = function (forceSoftware, profile, mode) {
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        var i = 0;
	        var len = this._stages.length;
	        while (i < len) {
	            if (!this._stages[i])
	                return this.getStageAt(i, forceSoftware, profile, mode);
	            ++i;
	        }
	        return null;
	    };
	    Object.defineProperty(StageManager.prototype, "hasFreeStage", {
	        /**
	         * Checks if a new stage can be created and managed by the class.
	         * @return true if there is one slot free for a new stage
	         */
	        get: function () {
	            return StageManager._numStages < StageManager.STAGE_MAX_QUANTITY ? true : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsFree", {
	        /**
	         * Returns the amount of stage objects that can be created and managed by the class
	         * @return the amount of free slots
	         */
	        get: function () {
	            return StageManager.STAGE_MAX_QUANTITY - StageManager._numStages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsUsed", {
	        /**
	         * Returns the amount of Stage objects currently managed by the class.
	         * @return the amount of slots used
	         */
	        get: function () {
	            return StageManager._numStages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsTotal", {
	        /**
	         * The maximum amount of Stage objects that can be managed by the class
	         */
	        get: function () {
	            return this._stages.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    StageManager.prototype.onContextCreated = function (event) {
	        //var stage:Stage = <Stage> e.target;
	        //document.body.appendChild(stage.canvas)
	    };
	    StageManager.STAGE_MAX_QUANTITY = 8;
	    StageManager._numStages = 0;
	    return StageManager;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StageManager;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(12);
	var Rectangle_1 = __webpack_require__(35);
	var CSS_1 = __webpack_require__(116);
	var ContextGLMipFilter_1 = __webpack_require__(117);
	var ContextGLTextureFilter_1 = __webpack_require__(118);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(119);
	var ContextGLWrapMode_1 = __webpack_require__(120);
	var ContextWebGL_1 = __webpack_require__(121);
	var StageEvent_1 = __webpack_require__(113);
	var ProgramDataPool_1 = __webpack_require__(141);
	/**
	 * Stage provides a proxy class to handle the creation and attachment of the Context
	 * (and in turn the back buffer) it uses. Stage should never be created directly,
	 * but requested through StageManager.
	 *
	 * @see away.managers.StageManager
	 *
	 */
	var Stage = (function (_super) {
	    __extends(Stage, _super);
	    function Stage(container, stageIndex, stageManager, forceSoftware, profile) {
	        var _this = this;
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        _super.call(this);
	        this._abstractionPool = new Object();
	        this._programData = new Array();
	        this._x = 0;
	        this._y = 0;
	        //private static _frameEventDriver:Shape = new Shape(); // TODO: add frame driver / request animation frame
	        this._stageIndex = -1;
	        this._antiAlias = 0;
	        //private var _activeVertexBuffers : Vector.<VertexBuffer> = new Vector.<VertexBuffer>(8, true);
	        //private var _activeTextures : Vector.<TextureBase> = new Vector.<TextureBase>(8, true);
	        this._renderTarget = null;
	        this._renderSurfaceSelector = 0;
	        //private _mouse3DManager:away.managers.Mouse3DManager;
	        //private _touch3DManager:Touch3DManager; //TODO: imeplement dependency Touch3DManager
	        this._initialised = false;
	        this._bufferFormatDictionary = new Array(5);
	        this._programDataPool = new ProgramDataPool_1.default(this);
	        this._container = container;
	        if (this._container) {
	            this._container.addEventListener("webglcontextlost", function (event) { return _this.onContextLost(event); });
	            this._container.addEventListener("webglcontextrestored", function (event) { return _this.onContextRestored(event); });
	        }
	        this._stageIndex = stageIndex;
	        this._stageManager = stageManager;
	        this._viewPort = new Rectangle_1.default();
	        this._enableDepthAndStencil = true;
	        CSS_1.default.setElementX(this._container, 0);
	        CSS_1.default.setElementY(this._container, 0);
	        this._bufferFormatDictionary[1] = new Array(5);
	        this._bufferFormatDictionary[1][1] = ContextGLVertexBufferFormat_1.default.BYTE_1;
	        this._bufferFormatDictionary[1][2] = ContextGLVertexBufferFormat_1.default.BYTE_2;
	        this._bufferFormatDictionary[1][3] = ContextGLVertexBufferFormat_1.default.BYTE_3;
	        this._bufferFormatDictionary[1][4] = ContextGLVertexBufferFormat_1.default.BYTE_4;
	        this._bufferFormatDictionary[2] = new Array(5);
	        this._bufferFormatDictionary[2][1] = ContextGLVertexBufferFormat_1.default.SHORT_1;
	        this._bufferFormatDictionary[2][2] = ContextGLVertexBufferFormat_1.default.SHORT_2;
	        this._bufferFormatDictionary[2][3] = ContextGLVertexBufferFormat_1.default.SHORT_3;
	        this._bufferFormatDictionary[2][4] = ContextGLVertexBufferFormat_1.default.SHORT_4;
	        this._bufferFormatDictionary[4] = new Array(5);
	        this._bufferFormatDictionary[4][1] = ContextGLVertexBufferFormat_1.default.FLOAT_1;
	        this._bufferFormatDictionary[4][2] = ContextGLVertexBufferFormat_1.default.FLOAT_2;
	        this._bufferFormatDictionary[4][3] = ContextGLVertexBufferFormat_1.default.FLOAT_3;
	        this._bufferFormatDictionary[4][4] = ContextGLVertexBufferFormat_1.default.FLOAT_4;
	        this._bufferFormatDictionary[5] = new Array(5);
	        this._bufferFormatDictionary[5][1] = ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_1;
	        this._bufferFormatDictionary[5][2] = ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_2;
	        this._bufferFormatDictionary[5][3] = ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_3;
	        this._bufferFormatDictionary[5][4] = ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_4;
	        this._bufferFormatDictionary[6] = new Array(5);
	        this._bufferFormatDictionary[6][1] = ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_1;
	        this._bufferFormatDictionary[6][2] = ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_2;
	        this._bufferFormatDictionary[6][3] = ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_3;
	        this._bufferFormatDictionary[6][4] = ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_4;
	        this.visible = true;
	    }
	    Stage.prototype.getProgramData = function (vertexString, fragmentString) {
	        return this._programDataPool.getItem(vertexString, fragmentString);
	    };
	    Stage.prototype.setRenderTarget = function (target, enableDepthAndStencil, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        if (this._renderTarget === target && surfaceSelector == this._renderSurfaceSelector && this._enableDepthAndStencil == enableDepthAndStencil)
	            return;
	        this._renderTarget = target;
	        this._renderSurfaceSelector = surfaceSelector;
	        this._enableDepthAndStencil = enableDepthAndStencil;
	        if (target) {
	            this._context.setRenderToTexture(this.getAbstraction(target).texture, enableDepthAndStencil, this._antiAlias, surfaceSelector);
	        }
	        else {
	            this._context.setRenderToBackBuffer();
	            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	        }
	    };
	    Stage.prototype.getAbstraction = function (asset) {
	        return (this._abstractionPool[asset.id] || (this._abstractionPool[asset.id] = new Stage._abstractionClassPool[asset.assetType](asset, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    Stage.prototype.clearAbstraction = function (asset) {
	        this._abstractionPool[asset.id] = null;
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    Stage.registerAbstraction = function (gl_assetClass, assetClass) {
	        Stage._abstractionClassPool[assetClass.assetType] = gl_assetClass;
	    };
	    /**
	     * Requests a Context object to attach to the managed gl canvas.
	     */
	    Stage.prototype.requestContext = function (forceSoftware, profile, mode) {
	        // If forcing software, we can be certain that the
	        // returned Context will be running software mode.
	        // If not, we can't be sure and should stick to the
	        // old value (will likely be same if re-requesting.)
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        if (this._usesSoftwareRendering != null)
	            this._usesSoftwareRendering = forceSoftware;
	        this._profile = profile;
	        try {
	            // if (mode == ContextMode.FLASH)
	            // 	new ContextStage3D(<HTMLCanvasElement> this._container, (context:IContextGL) => this._callback(context));
	            // else if(mode == ContextMode.SOFTWARE)
	            // 	this._context = new ContextSoftware(<HTMLCanvasElement> this._container);
	            // else
	            this._context = new ContextWebGL_1.default(this._container);
	        }
	        catch (e) {
	        }
	        if (this._context)
	            this._callback(this._context);
	    };
	    Object.defineProperty(Stage.prototype, "width", {
	        /**
	         * The width of the gl canvas
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (val) {
	            if (this._width == val)
	                return;
	            CSS_1.default.setElementWidth(this._container, val);
	            this._width = this._viewPort.width = val;
	            this._backBufferDirty = true;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "height", {
	        /**
	         * The height of the gl canvas
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (val) {
	            if (this._height == val)
	                return;
	            CSS_1.default.setElementHeight(this._container, val);
	            this._height = this._viewPort.height = val;
	            this._backBufferDirty = true;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "x", {
	        /**
	         * The x position of the gl canvas
	         */
	        get: function () {
	            return this._x;
	        },
	        set: function (val) {
	            if (this._x == val)
	                return;
	            CSS_1.default.setElementX(this._container, val);
	            this._x = this._viewPort.x = val;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "y", {
	        /**
	         * The y position of the gl canvas
	         */
	        get: function () {
	            return this._y;
	        },
	        set: function (val) {
	            if (this._y == val)
	                return;
	            CSS_1.default.setElementY(this._container, val);
	            this._y = this._viewPort.y = val;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "visible", {
	        get: function () {
	            return CSS_1.default.getElementVisibility(this._container);
	        },
	        set: function (val) {
	            CSS_1.default.setElementVisibility(this._container, val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "context", {
	        /**
	         * The Context object associated with the given stage object.
	         */
	        get: function () {
	            return this._context;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Stage.prototype.notifyViewportUpdated = function () {
	        if (this._viewportDirty)
	            return;
	        this._viewportDirty = true;
	        this.dispatchEvent(new StageEvent_1.default(StageEvent_1.default.VIEWPORT_UPDATED, this));
	    };
	    Object.defineProperty(Stage.prototype, "profile", {
	        get: function () {
	            return this._profile;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Disposes the Stage object, freeing the Context attached to the Stage.
	     */
	    Stage.prototype.dispose = function () {
	        for (var id in this._abstractionPool)
	            this._abstractionPool[id].clear();
	        this._abstractionPool = null;
	        this._stageManager.iRemoveStage(this);
	        this.freeContext();
	        this._stageManager = null;
	        this._stageIndex = -1;
	    };
	    /**
	     * Configures the back buffer associated with the Stage object.
	     * @param backBufferWidth The width of the backbuffer.
	     * @param backBufferHeight The height of the backbuffer.
	     * @param antiAlias The amount of anti-aliasing to use.
	     * @param enableDepthAndStencil Indicates whether the back buffer contains a depth and stencil buffer.
	     */
	    Stage.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil) {
	        this.width = backBufferWidth;
	        this.height = backBufferHeight;
	        this._antiAlias = antiAlias;
	        this._enableDepthAndStencil = enableDepthAndStencil;
	        if (this._context)
	            this._context.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil);
	    };
	    Object.defineProperty(Stage.prototype, "enableDepthAndStencil", {
	        /*
	         * Indicates whether the depth and stencil buffer is used
	         */
	        get: function () {
	            return this._enableDepthAndStencil;
	        },
	        set: function (enableDepthAndStencil) {
	            this._enableDepthAndStencil = enableDepthAndStencil;
	            this._backBufferDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "renderTarget", {
	        get: function () {
	            return this._renderTarget;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "renderSurfaceSelector", {
	        get: function () {
	            return this._renderSurfaceSelector;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /*
	     * Clear and reset the back buffer when using a shared context
	     */
	    Stage.prototype.clear = function () {
	        if (!this._context)
	            return;
	        if (this._backBufferDirty) {
	            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	            this._backBufferDirty = false;
	        }
	        this._context.clear((this._color & 0xff000000) >>> 24, // <--------- Zero-fill right shift
	        (this._color & 0xff0000) >>> 16, // <-------------|
	        (this._color & 0xff00) >>> 8, // <----------------|
	        this._color & 0xff);
	        this._bufferClear = true;
	    };
	    Object.defineProperty(Stage.prototype, "scissorRect", {
	        get: function () {
	            return this._scissorRect;
	        },
	        set: function (value) {
	            this._scissorRect = value;
	            this._context.setScissorRectangle(this._scissorRect);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "stageIndex", {
	        /**
	         * The index of the Stage which is managed by this instance of StageProxy.
	         */
	        get: function () {
	            return this._stageIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "usesSoftwareRendering", {
	        /**
	         * Indicates whether the Stage managed by this proxy is running in software mode.
	         * Remember to wait for the CONTEXT_CREATED event before checking this property,
	         * as only then will it be guaranteed to be accurate.
	         */
	        get: function () {
	            return this._usesSoftwareRendering;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "antiAlias", {
	        /**
	         * The antiAliasing of the Stage.
	         */
	        get: function () {
	            return this._antiAlias;
	        },
	        set: function (antiAlias) {
	            this._antiAlias = antiAlias;
	            this._backBufferDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "viewPort", {
	        /**
	         * A viewPort rectangle equivalent of the Stage size and position.
	         */
	        get: function () {
	            this._viewportDirty = false;
	            return this._viewPort;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "color", {
	        /**
	         * The background color of the Stage.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (color) {
	            this._color = color;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "bufferClear", {
	        /**
	         * The freshly cleared state of the backbuffer before any rendering
	         */
	        get: function () {
	            return this._bufferClear;
	        },
	        set: function (newBufferClear) {
	            this._bufferClear = newBufferClear;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Stage.prototype.registerProgram = function (programData) {
	        var i = 0;
	        while (this._programData[i] != null)
	            i++;
	        this._programData[i] = programData;
	        programData.id = i;
	    };
	    Stage.prototype.unRegisterProgram = function (programData) {
	        this._programData[programData.id] = null;
	        programData.id = -1;
	    };
	    /**
	     * Frees the Context associated with this StageProxy.
	     */
	    Stage.prototype.freeContext = function () {
	        if (this._context) {
	            this._context.dispose();
	            this.dispatchEvent(new StageEvent_1.default(StageEvent_1.default.CONTEXT_DISPOSED, this));
	        }
	        this._context = null;
	        this._initialised = false;
	    };
	    Stage.prototype.onContextLost = function (event) {
	    };
	    Stage.prototype.onContextRestored = function (event) {
	    };
	    Stage.prototype.recoverFromDisposal = function () {
	        if (!this._context)
	            return false;
	        //away.Debug.throwPIR( 'StageProxy' , 'recoverFromDisposal' , '' );
	        /*
	         if (this._iContext.driverInfo == "Disposed")
	         {
	         this._iContext = null;
	         this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED));
	         return false;

	         }
	         */
	        return true;
	    };
	    Stage.prototype._callback = function (context) {
	        this._context = context;
	        this._container = this._context.container;
	        // Only configure back buffer if width and height have been set,
	        // which they may not have been if View.render() has yet to be
	        // invoked for the first time.
	        if (this._width && this._height)
	            this._context.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	        // Dispatch the appropriate event depending on whether context was
	        // created for the first time or recreated after a device loss.
	        this.dispatchEvent(new StageEvent_1.default(this._initialised ? StageEvent_1.default.CONTEXT_RECREATED : StageEvent_1.default.CONTEXT_CREATED, this));
	        this._initialised = true;
	    };
	    Stage.prototype.setVertexBuffer = function (index, buffer, size, dimensions, offset, unsigned) {
	        if (unsigned === void 0) { unsigned = false; }
	        this._context.setVertexBufferAt(index, buffer, offset, this._bufferFormatDictionary[unsigned ? size + 4 : size][dimensions]);
	    };
	    Stage.prototype.setSamplerState = function (index, repeat, smooth, mipmap) {
	        var wrap = repeat ? ContextGLWrapMode_1.default.REPEAT : ContextGLWrapMode_1.default.CLAMP;
	        var filter = smooth ? ContextGLTextureFilter_1.default.LINEAR : ContextGLTextureFilter_1.default.NEAREST;
	        var mipfilter = mipmap ? ContextGLMipFilter_1.default.MIPLINEAR : ContextGLMipFilter_1.default.MIPNONE;
	        this._context.setSamplerStateAt(index, wrap, filter, mipfilter);
	    };
	    Stage._abstractionClassPool = new Object();
	    return Stage;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Stage;


/***/ },
/* 116 */
/***/ function(module, exports) {

	"use strict";
	var CSS = (function () {
	    function CSS() {
	    }
	    CSS.setElementSize = function (element, width, height) {
	        if (!element)
	            return;
	        element.style.width = width + "px";
	        element.style.height = height + "px";
	        element["width"] = width;
	        element["height"] = height;
	    };
	    CSS.setElementWidth = function (element, width) {
	        if (!element)
	            return;
	        element.style.width = width + "px";
	        element["width"] = width;
	    };
	    CSS.setElementHeight = function (element, height) {
	        if (!element)
	            return;
	        element.style.height = height + "px";
	        element["height"] = height;
	    };
	    CSS.setElementX = function (element, x) {
	        if (!element)
	            return;
	        element.style.position = 'absolute';
	        element.style.left = x + "px";
	    };
	    CSS.setElementY = function (element, y) {
	        if (!element)
	            return;
	        element.style.position = 'absolute';
	        element.style.top = y + "px";
	    };
	    CSS.getElementVisibility = function (element) {
	        if (!element)
	            return false;
	        return element.style.visibility == 'visible';
	    };
	    CSS.setElementVisibility = function (element, visible) {
	        if (!element)
	            return;
	        if (visible) {
	            element.style.visibility = 'visible';
	        }
	        else {
	            element.style.visibility = 'hidden';
	        }
	    };
	    CSS.setElementAlpha = function (element, alpha) {
	        if (element instanceof HTMLCanvasElement) {
	            var context = element.getContext("2d");
	            context.globalAlpha = alpha;
	        }
	    };
	    CSS.setElementPosition = function (element, x, y, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        if (!element)
	            return;
	        if (absolute) {
	            element.style.position = "absolute";
	        }
	        else {
	            element.style.position = "relative";
	        }
	        element.style.left = x + "px";
	        element.style.top = y + "px";
	    };
	    return CSS;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CSS;


/***/ },
/* 117 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLMipFilter = (function () {
	    function ContextGLMipFilter() {
	    }
	    ContextGLMipFilter.MIPLINEAR = "miplinear";
	    ContextGLMipFilter.MIPNEAREST = "mipnearest";
	    ContextGLMipFilter.MIPNONE = "mipnone";
	    return ContextGLMipFilter;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLMipFilter;


/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLTextureFilter = (function () {
	    function ContextGLTextureFilter() {
	    }
	    ContextGLTextureFilter.LINEAR = "linear";
	    ContextGLTextureFilter.NEAREST = "nearest";
	    return ContextGLTextureFilter;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLTextureFilter;


/***/ },
/* 119 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLVertexBufferFormat = (function () {
	    function ContextGLVertexBufferFormat() {
	    }
	    ContextGLVertexBufferFormat.FLOAT_1 = 0;
	    ContextGLVertexBufferFormat.FLOAT_2 = 1;
	    ContextGLVertexBufferFormat.FLOAT_3 = 2;
	    ContextGLVertexBufferFormat.FLOAT_4 = 3;
	    ContextGLVertexBufferFormat.BYTE_1 = 4;
	    ContextGLVertexBufferFormat.BYTE_2 = 5;
	    ContextGLVertexBufferFormat.BYTE_3 = 6;
	    ContextGLVertexBufferFormat.BYTE_4 = 7;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_1 = 8;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_2 = 9;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_3 = 10;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_4 = 11;
	    ContextGLVertexBufferFormat.SHORT_1 = 12;
	    ContextGLVertexBufferFormat.SHORT_2 = 13;
	    ContextGLVertexBufferFormat.SHORT_3 = 14;
	    ContextGLVertexBufferFormat.SHORT_4 = 15;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_1 = 16;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_2 = 17;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_3 = 18;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_4 = 19;
	    return ContextGLVertexBufferFormat;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLVertexBufferFormat;


/***/ },
/* 120 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLWrapMode = (function () {
	    function ContextGLWrapMode() {
	    }
	    ContextGLWrapMode.CLAMP = "clamp";
	    ContextGLWrapMode.REPEAT = "repeat";
	    return ContextGLWrapMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLWrapMode;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Rectangle_1 = __webpack_require__(35);
	var ByteArray_1 = __webpack_require__(107);
	var ContextGLBlendFactor_1 = __webpack_require__(112);
	var ContextGLDrawMode_1 = __webpack_require__(122);
	var ContextGLClearMask_1 = __webpack_require__(99);
	var ContextGLCompareMode_1 = __webpack_require__(98);
	var ContextGLMipFilter_1 = __webpack_require__(117);
	var ContextGLProgramType_1 = __webpack_require__(123);
	var ContextGLStencilAction_1 = __webpack_require__(124);
	var ContextGLTextureFilter_1 = __webpack_require__(118);
	var ContextGLTriangleFace_1 = __webpack_require__(125);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(119);
	var ContextGLWrapMode_1 = __webpack_require__(120);
	var CubeTextureWebGL_1 = __webpack_require__(126);
	var IndexBufferWebGL_1 = __webpack_require__(128);
	var ProgramWebGL_1 = __webpack_require__(129);
	var TextureWebGL_1 = __webpack_require__(138);
	var SamplerState_1 = __webpack_require__(139);
	var VertexBufferWebGL_1 = __webpack_require__(140);
	var ContextWebGL = (function () {
	    function ContextWebGL(canvas) {
	        this._blendFactorDictionary = new Object();
	        this._drawModeDictionary = new Object();
	        this._compareModeDictionary = new Object();
	        this._stencilActionDictionary = new Object();
	        this._textureIndexDictionary = new Array(8);
	        this._textureTypeDictionary = new Object();
	        this._wrapDictionary = new Object();
	        this._filterDictionary = new Object();
	        this._mipmapFilterDictionary = new Object();
	        this._vertexBufferPropertiesDictionary = [];
	        this._samplerStates = new Array(8);
	        this._stencilReferenceValue = 0;
	        this._stencilReadMask = 0xff;
	        this._separateStencil = false;
	        this._container = canvas;
	        try {
	            this._gl = canvas.getContext("experimental-webgl", { premultipliedAlpha: false, alpha: false, stencil: true });
	            if (!this._gl)
	                this._gl = canvas.getContext("webgl", { premultipliedAlpha: false, alpha: false, stencil: true });
	        }
	        catch (e) {
	        }
	        if (this._gl) {
	            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
	            if (this._gl.getExtension("OES_standard_derivatives")) {
	                this._standardDerivatives = true;
	            }
	            else {
	                this._standardDerivatives = false;
	            }
	            //setup shortcut dictionaries
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE] = this._gl.ONE;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.DESTINATION_ALPHA] = this._gl.DST_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.DESTINATION_COLOR] = this._gl.DST_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE] = this._gl.ONE;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE_MINUS_DESTINATION_ALPHA] = this._gl.ONE_MINUS_DST_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE_MINUS_DESTINATION_COLOR] = this._gl.ONE_MINUS_DST_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE_MINUS_SOURCE_ALPHA] = this._gl.ONE_MINUS_SRC_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ONE_MINUS_SOURCE_COLOR] = this._gl.ONE_MINUS_SRC_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.SOURCE_ALPHA] = this._gl.SRC_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.SOURCE_COLOR] = this._gl.SRC_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.default.ZERO] = this._gl.ZERO;
	            this._drawModeDictionary[ContextGLDrawMode_1.default.LINES] = this._gl.LINES;
	            this._drawModeDictionary[ContextGLDrawMode_1.default.TRIANGLES] = this._gl.TRIANGLES;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.ALWAYS] = this._gl.ALWAYS;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.EQUAL] = this._gl.EQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.GREATER] = this._gl.GREATER;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.GREATER_EQUAL] = this._gl.GEQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.LESS] = this._gl.LESS;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.LESS_EQUAL] = this._gl.LEQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.NEVER] = this._gl.NEVER;
	            this._compareModeDictionary[ContextGLCompareMode_1.default.NOT_EQUAL] = this._gl.NOTEQUAL;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.DECREMENT_SATURATE] = this._gl.DECR;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.DECREMENT_WRAP] = this._gl.DECR_WRAP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.INCREMENT_SATURATE] = this._gl.INCR;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.INCREMENT_WRAP] = this._gl.INCR_WRAP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.INVERT] = this._gl.INVERT;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.KEEP] = this._gl.KEEP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.SET] = this._gl.REPLACE;
	            this._stencilActionDictionary[ContextGLStencilAction_1.default.ZERO] = this._gl.ZERO;
	            this._textureIndexDictionary[0] = this._gl.TEXTURE0;
	            this._textureIndexDictionary[1] = this._gl.TEXTURE1;
	            this._textureIndexDictionary[2] = this._gl.TEXTURE2;
	            this._textureIndexDictionary[3] = this._gl.TEXTURE3;
	            this._textureIndexDictionary[4] = this._gl.TEXTURE4;
	            this._textureIndexDictionary[5] = this._gl.TEXTURE5;
	            this._textureIndexDictionary[6] = this._gl.TEXTURE6;
	            this._textureIndexDictionary[7] = this._gl.TEXTURE7;
	            this._textureTypeDictionary["texture2d"] = this._gl.TEXTURE_2D;
	            this._textureTypeDictionary["textureCube"] = this._gl.TEXTURE_CUBE_MAP;
	            this._wrapDictionary[ContextGLWrapMode_1.default.REPEAT] = this._gl.REPEAT;
	            this._wrapDictionary[ContextGLWrapMode_1.default.CLAMP] = this._gl.CLAMP_TO_EDGE;
	            this._filterDictionary[ContextGLTextureFilter_1.default.LINEAR] = this._gl.LINEAR;
	            this._filterDictionary[ContextGLTextureFilter_1.default.NEAREST] = this._gl.NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.LINEAR] = new Object();
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.LINEAR][ContextGLMipFilter_1.default.MIPNEAREST] = this._gl.LINEAR_MIPMAP_NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.LINEAR][ContextGLMipFilter_1.default.MIPLINEAR] = this._gl.LINEAR_MIPMAP_LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.LINEAR][ContextGLMipFilter_1.default.MIPNONE] = this._gl.LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.NEAREST] = new Object();
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.NEAREST][ContextGLMipFilter_1.default.MIPNEAREST] = this._gl.NEAREST_MIPMAP_NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.NEAREST][ContextGLMipFilter_1.default.MIPLINEAR] = this._gl.NEAREST_MIPMAP_LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.default.NEAREST][ContextGLMipFilter_1.default.MIPNONE] = this._gl.NEAREST;
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.FLOAT_1] = new VertexBufferProperties(1, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.FLOAT_2] = new VertexBufferProperties(2, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.FLOAT_3] = new VertexBufferProperties(3, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.FLOAT_4] = new VertexBufferProperties(4, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.BYTE_1] = new VertexBufferProperties(1, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.BYTE_2] = new VertexBufferProperties(2, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.BYTE_3] = new VertexBufferProperties(3, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.BYTE_4] = new VertexBufferProperties(4, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_BYTE_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.SHORT_1] = new VertexBufferProperties(1, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.SHORT_2] = new VertexBufferProperties(2, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.SHORT_3] = new VertexBufferProperties(3, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.SHORT_4] = new VertexBufferProperties(4, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.default.UNSIGNED_SHORT_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_SHORT, true);
	            this._stencilCompareMode = this._gl.ALWAYS;
	            this._stencilCompareModeBack = this._gl.ALWAYS;
	            this._stencilCompareModeFront = this._gl.ALWAYS;
	        }
	        else {
	            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
	            alert("WebGL is not available.");
	        }
	        //defaults
	        for (var i = 0; i < ContextWebGL.MAX_SAMPLERS; ++i) {
	            this._samplerStates[i] = new SamplerState_1.default();
	            this._samplerStates[i].wrap = this._gl.REPEAT;
	            this._samplerStates[i].filter = this._gl.LINEAR;
	            this._samplerStates[i].mipfilter = this._gl.LINEAR;
	        }
	    }
	    Object.defineProperty(ContextWebGL.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextWebGL.prototype, "standardDerivatives", {
	        get: function () {
	            return this._standardDerivatives;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContextWebGL.prototype.gl = function () {
	        return this._gl;
	    };
	    ContextWebGL.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
	        if (red === void 0) { red = 0; }
	        if (green === void 0) { green = 0; }
	        if (blue === void 0) { blue = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (depth === void 0) { depth = 1; }
	        if (stencil === void 0) { stencil = 0; }
	        if (mask === void 0) { mask = ContextGLClearMask_1.default.ALL; }
	        if (!this._drawing) {
	            this.updateBlendStatus();
	            this._drawing = true;
	        }
	        var glmask = 0;
	        if (mask & ContextGLClearMask_1.default.COLOR)
	            glmask |= this._gl.COLOR_BUFFER_BIT;
	        if (mask & ContextGLClearMask_1.default.STENCIL)
	            glmask |= this._gl.STENCIL_BUFFER_BIT;
	        if (mask & ContextGLClearMask_1.default.DEPTH)
	            glmask |= this._gl.DEPTH_BUFFER_BIT;
	        this._gl.clearColor(red, green, blue, alpha);
	        this._gl.clearDepth(depth);
	        this._gl.clearStencil(stencil);
	        this._gl.clear(glmask);
	    };
	    ContextWebGL.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
	        this._width = width;
	        this._height = height;
	        if (enableDepthAndStencil) {
	            this._gl.enable(this._gl.STENCIL_TEST);
	            this._gl.enable(this._gl.DEPTH_TEST);
	        }
	        this._gl.viewport['width'] = width;
	        this._gl.viewport['height'] = height;
	        this._gl.viewport(0, 0, width, height);
	    };
	    ContextWebGL.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        return new CubeTextureWebGL_1.default(this._gl, size);
	    };
	    ContextWebGL.prototype.createIndexBuffer = function (numIndices) {
	        return new IndexBufferWebGL_1.default(this._gl, numIndices);
	    };
	    ContextWebGL.prototype.createProgram = function () {
	        return new ProgramWebGL_1.default(this._gl);
	    };
	    ContextWebGL.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        //TODO streaming
	        return new TextureWebGL_1.default(this._gl, width, height);
	    };
	    ContextWebGL.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
	        return new VertexBufferWebGL_1.default(this._gl, numVertices, dataPerVertex);
	    };
	    ContextWebGL.prototype.dispose = function () {
	        for (var i = 0; i < this._samplerStates.length; ++i)
	            this._samplerStates[i] = null;
	    };
	    ContextWebGL.prototype.drawToBitmapImage2D = function (destination) {
	        var arrayBuffer = new ArrayBuffer(destination.width * destination.height * 4);
	        this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, new Uint8Array(arrayBuffer));
	        var byteArray = new ByteArray_1.default();
	        byteArray.setArrayBuffer(arrayBuffer);
	        destination.setPixels(new Rectangle_1.default(0, 0, destination.width, destination.height), byteArray);
	    };
	    ContextWebGL.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
	        if (firstIndex === void 0) { firstIndex = 0; }
	        if (numIndices === void 0) { numIndices = -1; }
	        if (!this._drawing)
	            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
	        this._gl.drawElements(this._drawModeDictionary[mode], (numIndices == -1) ? indexBuffer.numIndices : numIndices, this._gl.UNSIGNED_SHORT, firstIndex * 2);
	    };
	    ContextWebGL.prototype.drawVertices = function (mode, firstVertex, numVertices) {
	        if (firstVertex === void 0) { firstVertex = 0; }
	        if (numVertices === void 0) { numVertices = -1; }
	        if (!this._drawing)
	            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        this._gl.drawArrays(this._drawModeDictionary[mode], firstVertex, numVertices);
	    };
	    ContextWebGL.prototype.present = function () {
	        this._drawing = false;
	    };
	    ContextWebGL.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
	        this._blendEnabled = true;
	        this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
	        this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
	        this.updateBlendStatus();
	    };
	    ContextWebGL.prototype.setColorMask = function (red, green, blue, alpha) {
	        this._gl.colorMask(red, green, blue, alpha);
	    };
	    ContextWebGL.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        if (triangleFaceToCull == ContextGLTriangleFace_1.default.NONE) {
	            this._gl.disable(this._gl.CULL_FACE);
	        }
	        else {
	            this._gl.enable(this._gl.CULL_FACE);
	            this._gl.cullFace(this.translateTriangleFace(triangleFaceToCull, coordinateSystem));
	        }
	    };
	    // TODO ContextGLCompareMode
	    ContextWebGL.prototype.setDepthTest = function (depthMask, passCompareMode) {
	        this._gl.depthFunc(this._compareModeDictionary[passCompareMode]);
	        this._gl.depthMask(depthMask);
	    };
	    ContextWebGL.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
	        if (triangleFace === void 0) { triangleFace = "frontAndBack"; }
	        if (compareMode === void 0) { compareMode = "always"; }
	        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
	        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
	        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        this._separateStencil = triangleFace != "frontAndBack";
	        var compareModeGL = this._compareModeDictionary[compareMode];
	        var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
	        var zFail = this._stencilActionDictionary[actionOnDepthFail];
	        var pass = this._stencilActionDictionary[actionOnBothPass];
	        if (!this._separateStencil) {
	            this._stencilCompareMode = compareModeGL;
	            this._gl.stencilFunc(compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOp(fail, zFail, pass);
	        }
	        else if (triangleFace == "back") {
	            this._stencilCompareModeBack = compareModeGL;
	            this._gl.stencilFuncSeparate(this._gl.BACK, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOpSeparate(this._gl.BACK, fail, zFail, pass);
	        }
	        else if (triangleFace == "front") {
	            this._stencilCompareModeFront = compareModeGL;
	            this._gl.stencilFuncSeparate(this._gl.FRONT, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOpSeparate(this._gl.FRONT, fail, zFail, pass);
	        }
	    };
	    ContextWebGL.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
	        this._stencilReferenceValue = referenceValue;
	        this._stencilReadMask = readMask;
	        if (this._separateStencil) {
	            this._gl.stencilFuncSeparate(this._gl.FRONT, this._stencilCompareModeFront, referenceValue, readMask);
	            this._gl.stencilFuncSeparate(this._gl.BACK, this._stencilCompareModeBack, referenceValue, readMask);
	        }
	        else {
	            this._gl.stencilFunc(this._stencilCompareMode, referenceValue, readMask);
	        }
	        this._gl.stencilMask(writeMask);
	    };
	    ContextWebGL.prototype.setProgram = function (program) {
	        //TODO decide on construction/reference resposibilities
	        this._currentProgram = program;
	        program.focusProgram();
	    };
	    ContextWebGL.prototype.setProgramConstantsFromMatrix = function (programType, firstRegister, matrix, transposedMatrix) {
	        //this._gl.uniformMatrix4fv(this._gl.getUniformLocation(this._currentProgram.glProgram, this._uniformLocationNameDictionary[programType]), !transposedMatrix, new Float32Array(matrix.rawData));
	        if (transposedMatrix === void 0) { transposedMatrix = false; }
	        //TODO remove special case for WebGL matrix calls?
	        var d = matrix.rawData;
	        if (transposedMatrix) {
	            var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	            raw[0] = d[0];
	            raw[1] = d[4];
	            raw[2] = d[8];
	            raw[3] = d[12];
	            raw[4] = d[1];
	            raw[5] = d[5];
	            raw[6] = d[9];
	            raw[7] = d[13];
	            raw[8] = d[2];
	            raw[9] = d[6];
	            raw[10] = d[10];
	            raw[11] = d[14];
	            raw[12] = d[3];
	            raw[13] = d[7];
	            raw[14] = d[11];
	            raw[15] = d[15];
	            this.setProgramConstantsFromArray(programType, firstRegister, raw, 4);
	        }
	        else {
	            this.setProgramConstantsFromArray(programType, firstRegister, d, 4);
	        }
	    };
	    ContextWebGL.prototype.setProgramConstantsFromArray = function (programType, firstRegister, data, numRegisters) {
	        if (numRegisters === void 0) { numRegisters = -1; }
	        var startIndex;
	        for (var i = 0; i < numRegisters; i++) {
	            startIndex = i * 4;
	            this._gl.uniform4f(this._currentProgram.getUniformLocation(programType, (firstRegister + i)), data[startIndex], data[startIndex + 1], data[startIndex + 2], data[startIndex + 3]);
	        }
	    };
	    ContextWebGL.prototype.setScissorRectangle = function (rectangle) {
	        if (!rectangle) {
	            this._gl.disable(this._gl.SCISSOR_TEST);
	            return;
	        }
	        this._gl.enable(this._gl.SCISSOR_TEST);
	        this._gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	    };
	    ContextWebGL.prototype.setTextureAt = function (sampler, texture) {
	        var samplerState = this._samplerStates[sampler];
	        if (this._activeTexture != sampler && (texture || samplerState.type)) {
	            this._activeTexture = sampler;
	            this._gl.activeTexture(this._textureIndexDictionary[sampler]);
	        }
	        if (!texture) {
	            if (samplerState.type) {
	                this._gl.bindTexture(samplerState.type, null);
	                samplerState.type = null;
	            }
	            return;
	        }
	        var textureType = this._textureTypeDictionary[texture.textureType];
	        samplerState.type = textureType;
	        this._gl.bindTexture(textureType, texture.glTexture);
	        this._gl.uniform1i(this._currentProgram.getUniformLocation(ContextGLProgramType_1.default.SAMPLER, sampler), sampler);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, samplerState.mipfilter);
	    };
	    ContextWebGL.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
	        if (0 <= sampler && sampler < ContextWebGL.MAX_SAMPLERS) {
	            this._samplerStates[sampler].wrap = this._wrapDictionary[wrap];
	            this._samplerStates[sampler].filter = this._filterDictionary[filter];
	            this._samplerStates[sampler].mipfilter = this._mipmapFilterDictionary[filter][mipfilter];
	        }
	        else {
	            throw "Sampler is out of bounds.";
	        }
	    };
	    ContextWebGL.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
	        if (bufferOffset === void 0) { bufferOffset = 0; }
	        if (format === void 0) { format = 4; }
	        var location = this._currentProgram ? this._currentProgram.getAttribLocation(index) : -1;
	        if (!buffer) {
	            if (location > -1)
	                this._gl.disableVertexAttribArray(location);
	            return;
	        }
	        //buffer may not have changed if concatenated buffers are being used
	        if (this._currentArrayBuffer != buffer) {
	            this._currentArrayBuffer = buffer;
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer ? buffer.glBuffer : null);
	        }
	        var properties = this._vertexBufferPropertiesDictionary[format];
	        this._gl.enableVertexAttribArray(location);
	        this._gl.vertexAttribPointer(location, properties.size, properties.type, properties.normalized, buffer.dataPerVertex, bufferOffset);
	    };
	    ContextWebGL.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (antiAlias === void 0) { antiAlias = 0; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        var texture = target;
	        var frameBuffer = texture.frameBuffer;
	        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
	        if (enableDepthAndStencil) {
	            this._gl.enable(this._gl.STENCIL_TEST);
	            this._gl.enable(this._gl.DEPTH_TEST);
	        }
	        this._gl.viewport(0, 0, texture.width, texture.height);
	    };
	    ContextWebGL.prototype.setRenderToBackBuffer = function () {
	        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	    };
	    ContextWebGL.prototype.updateBlendStatus = function () {
	        if (this._blendEnabled) {
	            this._gl.enable(this._gl.BLEND);
	            this._gl.blendEquation(this._gl.FUNC_ADD);
	            this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
	        }
	        else {
	            this._gl.disable(this._gl.BLEND);
	        }
	    };
	    ContextWebGL.prototype.translateTriangleFace = function (triangleFace, coordinateSystem) {
	        switch (triangleFace) {
	            case ContextGLTriangleFace_1.default.BACK:
	                return (coordinateSystem == "leftHanded") ? this._gl.FRONT : this._gl.BACK;
	            case ContextGLTriangleFace_1.default.FRONT:
	                return (coordinateSystem == "leftHanded") ? this._gl.BACK : this._gl.FRONT;
	            case ContextGLTriangleFace_1.default.FRONT_AND_BACK:
	                return this._gl.FRONT_AND_BACK;
	            default:
	                throw "Unknown ContextGLTriangleFace type."; // TODO error
	        }
	    };
	    ContextWebGL.MAX_SAMPLERS = 8;
	    ContextWebGL._float4 = new Float32Array(4);
	    ContextWebGL.modulo = 0;
	    return ContextWebGL;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextWebGL;
	var VertexBufferProperties = (function () {
	    function VertexBufferProperties(size, type, normalized) {
	        this.size = size;
	        this.type = type;
	        this.normalized = normalized;
	    }
	    return VertexBufferProperties;
	}());


/***/ },
/* 122 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLDrawMode = (function () {
	    function ContextGLDrawMode() {
	    }
	    ContextGLDrawMode.TRIANGLES = "triangles";
	    ContextGLDrawMode.LINES = "lines";
	    return ContextGLDrawMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLDrawMode;


/***/ },
/* 123 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLProgramType = (function () {
	    function ContextGLProgramType() {
	    }
	    ContextGLProgramType.FRAGMENT = 0;
	    ContextGLProgramType.SAMPLER = 1;
	    ContextGLProgramType.VERTEX = 2;
	    return ContextGLProgramType;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLProgramType;


/***/ },
/* 124 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLStencilAction = (function () {
	    function ContextGLStencilAction() {
	    }
	    ContextGLStencilAction.DECREMENT_SATURATE = "decrementSaturate";
	    ContextGLStencilAction.DECREMENT_WRAP = "decrementWrap";
	    ContextGLStencilAction.INCREMENT_SATURATE = "incrementSaturate";
	    ContextGLStencilAction.INCREMENT_WRAP = "incrementWrap";
	    ContextGLStencilAction.INVERT = "invert";
	    ContextGLStencilAction.KEEP = "keep";
	    ContextGLStencilAction.SET = "set";
	    ContextGLStencilAction.ZERO = "zero";
	    return ContextGLStencilAction;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLStencilAction;


/***/ },
/* 125 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLTriangleFace = (function () {
	    function ContextGLTriangleFace() {
	    }
	    ContextGLTriangleFace.BACK = "back";
	    ContextGLTriangleFace.FRONT = "front";
	    ContextGLTriangleFace.FRONT_AND_BACK = "frontAndBack";
	    ContextGLTriangleFace.NONE = "none";
	    return ContextGLTriangleFace;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLTriangleFace;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseWebGL_1 = __webpack_require__(127);
	var CubeTextureWebGL = (function (_super) {
	    __extends(CubeTextureWebGL, _super);
	    function CubeTextureWebGL(gl, size) {
	        _super.call(this, gl);
	        this._textureSelectorDictionary = new Array(6);
	        this.textureType = "textureCube";
	        this._size = size;
	        this._texture = this._gl.createTexture();
	        this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
	        this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
	        this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
	        this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	        this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
	        this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	    }
	    CubeTextureWebGL.prototype.dispose = function () {
	        this._gl.deleteTexture(this._texture);
	    };
	    CubeTextureWebGL.prototype.uploadFromData = function (data, side, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._texture);
	        this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
	    };
	    CubeTextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	    };
	    Object.defineProperty(CubeTextureWebGL.prototype, "size", {
	        get: function () {
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CubeTextureWebGL.prototype, "glTexture", {
	        get: function () {
	            return this._texture;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CubeTextureWebGL;
	}(TextureBaseWebGL_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CubeTextureWebGL;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(20);
	var TextureBaseWebGL = (function () {
	    function TextureBaseWebGL(gl) {
	        this.textureType = "";
	        this._gl = gl;
	    }
	    TextureBaseWebGL.prototype.dispose = function () {
	        throw "Abstract method must be overridden.";
	    };
	    Object.defineProperty(TextureBaseWebGL.prototype, "glTexture", {
	        get: function () {
	            throw new AbstractMethodError_1.default();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TextureBaseWebGL;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextureBaseWebGL;


/***/ },
/* 128 */
/***/ function(module, exports) {

	"use strict";
	var IndexBufferWebGL = (function () {
	    function IndexBufferWebGL(gl, numIndices) {
	        this._gl = gl;
	        this._buffer = this._gl.createBuffer();
	        this._numIndices = numIndices;
	    }
	    IndexBufferWebGL.prototype.uploadFromArray = function (data, startOffset, count) {
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        if (startOffset)
	            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, new Uint16Array(data));
	        else
	            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
	    };
	    IndexBufferWebGL.prototype.uploadFromByteArray = function (data, startOffset, count) {
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        if (startOffset)
	            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, data);
	        else
	            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    IndexBufferWebGL.prototype.dispose = function () {
	        this._gl.deleteBuffer(this._buffer);
	    };
	    Object.defineProperty(IndexBufferWebGL.prototype, "numIndices", {
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(IndexBufferWebGL.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return IndexBufferWebGL;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = IndexBufferWebGL;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AGALTokenizer_1 = __webpack_require__(130);
	var AGLSLParser_1 = __webpack_require__(137);
	var ProgramWebGL = (function () {
	    function ProgramWebGL(gl) {
	        this._uniforms = [[], [], []];
	        this._attribs = [];
	        this._gl = gl;
	        this._program = this._gl.createProgram();
	    }
	    ProgramWebGL.prototype.upload = function (vertexProgram, fragmentProgram) {
	        var vertexString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(vertexProgram));
	        var fragmentString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(fragmentProgram));
	        this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
	        this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
	        this._gl.shaderSource(this._vertexShader, vertexString);
	        this._gl.compileShader(this._vertexShader);
	        if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS))
	            throw new Error(this._gl.getShaderInfoLog(this._vertexShader));
	        this._gl.shaderSource(this._fragmentShader, fragmentString);
	        this._gl.compileShader(this._fragmentShader);
	        if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS))
	            throw new Error(this._gl.getShaderInfoLog(this._fragmentShader));
	        this._gl.attachShader(this._program, this._vertexShader);
	        this._gl.attachShader(this._program, this._fragmentShader);
	        this._gl.linkProgram(this._program);
	        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS))
	            throw new Error(this._gl.getProgramInfoLog(this._program));
	        this._uniforms[0].length = 0;
	        this._uniforms[1].length = 0;
	        this._uniforms[2].length = 0;
	        this._attribs.length = 0;
	    };
	    ProgramWebGL.prototype.getUniformLocation = function (programType, index) {
	        if (this._uniforms[programType][index] != null)
	            return this._uniforms[programType][index];
	        return (this._uniforms[programType][index] = this._gl.getUniformLocation(this._program, ProgramWebGL._uniformLocationNameDictionary[programType] + index));
	    };
	    ProgramWebGL.prototype.getAttribLocation = function (index) {
	        if (this._attribs[index] != null)
	            return this._attribs[index];
	        return (this._attribs[index] = this._gl.getAttribLocation(this._program, "va" + index));
	    };
	    ProgramWebGL.prototype.dispose = function () {
	        this._gl.deleteProgram(this._program);
	    };
	    ProgramWebGL.prototype.focusProgram = function () {
	        this._gl.useProgram(this._program);
	    };
	    Object.defineProperty(ProgramWebGL.prototype, "glProgram", {
	        get: function () {
	            return this._program;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProgramWebGL._tokenizer = new AGALTokenizer_1.default();
	    ProgramWebGL._aglslParser = new AGLSLParser_1.default();
	    ProgramWebGL._uniformLocationNameDictionary = ["fc", "fs", "vc"];
	    return ProgramWebGL;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ProgramWebGL;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Description_1 = __webpack_require__(131);
	var Header_1 = __webpack_require__(132);
	var Mapping_1 = __webpack_require__(133);
	var Token_1 = __webpack_require__(135);
	var AGALTokenizer = (function () {
	    function AGALTokenizer() {
	    }
	    AGALTokenizer.prototype.decribeAGALByteArray = function (bytes) {
	        var header = new Header_1.default();
	        if (bytes.readUnsignedByte() != 0xa0) {
	            throw "Bad AGAL: Missing 0xa0 magic byte.";
	        }
	        header.version = bytes.readUnsignedInt();
	        if (header.version >= 0x10) {
	            bytes.readUnsignedByte();
	            header.version >>= 1;
	        }
	        if (bytes.readUnsignedByte() != 0xa1) {
	            throw "Bad AGAL: Missing 0xa1 magic byte.";
	        }
	        header.progid = bytes.readUnsignedByte();
	        switch (header.progid) {
	            case 1:
	                header.type = "fragment";
	                break;
	            case 0:
	                header.type = "vertex";
	                break;
	            case 2:
	                header.type = "cpu";
	                break;
	            default:
	                header.type = "";
	                break;
	        }
	        var desc = new Description_1.default();
	        var tokens = [];
	        while (bytes.position < bytes.length) {
	            var token = new Token_1.default();
	            token.opcode = bytes.readUnsignedInt();
	            var lutentry = Mapping_1.default.agal2glsllut[token.opcode];
	            if (!lutentry) {
	                throw "Opcode not valid or not implemented yet: " + token.opcode;
	            }
	            if (lutentry.matrixheight) {
	                desc.hasmatrix = true;
	            }
	            if (lutentry.dest) {
	                token.dest.regnum = bytes.readUnsignedShort();
	                token.dest.mask = bytes.readUnsignedByte();
	                token.dest.regtype = bytes.readUnsignedByte();
	                desc.regwrite[token.dest.regtype][token.dest.regnum] |= token.dest.mask;
	            }
	            else {
	                token.dest = null;
	                bytes.readUnsignedInt();
	            }
	            if (lutentry.a) {
	                this.readReg(token.a, 1, desc, bytes);
	            }
	            else {
	                token.a = null;
	                bytes.readUnsignedInt();
	                bytes.readUnsignedInt();
	            }
	            if (lutentry.b) {
	                this.readReg(token.b, lutentry.matrixheight | 0, desc, bytes);
	            }
	            else {
	                token.b = null;
	                bytes.readUnsignedInt();
	                bytes.readUnsignedInt();
	            }
	            tokens.push(token);
	        }
	        desc.header = header;
	        desc.tokens = tokens;
	        return desc;
	    };
	    AGALTokenizer.prototype.readReg = function (s, mh, desc, bytes) {
	        s.regnum = bytes.readUnsignedShort();
	        s.indexoffset = bytes.readByte();
	        s.swizzle = bytes.readUnsignedByte();
	        s.regtype = bytes.readUnsignedByte();
	        desc.regread[s.regtype][s.regnum] = 0xf; // sould be swizzle to mask? should be |=                                                 
	        if (s.regtype == 0x5) {
	            // sampler
	            s.lodbiad = s.indexoffset;
	            s.indexoffset = undefined;
	            s.swizzle = undefined;
	            // sampler 
	            s.readmode = bytes.readUnsignedByte();
	            s.dim = s.readmode >> 4;
	            s.readmode &= 0xf;
	            s.special = bytes.readUnsignedByte();
	            s.wrap = s.special >> 4;
	            s.special &= 0xf;
	            s.mipmap = bytes.readUnsignedByte();
	            s.filter = s.mipmap >> 4;
	            s.mipmap &= 0xf;
	            desc.samplers[s.regnum] = s;
	        }
	        else {
	            s.indexregtype = bytes.readUnsignedByte();
	            s.indexselect = bytes.readUnsignedByte();
	            s.indirectflag = bytes.readUnsignedByte();
	        }
	        if (s.indirectflag) {
	            desc.hasindirect = true;
	        }
	        if (!s.indirectflag && mh) {
	            for (var mhi = 0; mhi < mh; mhi++) {
	                desc.regread[s.regtype][s.regnum + mhi] = desc.regread[s.regtype][s.regnum];
	            }
	        }
	    };
	    return AGALTokenizer;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AGALTokenizer;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Header_1 = __webpack_require__(132);
	var Description = (function () {
	    function Description() {
	        this.regread = [
	            [],
	            [],
	            [],
	            [],
	            [],
	            [],
	            []
	        ];
	        this.regwrite = [
	            [],
	            [],
	            [],
	            [],
	            [],
	            [],
	            []
	        ];
	        this.hasindirect = false;
	        this.writedepth = false;
	        this.hasmatrix = false;
	        this.samplers = [];
	        // added due to dynamic assignment 3*0xFFFFFFuuuu
	        this.tokens = [];
	        this.header = new Header_1.default();
	    }
	    return Description;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Description;


/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	var Header = (function () {
	    function Header() {
	        this.progid = 0;
	        this.version = 0;
	        this.type = "";
	    }
	    return Header;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Header;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var OpLUT_1 = __webpack_require__(134);
	var Mapping = (function () {
	    //TODO: get rid of hack that fixes including definition file
	    function Mapping(include) {
	    }
	    Mapping.agal2glsllut = [
	        //         s 												flags   dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.default("%dest = %cast(%a);\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(%a + %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(%a - %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(%a * %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(%a / %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(1.0) / %a;\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(min(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(max(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(fract(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(sqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(inversesqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(pow(abs(%a),%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(log2(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(exp2(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        //         s 												flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.default("%dest = %cast(normalize(vec3( %a ) ));\n", 0, true, true, false, null, null, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(sin(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(cos(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(cross(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(abs(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(%a * -1.0);\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(clamp(%a,0.0,1.0));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", null, true, true, true, 3, 3, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 4, true, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 3, true, null, null, null),
	        //s:string, flags:number, dest:boolean, a:boolean, b:boolean, matrixwidth:number, matrixheight:number, ndwm:boolean, scaler:boolean, dm:boolean, lod:boolean
	        new OpLUT_1.default("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("%dest = %cast(dFdy(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.default("if (float(%a)==float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.default("if (float(%a)!=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.default("if (float(%a)>=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.default("if (float(%a)<float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.default("} else {;\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT_1.default("};\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT_1.default(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.default(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.default(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.default(null, null, null, null, false, null, null, null, null, null, null),
	        //         s 															flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.default("%dest = %cast(texture%texdimLod(%b,%texsize(%a)).%dm);\n", null, true, true, true, null, null, null, null, true, null), new OpLUT_1.default("if ( float(%a)<0.0 ) discard;\n", null, false, true, false, null, null, null, true, null, null), new OpLUT_1.default("%dest = %cast(texture%texdim(%b,%texsize(%a)%lod).%dm);\n", null, true, true, true, null, null, true, null, true, true), new OpLUT_1.default("%dest = %cast(greaterThanEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.default("%dest = %cast(lessThan(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.default("%dest = %cast(sign(%a));\n", 0, true, true, false, null, null, null, null, null, null), new OpLUT_1.default("%dest = %cast(equal(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.default("%dest = %cast(notEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null)
	    ];
	    return Mapping;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Mapping;


/***/ },
/* 134 */
/***/ function(module, exports) {

	"use strict";
	var OpLUT = (function () {
	    function OpLUT(s, flags, dest, a, b, matrixwidth, matrixheight, ndwm, scaler, dm, lod) {
	        this.s = s;
	        this.flags = flags;
	        this.dest = dest;
	        this.a = a;
	        this.b = b;
	        this.matrixwidth = matrixwidth;
	        this.matrixheight = matrixheight;
	        this.ndwm = ndwm;
	        this.scalar = scaler;
	        this.dm = dm;
	        this.lod = lod;
	    }
	    return OpLUT;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OpLUT;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Destination_1 = __webpack_require__(136);
	var Token = (function () {
	    function Token() {
	        this.dest = new Destination_1.default();
	        this.opcode = 0;
	        this.a = new Destination_1.default();
	        this.b = new Destination_1.default();
	    }
	    return Token;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Token;


/***/ },
/* 136 */
/***/ function(module, exports) {

	"use strict";
	var Destination = (function () {
	    function Destination() {
	        this.mask = 0;
	        this.regnum = 0;
	        this.regtype = 0;
	        this.dim = 0;
	        this.indexoffset = 0;
	        this.swizzle = 0;
	        this.lodbiad = 0;
	        this.readmode = 0;
	        this.special = 0;
	        this.wrap = 0;
	        this.filter = 0;
	        this.indexregtype = 0;
	        this.indexselect = 0;
	        this.indirectflag = 0;
	    }
	    return Destination;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Destination;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Mapping_1 = __webpack_require__(133);
	var AGLSLParser = (function () {
	    function AGLSLParser() {
	    }
	    AGLSLParser.prototype.parse = function (desc) {
	        var header = "";
	        var body = "";
	        header += "precision highp float;\n";
	        var tag = desc.header.type[0]; //TODO
	        // declare uniforms
	        if (desc.header.type == "vertex") {
	            header += "uniform float yflip;\n";
	        }
	        if (!desc.hasindirect) {
	            for (var i = 0; i < desc.regread[0x1].length; i++) {
	                if (desc.regread[0x1][i]) {
	                    header += "uniform vec4 " + tag + "c" + i + ";\n";
	                }
	            }
	        }
	        else {
	            header += "uniform vec4 " + tag + "carrr[" + AGLSLParser.maxvertexconstants + "];\n"; // use max const count instead
	        }
	        // declare temps
	        for (var i = 0; i < desc.regread[0x2].length || i < desc.regwrite[0x2].length; i++) {
	            if (desc.regread[0x2][i] || desc.regwrite[0x2][i]) {
	                header += "vec4 " + tag + "t" + i + ";\n";
	            }
	        }
	        // declare streams
	        for (var i = 0; i < desc.regread[0x0].length; i++) {
	            if (desc.regread[0x0][i]) {
	                header += "attribute vec4 va" + i + ";\n";
	            }
	        }
	        // declare interpolated
	        for (var i = 0; i < desc.regread[0x4].length || i < desc.regwrite[0x4].length; i++) {
	            if (desc.regread[0x4][i] || desc.regwrite[0x4][i]) {
	                header += "varying vec4 vi" + i + ";\n";
	            }
	        }
	        // declare samplers
	        var samptype = ["2D", "Cube", "3D", ""];
	        for (var i = 0; i < desc.samplers.length; i++) {
	            if (desc.samplers[i]) {
	                header += "uniform sampler" + samptype[desc.samplers[i].dim & 3] + " fs" + i + ";\n";
	            }
	        }
	        // extra gl fluff: setup position and depth adjust temps
	        if (desc.header.type == "vertex") {
	            header += "vec4 outpos;\n";
	        }
	        if (desc.writedepth) {
	            header += "vec4 tmp_FragDepth;\n";
	        }
	        //if ( desc.hasmatrix ) 
	        //    header += "vec4 tmp_matrix;\n";
	        var derivatives = false;
	        // start body of code
	        body += "void main() {\n";
	        for (var i = 0; i < desc.tokens.length; i++) {
	            var lutentry = Mapping_1.default.agal2glsllut[desc.tokens[i].opcode];
	            if (lutentry.s.indexOf("dFdx") != -1 || lutentry.s.indexOf("dFdy") != -1)
	                derivatives = true;
	            if (!lutentry) {
	                throw "Opcode not valid or not implemented yet: ";
	            }
	            var sublines = lutentry.matrixheight || 1;
	            for (var sl = 0; sl < sublines; sl++) {
	                var line = "  " + lutentry.s;
	                if (desc.tokens[i].dest) {
	                    if (lutentry.matrixheight) {
	                        if (((desc.tokens[i].dest.mask >> sl) & 1) != 1) {
	                            continue;
	                        }
	                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
	                        var destcaststring = "float";
	                        var destmaskstring = ["x", "y", "z", "w"][sl];
	                        destregstring += "." + destmaskstring;
	                    }
	                    else {
	                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
	                        var destcaststring;
	                        var destmaskstring;
	                        if (desc.tokens[i].dest.mask != 0xf) {
	                            var ndest = 0;
	                            destmaskstring = "";
	                            if (desc.tokens[i].dest.mask & 1) {
	                                ndest++;
	                                destmaskstring += "x";
	                            }
	                            if (desc.tokens[i].dest.mask & 2) {
	                                ndest++;
	                                destmaskstring += "y";
	                            }
	                            if (desc.tokens[i].dest.mask & 4) {
	                                ndest++;
	                                destmaskstring += "z";
	                            }
	                            if (desc.tokens[i].dest.mask & 8) {
	                                ndest++;
	                                destmaskstring += "w";
	                            }
	                            destregstring += "." + destmaskstring;
	                            switch (ndest) {
	                                case 1:
	                                    destcaststring = "float";
	                                    break;
	                                case 2:
	                                    destcaststring = "vec2";
	                                    break;
	                                case 3:
	                                    destcaststring = "vec3";
	                                    break;
	                                default:
	                                    throw "Unexpected destination mask";
	                            }
	                        }
	                        else {
	                            destcaststring = "vec4";
	                            destmaskstring = "xyzw";
	                        }
	                    }
	                    line = line.replace("%dest", destregstring);
	                    line = line.replace("%cast", destcaststring);
	                    line = line.replace("%dm", destmaskstring);
	                }
	                var dwm = 0xf;
	                if (!lutentry.ndwm && lutentry.dest && desc.tokens[i].dest) {
	                    dwm = desc.tokens[i].dest.mask;
	                }
	                if (desc.tokens[i].a) {
	                    line = line.replace("%a", this.sourcetostring(desc.tokens[i].a, 0, dwm, lutentry.scalar, desc, tag));
	                }
	                if (desc.tokens[i].b) {
	                    line = line.replace("%b", this.sourcetostring(desc.tokens[i].b, sl, dwm, lutentry.scalar, desc, tag));
	                    if (desc.tokens[i].b.regtype == 0x5) {
	                        // sampler dim
	                        var texdim = ["2D", "Cube", "3D"][desc.tokens[i].b.dim];
	                        var texsize = ["vec2", "vec3", "vec3"][desc.tokens[i].b.dim];
	                        line = line.replace("%texdim", texdim);
	                        line = line.replace("%texsize", texsize);
	                        var texlod = "";
	                        line = line.replace("%lod", texlod);
	                    }
	                }
	                body += line;
	            }
	        }
	        // adjust z from opengl range of -1..1 to 0..1 as in d3d, this also enforces a left handed coordinate system
	        if (desc.header.type == "vertex") {
	            body += "  gl_Position = vec4(outpos.x, outpos.y, outpos.z*2.0 - outpos.w, outpos.w);\n";
	        }
	        //flag based switch
	        if (derivatives && desc.header.type == "fragment") {
	            header = "#extension GL_OES_standard_derivatives : enable\n" + header;
	        }
	        // clamp fragment depth
	        if (desc.writedepth) {
	            body += "  gl_FragDepth = clamp(tmp_FragDepth,0.0,1.0);\n";
	        }
	        // close main
	        body += "}\n";
	        return header + body;
	    };
	    AGLSLParser.prototype.regtostring = function (regtype, regnum, desc, tag) {
	        switch (regtype) {
	            case 0x0:
	                return "va" + regnum;
	            case 0x1:
	                if (desc.hasindirect && desc.header.type == "vertex") {
	                    return "vcarrr[" + regnum + "]";
	                }
	                else {
	                    return tag + "c" + regnum;
	                }
	            case 0x2:
	                return tag + "t" + regnum;
	            case 0x3:
	                return desc.header.type == "vertex" ? "outpos" : "gl_FragColor";
	            case 0x4:
	                return "vi" + regnum;
	            case 0x5:
	                return "fs" + regnum;
	            case 0x6:
	                return "tmp_FragDepth";
	            default:
	                throw "Unknown register type";
	        }
	    };
	    AGLSLParser.prototype.sourcetostring = function (s, subline, dwm, isscalar, desc, tag) {
	        var swiz = ["x", "y", "z", "w"];
	        var r;
	        if (s.indirectflag) {
	            r = "vcarrr[int(" + this.regtostring(s.indexregtype, s.regnum, desc, tag) + "." + swiz[s.indexselect] + ")";
	            var realofs = subline + s.indexoffset;
	            if (realofs < 0)
	                r += realofs.toString();
	            if (realofs > 0)
	                r += "+" + realofs.toString();
	            r += "]";
	        }
	        else {
	            r = this.regtostring(s.regtype, s.regnum + subline, desc, tag);
	        }
	        // samplers never add swizzle        
	        if (s.regtype == 0x5) {
	            return r;
	        }
	        // scalar, first component only
	        if (isscalar) {
	            return r + "." + swiz[(s.swizzle >> 0) & 3];
	        }
	        // identity
	        if (s.swizzle == 0xe4 && dwm == 0xf) {
	            return r;
	        }
	        // with destination write mask folded in
	        r += ".";
	        if (dwm & 1)
	            r += swiz[(s.swizzle >> 0) & 3];
	        if (dwm & 2)
	            r += swiz[(s.swizzle >> 2) & 3];
	        if (dwm & 4)
	            r += swiz[(s.swizzle >> 4) & 3];
	        if (dwm & 8)
	            r += swiz[(s.swizzle >> 6) & 3];
	        return r;
	    };
	    AGLSLParser.maxvertexconstants = 128;
	    AGLSLParser.maxfragconstants = 28;
	    AGLSLParser.maxtemp = 8;
	    AGLSLParser.maxstreams = 8;
	    AGLSLParser.maxtextures = 8;
	    return AGLSLParser;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AGLSLParser;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseWebGL_1 = __webpack_require__(127);
	var TextureWebGL = (function (_super) {
	    __extends(TextureWebGL, _super);
	    function TextureWebGL(gl, width, height) {
	        _super.call(this, gl);
	        this.textureType = "texture2d";
	        this._width = width;
	        this._height = height;
	        this._glTexture = this._gl.createTexture();
	    }
	    TextureWebGL.prototype.dispose = function () {
	        this._gl.deleteTexture(this._glTexture);
	    };
	    Object.defineProperty(TextureWebGL.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureWebGL.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureWebGL.prototype, "frameBuffer", {
	        get: function () {
	            if (!this._frameBuffer) {
	                this._frameBuffer = this._gl.createFramebuffer();
	                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
	                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
	                var renderBuffer = this._gl.createRenderbuffer();
	                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
	                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, this._width, this._height);
	                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
	                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
	                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
	                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	            }
	            return this._frameBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureWebGL.prototype.uploadFromData = function (data, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	        this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	    };
	    TextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	        var ext = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
	        //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
	    };
	    Object.defineProperty(TextureWebGL.prototype, "glTexture", {
	        get: function () {
	            return this._glTexture;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureWebGL.prototype.generateMipmaps = function () {
	        //TODO: implement generating mipmaps
	        //this._gl.bindTexture( this._gl.TEXTURE_2D, this._glTexture );
	        //this._gl.generateMipmap(this._gl.TEXTURE_2D);
	        //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
	    };
	    return TextureWebGL;
	}(TextureBaseWebGL_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextureWebGL;


/***/ },
/* 139 */
/***/ function(module, exports) {

	"use strict";
	var SamplerState = (function () {
	    function SamplerState() {
	    }
	    return SamplerState;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SamplerState;


/***/ },
/* 140 */
/***/ function(module, exports) {

	"use strict";
	var VertexBufferWebGL = (function () {
	    function VertexBufferWebGL(gl, numVertices, dataPerVertex) {
	        this._gl = gl;
	        this._buffer = this._gl.createBuffer();
	        this._numVertices = numVertices;
	        this._dataPerVertex = dataPerVertex;
	    }
	    VertexBufferWebGL.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
	        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        if (startVertex)
	            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, new Float32Array(vertices));
	        else
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
	    };
	    VertexBufferWebGL.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
	        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        if (startVertex)
	            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, data);
	        else
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    Object.defineProperty(VertexBufferWebGL.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferWebGL.prototype, "dataPerVertex", {
	        get: function () {
	            return this._dataPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferWebGL.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    VertexBufferWebGL.prototype.dispose = function () {
	        this._gl.deleteBuffer(this._buffer);
	    };
	    return VertexBufferWebGL;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexBufferWebGL;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ProgramData_1 = __webpack_require__(142);
	/**
	 * @class away.pool.ProgramDataPool
	 */
	var ProgramDataPool = (function () {
	    /**
	     * //TODO
	     *
	     * @param textureDataClass
	     */
	    function ProgramDataPool(stage) {
	        this._pool = new Object();
	        this._stage = stage;
	    }
	    /**
	     * //TODO
	     *
	     * @param materialOwner
	     * @returns ITexture
	     */
	    ProgramDataPool.prototype.getItem = function (vertexString, fragmentString) {
	        var key = vertexString + fragmentString;
	        return this._pool[key] || (this._pool[key] = new ProgramData_1.default(this, this._stage, vertexString, fragmentString));
	    };
	    /**
	     * //TODO
	     *
	     * @param materialOwner
	     */
	    ProgramDataPool.prototype.disposeItem = function (key) {
	        this._pool[key] = null;
	    };
	    return ProgramDataPool;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ProgramDataPool;


/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 * @class away.pool.ProgramDataBase
	 */
	var ProgramData = (function () {
	    function ProgramData(pool, context, vertexString, fragmentString) {
	        this.usages = 0;
	        this._pool = pool;
	        this.stage = context;
	        this.vertexString = vertexString;
	        this.fragmentString = fragmentString;
	        this.stage.registerProgram(this);
	    }
	    /**
	     *
	     */
	    ProgramData.prototype.dispose = function () {
	        this.usages--;
	        if (!this.usages) {
	            this._pool.disposeItem(this.vertexString + this.fragmentString);
	            this.stage.unRegisterProgram(this);
	            if (this.program) {
	                this.program.dispose();
	                this.program = null;
	            }
	        }
	    };
	    ProgramData.PROGRAMDATA_ID_COUNT = 0;
	    return ProgramData;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ProgramData;


/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.pool.SurfacePool
	 */
	var SurfacePool = (function () {
	    /**
	     * //TODO
	     *
	     * @param surfaceClassGL
	     */
	    function SurfacePool(elementsClass, stage, surfaceClassGL) {
	        if (surfaceClassGL === void 0) { surfaceClassGL = null; }
	        this._abstractionPool = new Object();
	        this._elementsClass = elementsClass;
	        this._stage = stage;
	        this._surfaceClassGL = surfaceClassGL;
	    }
	    Object.defineProperty(SurfacePool.prototype, "stage", {
	        get: function () {
	            return this._stage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * //TODO
	     *
	     * @param elementsOwner
	     * @returns IElements
	     */
	    SurfacePool.prototype.getAbstraction = function (surface) {
	        return (this._abstractionPool[surface.id] || (this._abstractionPool[surface.id] = new (this._surfaceClassGL || SurfacePool._abstractionClassPool[surface.assetType])(surface, this._elementsClass, this)));
	    };
	    /**
	     * //TODO
	     *
	     * @param elementsOwner
	     */
	    SurfacePool.prototype.clearAbstraction = function (surface) {
	        delete this._abstractionPool[surface.id];
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    SurfacePool.registerAbstraction = function (surfaceClassGL, assetClass) {
	        SurfacePool._abstractionClassPool[assetClass.assetType] = surfaceClassGL;
	    };
	    SurfacePool._abstractionClassPool = new Object();
	    return SurfacePool;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SurfacePool;


/***/ },
/* 144 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.pool.SurfacePool
	 */
	var ElementsPool = (function () {
	    /**
	     * //TODO
	     *
	     * @param surfaceClassGL
	     */
	    function ElementsPool(shader, elementsClass) {
	        this._abstractionPool = new Object();
	        this._shader = shader;
	        this._elementsClass = elementsClass;
	    }
	    /**
	     * //TODO
	     *
	     * @param renderable
	     * @returns IRenderable
	     */
	    ElementsPool.prototype.getAbstraction = function (elements) {
	        return (this._abstractionPool[elements.id] || (this._abstractionPool[elements.id] = new (this._elementsClass)(elements, this._shader, this)));
	    };
	    /**
	     * //TODO
	     *
	     * @param renderable
	     */
	    ElementsPool.prototype.clearAbstraction = function (elements) {
	        delete this._abstractionPool[elements.id];
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    ElementsPool.registerAbstraction = function (elementsClass, assetClass) {
	        ElementsPool._abstractionClassPool[assetClass.assetType] = elementsClass;
	    };
	    ElementsPool._abstractionClassPool = new Object();
	    return ElementsPool;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ElementsPool;


/***/ },
/* 145 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.sort.RenderableMergeSort
	 */
	var RenderableMergeSort = (function () {
	    function RenderableMergeSort() {
	    }
	    RenderableMergeSort.prototype.sortBlendedRenderables = function (head) {
	        var headB;
	        var fast;
	        var slow;
	        if (!head || !head.next) {
	            return head;
	        }
	        // split in two sublists
	        slow = head;
	        fast = head.next;
	        while (fast) {
	            fast = fast.next;
	            if (fast) {
	                slow = slow.next;
	                fast = fast.next;
	            }
	        }
	        headB = slow.next;
	        slow.next = null;
	        // recurse
	        head = this.sortBlendedRenderables(head);
	        headB = this.sortBlendedRenderables(headB);
	        // merge sublists while respecting order
	        var result;
	        var curr;
	        var l;
	        if (!head)
	            return headB;
	        if (!headB)
	            return head;
	        while (head && headB) {
	            if (head.zIndex < headB.zIndex) {
	                l = head;
	                head = head.next;
	            }
	            else {
	                l = headB;
	                headB = headB.next;
	            }
	            if (!result)
	                result = l;
	            else
	                curr.next = l;
	            curr = l;
	        }
	        if (head)
	            curr.next = head;
	        else if (headB)
	            curr.next = headB;
	        return result;
	    };
	    RenderableMergeSort.prototype.sortOpaqueRenderables = function (head) {
	        var headB;
	        var fast, slow;
	        if (!head || !head.next) {
	            return head;
	        }
	        // split in two sublists
	        slow = head;
	        fast = head.next;
	        while (fast) {
	            fast = fast.next;
	            if (fast) {
	                slow = slow.next;
	                fast = fast.next;
	            }
	        }
	        headB = slow.next;
	        slow.next = null;
	        // recurse
	        head = this.sortOpaqueRenderables(head);
	        headB = this.sortOpaqueRenderables(headB);
	        // merge sublists while respecting order
	        var result;
	        var curr;
	        var l;
	        var cmp = 0;
	        if (!head)
	            return headB;
	        if (!headB)
	            return head;
	        while (head && headB && head != null && headB != null) {
	            // first sort per render order id (reduces program3D switches),
	            // then on render object id (reduces setting props),
	            // then on zIndex (reduces overdraw)
	            var aid = head.renderOrderId;
	            var bid = headB.renderOrderId;
	            if (aid == bid) {
	                var ma = head.surfaceID;
	                var mb = headB.surfaceID;
	                if (ma == mb) {
	                    if (head.zIndex < headB.zIndex)
	                        cmp = 1;
	                    else
	                        cmp = -1;
	                }
	                else if (ma > mb) {
	                    cmp = 1;
	                }
	                else {
	                    cmp = -1;
	                }
	            }
	            else if (aid > bid) {
	                cmp = 1;
	            }
	            else {
	                cmp = -1;
	            }
	            if (cmp < 0) {
	                l = head;
	                head = head.next;
	            }
	            else {
	                l = headB;
	                headB = headB.next;
	            }
	            if (!result) {
	                result = l;
	                curr = l;
	            }
	            else {
	                curr.next = l;
	                curr = l;
	            }
	        }
	        if (head)
	            curr.next = head;
	        else if (headB)
	            curr.next = headB;
	        return result;
	    };
	    return RenderableMergeSort;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RenderableMergeSort;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var RendererBase_1 = __webpack_require__(100);
	var GL_DepthSurface_1 = __webpack_require__(147);
	/**
	 * The DepthRenderer class renders 32-bit depth information encoded as RGBA
	 *
	 * @class away.render.DepthRenderer
	 */
	var DepthRenderer = (function (_super) {
	    __extends(DepthRenderer, _super);
	    /**
	     * Creates a new DepthRenderer object.
	     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
	     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
	     */
	    function DepthRenderer(stage) {
	        if (stage === void 0) { stage = null; }
	        _super.call(this, stage, GL_DepthSurface_1.default);
	        this._iBackgroundR = 1;
	        this._iBackgroundG = 1;
	        this._iBackgroundB = 1;
	    }
	    /**
	     *
	     */
	    DepthRenderer.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase_1.default._iCollectionMark && node.isCastingShadow();
	        if (!enter) {
	            node._iCollectionMark = RendererBase_1.default._iCollectionMark;
	            return false;
	        }
	        return _super.prototype.enterNode.call(this, node);
	    };
	    return DepthRenderer;
	}(RendererBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DepthRenderer;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SurfacePassBase_1 = __webpack_require__(148);
	var ShaderBase_1 = __webpack_require__(171);
	/**
	 * GL_DepthSurface forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var GL_DepthSurface = (function (_super) {
	    __extends(GL_DepthSurface, _super);
	    /**
	     *
	     * @param pool
	     * @param surface
	     * @param elementsClass
	     * @param stage
	     */
	    function GL_DepthSurface(surface, elementsClass, renderPool) {
	        _super.call(this, surface, elementsClass, renderPool);
	        this._shader = new ShaderBase_1.default(elementsClass, this, this._stage);
	        this._pAddPass(this);
	    }
	    GL_DepthSurface.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._textureVO = this._surface.getTextureAt(0) ? this._shader.getAbstraction(this._surface.getTextureAt(0)) : null;
	    };
	    GL_DepthSurface.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        shader.projectionDependencies++;
	        if (shader.alphaThreshold > 0)
	            shader.uvDependencies++;
	    };
	    GL_DepthSurface.prototype._iInitConstantData = function (shader) {
	        _super.prototype._iInitConstantData.call(this, shader);
	        var index = this._fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = 1.0;
	        data[index + 1] = 255.0;
	        data[index + 2] = 65025.0;
	        data[index + 3] = 16581375.0;
	        data[index + 4] = 1.0 / 255.0;
	        data[index + 5] = 1.0 / 255.0;
	        data[index + 6] = 1.0 / 255.0;
	        data[index + 7] = 0.0;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DepthSurface.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        var targetReg = sharedRegisters.shadedTarget;
	        var dataReg1 = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        this._fragmentConstantsIndex = dataReg1.index * 4;
	        var temp1 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp1, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        code += "div " + temp1 + ", " + sharedRegisters.projectionFragment + ", " + sharedRegisters.projectionFragment + ".w\n" +
	            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
	            "frc " + temp1 + ", " + temp1 + "\n" +
	            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
	        //codeF += "mov ft1.w, fc1.w	\n" +
	        //    "mov ft0.w, fc0.x	\n";
	        if (this._textureVO && shader.alphaThreshold > 0) {
	            var albedo = registerCache.getFreeFragmentVectorTemp();
	            code += this._textureVO._iGetFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            var cutOffReg = registerCache.getFreeFragmentConstant();
	            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
	                "kil " + albedo + ".w\n";
	        }
	        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
	        registerCache.removeFragmentTempUsage(temp1);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DepthSurface.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        if (this._textureVO && this._shader.alphaThreshold > 0) {
	            this._textureVO.activate(this);
	            this._shader.fragmentConstantData[this._fragmentConstantsIndex + 8] = this._shader.alphaThreshold;
	        }
	    };
	    return GL_DepthSurface;
	}(GL_SurfacePassBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_DepthSurface;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PassEvent_1 = __webpack_require__(149);
	var GL_SurfaceBase_1 = __webpack_require__(150);
	/**
	 * GL_SurfacePassBase provides an abstract base class for material shader passes. A material pass constitutes at least
	 * a render call per required renderable.
	 */
	var GL_SurfacePassBase = (function (_super) {
	    __extends(GL_SurfacePassBase, _super);
	    function GL_SurfacePassBase() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(GL_SurfacePassBase.prototype, "shader", {
	        get: function () {
	            return this._shader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfacePassBase.prototype, "animationSet", {
	        get: function () {
	            return this._surface.animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Marks the shader program as invalid, so it will be recompiled before the next render.
	     */
	    GL_SurfacePassBase.prototype.invalidate = function () {
	        this._shader.invalidateShader();
	        this.dispatchEvent(new PassEvent_1.default(PassEvent_1.default.INVALIDATE, this));
	    };
	    GL_SurfacePassBase.prototype.dispose = function () {
	        if (this._shader) {
	            this._shader.dispose();
	            this._shader = null;
	        }
	    };
	    /**
	     * Renders the current pass. Before calling pass, activatePass needs to be called with the same index.
	     * @param pass The pass used to render the renderable.
	     * @param renderable The IRenderable object to draw.
	     * @param stage The Stage object used for rendering.
	     * @param entityCollector The EntityCollector object that contains the visible scene data.
	     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
	     * camera.viewProjection as it includes the scaling factors when rendering to textures.
	     *
	     * @internal
	     */
	    GL_SurfacePassBase.prototype._iRender = function (renderable, camera, viewProjection) {
	        this._shader._iRender(renderable, camera, viewProjection);
	    };
	    /**
	     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
	     * calling pass. Before activating a pass, the previously used pass needs to be deactivated.
	     * @param stage The Stage object which is currently used for rendering.
	     * @param camera The camera from which the scene is viewed.
	     * @private
	     */
	    GL_SurfacePassBase.prototype._iActivate = function (camera) {
	        this._shader._iActivate(camera);
	    };
	    /**
	     * Clears the render state for the pass. This needs to be called before activating another pass.
	     * @param stage The Stage used for rendering
	     *
	     * @private
	     */
	    GL_SurfacePassBase.prototype._iDeactivate = function () {
	        this._shader._iDeactivate();
	    };
	    GL_SurfacePassBase.prototype._iInitConstantData = function (shader) {
	    };
	    GL_SurfacePassBase.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    return GL_SurfacePassBase;
	}(GL_SurfaceBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_SurfacePassBase;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var PassEvent = (function (_super) {
	    __extends(PassEvent, _super);
	    function PassEvent(type, pass) {
	        _super.call(this, type);
	        this._pass = pass;
	    }
	    Object.defineProperty(PassEvent.prototype, "pass", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pass;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    PassEvent.prototype.clone = function () {
	        return new PassEvent(this.type, this._pass);
	    };
	    /**
	     *
	     */
	    PassEvent.INVALIDATE = "invalidatePass";
	    return PassEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PassEvent;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(151);
	var SurfaceEvent_1 = __webpack_require__(152);
	var MaterialBase_1 = __webpack_require__(153);
	var DefaultMaterialManager_1 = __webpack_require__(156);
	var PassEvent_1 = __webpack_require__(149);
	/**
	 *
	 * @class away.pool.Passes
	 */
	var GL_SurfaceBase = (function (_super) {
	    __extends(GL_SurfaceBase, _super);
	    function GL_SurfaceBase(surface, elementsClass, renderPool) {
	        var _this = this;
	        _super.call(this, surface, renderPool);
	        this.usages = 0;
	        this._forceSeparateMVP = false;
	        this._invalidAnimation = true;
	        this._invalidRender = true;
	        this._invalidImages = true;
	        this._passes = new Array();
	        this._imageIndices = new Object();
	        this._pRequiresBlending = false;
	        this.images = new Array();
	        this.samplers = new Array();
	        this._onInvalidateAnimationDelegate = function (event) { return _this.onInvalidateAnimation(event); };
	        this._onInvalidatePassesDelegate = function (event) { return _this.onInvalidatePasses(event); };
	        this.surfaceID = surface.id;
	        this._surface = surface;
	        this._elementsClass = elementsClass;
	        this._stage = renderPool.stage;
	        this._surface.addEventListener(SurfaceEvent_1.default.INVALIDATE_ANIMATION, this._onInvalidateAnimationDelegate);
	        this._surface.addEventListener(SurfaceEvent_1.default.INVALIDATE_PASSES, this._onInvalidatePassesDelegate);
	        this._onPassInvalidateDelegate = function (event) { return _this.onPassInvalidate(event); };
	    }
	    Object.defineProperty(GL_SurfaceBase.prototype, "requiresBlending", {
	        /**
	         * Indicates whether or not the renderable requires alpha blending during rendering.
	         */
	        get: function () {
	            return this._pRequiresBlending;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "renderOrderId", {
	        get: function () {
	            if (this._invalidAnimation)
	                this._updateAnimation();
	            return this._renderOrderId;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "passes", {
	        get: function () {
	            if (this._invalidAnimation)
	                this._updateAnimation();
	            return this._passes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "surface", {
	        get: function () {
	            return this._surface;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "numImages", {
	        get: function () {
	            if (this._invalidImages)
	                this._updateImages();
	            return this._numImages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_SurfaceBase.prototype._iIncludeDependencies = function (shader) {
	        this._elementsClass._iIncludeDependencies(shader);
	        shader.alphaThreshold = this._surface.alphaThreshold;
	        shader.useImageRect = this._surface.imageRect;
	        shader.usesCurves = this._surface.curves;
	        if (this._surface instanceof MaterialBase_1.default) {
	            var material = this._surface;
	            shader.useAlphaPremultiplied = material.alphaPremultiplied;
	            shader.useBothSides = material.bothSides;
	            shader.usesUVTransform = material.animateUVs;
	            shader.usesColorTransform = material.useColorTransform;
	        }
	    };
	    GL_SurfaceBase.prototype.getImageIndex = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (this._invalidImages)
	            this._updateImages();
	        return this._imageIndices[texture.id][index];
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._surface = null;
	        this._elementsClass = null;
	        this._stage = null;
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++) {
	            this._passes[i].removeEventListener(PassEvent_1.default.INVALIDATE, this._onPassInvalidateDelegate);
	            this._passes[i].dispose();
	        }
	        this._passes = null;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidate = function (event) {
	        _super.prototype.onInvalidate.call(this, event);
	        this._invalidRender = true;
	        this._invalidAnimation = true;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidatePasses = function (event) {
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++)
	            this._passes[i].invalidate();
	        this._invalidAnimation = true;
	        this._invalidImages = true;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidateAnimation = function (event) {
	        this._invalidAnimation = true;
	    };
	    /**
	     *
	     * @param surface
	     */
	    GL_SurfaceBase.prototype._updateAnimation = function () {
	        if (this._invalidRender)
	            this._pUpdateRender();
	        this._invalidAnimation = false;
	        var enabledGPUAnimation = this._getEnabledGPUAnimation();
	        var renderOrderId = 0;
	        var mult = 1;
	        var shader;
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++) {
	            shader = this._passes[i].shader;
	            if (shader.usesAnimation != enabledGPUAnimation) {
	                shader.usesAnimation = enabledGPUAnimation;
	                shader.invalidateProgram();
	            }
	            renderOrderId += shader.programData.id * mult;
	            mult *= 1000;
	        }
	        this._renderOrderId = renderOrderId;
	    };
	    GL_SurfaceBase.prototype._updateImages = function () {
	        this._invalidImages = false;
	        var numTextures = this._surface.getNumTextures();
	        var texture;
	        var numImages;
	        var images;
	        var image;
	        var sampler;
	        var index = 0;
	        for (var i = 0; i < numTextures; i++) {
	            texture = this._surface.getTextureAt(i);
	            numImages = texture.getNumImages();
	            images = this._imageIndices[texture.id] = new Array();
	            for (var j = 0; j < numImages; j++) {
	                image = texture.getImageAt(j) || (this._surface.style ? this._surface.style.getImageAt(texture, j) : null) || DefaultMaterialManager_1.default.getDefaultImage2D();
	                this.images[index] = this._stage.getAbstraction(image);
	                sampler = texture.getSamplerAt(j) || (this._surface.style ? this._surface.style.getSamplerAt(texture, j) : null) || DefaultMaterialManager_1.default.getDefaultSampler();
	                this.samplers[index] = this._stage.getAbstraction(sampler);
	                images[j] = index++;
	            }
	        }
	        this._numImages = index;
	    };
	    /**
	     * Performs any processing that needs to occur before any of its passes are used.
	     *
	     * @private
	     */
	    GL_SurfaceBase.prototype._pUpdateRender = function () {
	        this._invalidRender = false;
	        //overrride to update shader object properties
	    };
	    /**
	     * Removes a pass from the surface.
	     * @param pass The pass to be removed.
	     */
	    GL_SurfaceBase.prototype._pRemovePass = function (pass) {
	        pass.removeEventListener(PassEvent_1.default.INVALIDATE, this._onPassInvalidateDelegate);
	        this._passes.splice(this._passes.indexOf(pass), 1);
	    };
	    /**
	     * Removes all passes from the surface
	     */
	    GL_SurfaceBase.prototype._pClearPasses = function () {
	        var len = this._passes.length;
	        for (var i = 0; i < len; ++i)
	            this._passes[i].removeEventListener(PassEvent_1.default.INVALIDATE, this._onPassInvalidateDelegate);
	        this._passes.length = 0;
	    };
	    /**
	     * Adds a pass to the surface
	     * @param pass
	     */
	    GL_SurfaceBase.prototype._pAddPass = function (pass) {
	        this._passes.push(pass);
	        pass.addEventListener(PassEvent_1.default.INVALIDATE, this._onPassInvalidateDelegate);
	    };
	    /**
	     * Listener for when a pass's shader code changes. It recalculates the render order id.
	     */
	    GL_SurfaceBase.prototype.onPassInvalidate = function (event) {
	        this._invalidAnimation = true;
	    };
	    /**
	     * test if animation will be able to run on gpu BEFORE compiling materials
	     * test if the shader objects supports animating the animation set in the vertex shader
	     * if any object using this material fails to support accelerated animations for any of the shader objects,
	     * we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
	     */
	    GL_SurfaceBase.prototype._getEnabledGPUAnimation = function () {
	        if (this._surface.animationSet) {
	            this._surface.animationSet.resetGPUCompatibility();
	            var owners = this._surface.iOwners;
	            var numOwners = owners.length;
	            var len = this._passes.length;
	            for (var i = 0; i < len; i++)
	                for (var j = 0; j < numOwners; j++)
	                    if (owners[j].animator)
	                        owners[j].animator.testGPUCompatibility(this._passes[i].shader);
	            return !this._surface.animationSet.usesCPU;
	        }
	        return false;
	    };
	    return GL_SurfaceBase;
	}(AbstractionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_SurfaceBase;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var EventDispatcher_1 = __webpack_require__(12);
	/**
	 *
	 * @class away.pool.AbstractionBase
	 */
	var AbstractionBase = (function (_super) {
	    __extends(AbstractionBase, _super);
	    function AbstractionBase(asset, pool) {
	        var _this = this;
	        _super.call(this);
	        this._invalid = true;
	        this._asset = asset;
	        this._pool = pool;
	        this._onClearDelegate = function (event) { return _this.onClear(event); };
	        this._onInvalidateDelegate = function (event) { return _this.onInvalidate(event); };
	        this._asset.addEventListener(AssetEvent_1.default.CLEAR, this._onClearDelegate);
	        this._asset.addEventListener(AssetEvent_1.default.INVALIDATE, this._onInvalidateDelegate);
	    }
	    /**
	     *
	     */
	    AbstractionBase.prototype.onClear = function (event) {
	        this._asset.removeEventListener(AssetEvent_1.default.CLEAR, this._onClearDelegate);
	        this._asset.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onInvalidateDelegate);
	        this._pool.clearAbstraction(this._asset);
	        this._pool = null;
	        this._asset = null;
	    };
	    /**
	     *
	     */
	    AbstractionBase.prototype.onInvalidate = function (event) {
	        this._invalid = true;
	    };
	    return AbstractionBase;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AbstractionBase;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var SurfaceEvent = (function (_super) {
	    __extends(SurfaceEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param dataType An optional data type of the vertex data being updated.
	     */
	    function SurfaceEvent(type, surface) {
	        _super.call(this, type);
	        this._surface = surface;
	    }
	    Object.defineProperty(SurfaceEvent.prototype, "surface", {
	        /**
	         * The surface of the renderable.
	         */
	        get: function () {
	            return this._surface;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    SurfaceEvent.prototype.clone = function () {
	        return new SurfaceEvent(this.type, this._surface);
	    };
	    SurfaceEvent.INVALIDATE_TEXTURE = "invalidateTexture";
	    SurfaceEvent.INVALIDATE_ANIMATION = "invalidateAnimation";
	    SurfaceEvent.INVALIDATE_PASSES = "invalidatePasses";
	    return SurfaceEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SurfaceEvent;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BlendMode_1 = __webpack_require__(154);
	var ImageBase_1 = __webpack_require__(91);
	var ColorTransform_1 = __webpack_require__(46);
	var AssetEvent_1 = __webpack_require__(1);
	var AssetBase_1 = __webpack_require__(24);
	var SurfaceEvent_1 = __webpack_require__(152);
	var Style_1 = __webpack_require__(155);
	var StyleEvent_1 = __webpack_require__(77);
	/**
	 * MaterialBase forms an abstract base class for any material.
	 * A material consists of several passes, each of which constitutes at least one render call. Several passes could
	 * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
	 * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
	 * subsurface scattering, or rendering a depth map for specialized self-shadowing).
	 *
	 * Away3D provides default materials trough SinglePassMaterialBase and TriangleMaterial, which use modular
	 * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
	 * shaders, or entire new material frameworks.
	 */
	var MaterialBase = (function (_super) {
	    __extends(MaterialBase, _super);
	    function MaterialBase(imageColor, alpha) {
	        var _this = this;
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._textures = new Array();
	        this._pUseColorTransform = false;
	        this._alphaBlending = false;
	        this._alpha = 1;
	        this._pAlphaThreshold = 0;
	        this._pAnimateUVs = false;
	        this._enableLightFallOff = true;
	        this._specularLightSources = 0x01;
	        this._diffuseLightSources = 0x03;
	        this._style = new Style_1.default();
	        this._iBaseScreenPassIndex = 0;
	        this._bothSides = false; // update
	        /**
	         * A list of material owners, renderables or custom Entities.
	         */
	        this._owners = new Array();
	        this._pBlendMode = BlendMode_1.default.NORMAL;
	        this._imageRect = false;
	        this._curves = false;
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	        if (imageColor instanceof ImageBase_1.default)
	            this._style.image = imageColor;
	        else if (imageColor)
	            this._style.color = Number(imageColor);
	        this.alpha = alpha;
	        this._onLightChangeDelegate = function (event) { return _this.onLightsChange(event); };
	        this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
	        this.alphaPremultiplied = false; //TODO: work out why this is different for WebGL
	    }
	    Object.defineProperty(MaterialBase.prototype, "alpha", {
	        /**
	         * The alpha of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            if (value > 1)
	                value = 1;
	            else if (value < 0)
	                value = 0;
	            if (this._alpha == value)
	                return;
	            this._alpha = value;
	            if (this._colorTransform == null)
	                this._colorTransform = new ColorTransform_1.default();
	            this._colorTransform.alphaMultiplier = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "colorTransform", {
	        /**
	         * The ColorTransform object to transform the colour of the material with. Defaults to null.
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (value) {
	            this._colorTransform = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaBlending", {
	        /**
	         * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
	         * example when using textures of foliage, consider using alphaThreshold instead.
	         */
	        get: function () {
	            return this._alphaBlending;
	        },
	        set: function (value) {
	            if (this._alphaBlending == value)
	                return;
	            this._alphaBlending = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "animationSet", {
	        /**
	         *
	         */
	        get: function () {
	            return this._animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "lightPicker", {
	        /**
	         * The light picker used by the material to provide lights to the material if it supports lighting.
	         *
	         * @see LightPickerBase
	         * @see StaticLightPicker
	         */
	        get: function () {
	            return this._pLightPicker;
	        },
	        set: function (value) {
	            if (this._pLightPicker == value)
	                return;
	            if (this._pLightPicker)
	                this._pLightPicker.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onLightChangeDelegate);
	            this._pLightPicker = value;
	            if (this._pLightPicker)
	                this._pLightPicker.addEventListener(AssetEvent_1.default.INVALIDATE, this._onLightChangeDelegate);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "curves", {
	        /**
	         * Indicates whether material should use curves. Defaults to false.
	         */
	        get: function () {
	            return this._curves;
	        },
	        set: function (value) {
	            if (this._curves == value)
	                return;
	            this._curves = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "imageRect", {
	        /**
	         * Indicates whether or not any used textures should use an atlas. Defaults to false.
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "style", {
	        /**
	         * The style used to render the current TriangleGraphic. If set to null, its parent Sprite's style will be used instead.
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "animateUVs", {
	        /**
	         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
	         */
	        get: function () {
	            return this._pAnimateUVs;
	        },
	        set: function (value) {
	            if (this._pAnimateUVs == value)
	                return;
	            this._pAnimateUVs = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "useColorTransform", {
	        /**
	         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
	         */
	        get: function () {
	            return this._pUseColorTransform;
	        },
	        set: function (value) {
	            if (this._pUseColorTransform == value)
	                return;
	            this._pUseColorTransform = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "enableLightFallOff", {
	        /**
	         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
	         * compatibility for constrained mode.
	         */
	        get: function () {
	            return this._enableLightFallOff;
	        },
	        set: function (value) {
	            if (this._enableLightFallOff == value)
	                return;
	            this._enableLightFallOff = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "diffuseLightSources", {
	        /**
	         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
	         * and/or light probes for diffuse reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._diffuseLightSources;
	        },
	        set: function (value) {
	            if (this._diffuseLightSources == value)
	                return;
	            this._diffuseLightSources = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "specularLightSources", {
	        /**
	         * Define which light source types to use for specular reflections. This allows choosing between regular lights
	         * and/or light probes for specular reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._specularLightSources;
	        },
	        set: function (value) {
	            if (this._specularLightSources == value)
	                return;
	            this._specularLightSources = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "bothSides", {
	        /**
	         * Defines whether or not the material should cull triangles facing away from the camera.
	         */
	        get: function () {
	            return this._bothSides;
	        },
	        set: function (value) {
	            if (this._bothSides = value)
	                return;
	            this._bothSides = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "blendMode", {
	        /**
	         * The blend mode to use when drawing this renderable. The following blend modes are supported:
	         * <ul>
	         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	         * <li>BlendMode.MULTIPLY</li>
	         * <li>BlendMode.ADD</li>
	         * <li>BlendMode.ALPHA</li>
	         * </ul>
	         */
	        get: function () {
	            return this._pBlendMode;
	        },
	        set: function (value) {
	            if (this._pBlendMode == value)
	                return;
	            this._pBlendMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
	        /**
	         * Indicates whether visible textures (or other pixels) used by this material have
	         * already been premultiplied. Toggle this if you are seeing black halos around your
	         * blended alpha edges.
	         */
	        get: function () {
	            return this._alphaPremultiplied;
	        },
	        set: function (value) {
	            if (this._alphaPremultiplied == value)
	                return;
	            this._alphaPremultiplied = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaThreshold", {
	        /**
	         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
	         * invisible or entirely opaque, often used with textures for foliage, etc.
	         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
	         */
	        get: function () {
	            return this._pAlphaThreshold;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            if (this._pAlphaThreshold == value)
	                return;
	            this._pAlphaThreshold = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //
	    // MATERIAL MANAGEMENT
	    //
	    /**
	     * Mark an IRenderable as owner of this material.
	     * Assures we're not using the same material across renderables with different animations, since the
	     * Programs depend on animation. This method needs to be called when a material is assigned.
	     *
	     * @param owner The IRenderable that had this material assigned
	     *
	     * @internal
	     */
	    MaterialBase.prototype.iAddOwner = function (owner) {
	        this._owners.push(owner);
	        var animationSet;
	        var animator = owner.animator;
	        if (animator)
	            animationSet = animator.animationSet;
	        if (owner.animator) {
	            if (this._animationSet && animationSet != this._animationSet) {
	                throw new Error("A Material instance cannot be shared across material owners with different animation sets");
	            }
	            else {
	                if (this._animationSet != animationSet) {
	                    this._animationSet = animationSet;
	                    this.invalidateAnimation();
	                }
	            }
	        }
	        owner.invalidateSurface();
	    };
	    /**
	     * Removes an IRenderable as owner.
	     * @param owner
	     *
	     * @internal
	     */
	    MaterialBase.prototype.iRemoveOwner = function (owner) {
	        this._owners.splice(this._owners.indexOf(owner), 1);
	        if (this._owners.length == 0) {
	            this._animationSet = null;
	            this.invalidateAnimation();
	        }
	        owner.invalidateSurface();
	    };
	    Object.defineProperty(MaterialBase.prototype, "iOwners", {
	        /**
	         * A list of the IRenderables that use this material
	         *
	         * @private
	         */
	        get: function () {
	            return this._owners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MaterialBase.prototype.getNumTextures = function () {
	        return this._textures.length;
	    };
	    MaterialBase.prototype.getTextureAt = function (index) {
	        return this._textures[index];
	    };
	    /**
	     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
	     *
	     * @private
	     */
	    MaterialBase.prototype.invalidatePasses = function () {
	        this.dispatchEvent(new SurfaceEvent_1.default(SurfaceEvent_1.default.INVALIDATE_PASSES, this));
	    };
	    MaterialBase.prototype.invalidateAnimation = function () {
	        this.dispatchEvent(new SurfaceEvent_1.default(SurfaceEvent_1.default.INVALIDATE_ANIMATION, this));
	    };
	    MaterialBase.prototype.invalidateSurfaces = function () {
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].invalidateSurface();
	    };
	    /**
	     * Called when the light picker's configuration changed.
	     */
	    MaterialBase.prototype.onLightsChange = function (event) {
	        this.invalidate();
	    };
	    MaterialBase.prototype.invalidateTexture = function () {
	        this.dispatchEvent(new SurfaceEvent_1.default(SurfaceEvent_1.default.INVALIDATE_TEXTURE, this));
	    };
	    MaterialBase.prototype.addTextureAt = function (texture, index) {
	        var i = this._textures.indexOf(texture);
	        if (i == index)
	            return;
	        else if (i != -1)
	            this._textures.splice(i, 1);
	        this._textures.splice(index, 0, texture);
	        texture.addEventListener(AssetEvent_1.default.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.addTexture = function (texture) {
	        if (this._textures.indexOf(texture) != -1)
	            return;
	        this._textures.push(texture);
	        texture.addEventListener(AssetEvent_1.default.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.removeTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        texture.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.onTextureInvalidate = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidatePasses();
	        //invalidate renderables for number of images getter (in case it has changed)
	        this.invalidateSurfaces();
	    };
	    MaterialBase.prototype._onInvalidateProperties = function (event) {
	        this.invalidatePasses();
	    };
	    return MaterialBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MaterialBase;


/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A class that provides constant values for visual blend mode effects. These
	 * constants are used in the following:
	 * <ul>
	 *   <li> The <code>blendMode</code> property of the
	 * flash.display.DisplayObject class.</li>
	 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
	 * method of the flash.display.BitmapData class</li>
	 * </ul>
	 */
	var BlendMode = (function () {
	    function BlendMode() {
	    }
	    /**
	     * Adds the values of the constituent colors of the display object to the
	     * colors of its background, applying a ceiling of 0xFF. This setting is
	     * commonly used for animating a lightening dissolve between two objects.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
	     * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
	     * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>
	     */
	    BlendMode.ADD = "add";
	    /**
	     * Applies the alpha value of each pixel of the display object to the
	     * background. This requires the <code>blendMode</code> property of the
	     * parent display object be set to
	     * <code>away.base.BlendMode.LAYER</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.ALPHA = "alpha";
	    /**
	     * Selects the darker of the constituent colors of the display object and the
	     * colors of the background(the colors with the smaller values). This
	     * setting is commonly used for superimposing type.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
	     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.DARKEN = "darken";
	    /**
	     * Compares the constituent colors of the display object with the colors of
	     * its background, and subtracts the darker of the values of the two
	     * constituent colors from the lighter value. This setting is commonly used
	     * for more vibrant colors.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
	     * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>
	     */
	    BlendMode.DIFFERENCE = "difference";
	    /**
	     * Erases the background based on the alpha value of the display object. This
	     * process requires that the <code>blendMode</code> property of the parent
	     * display object be set to <code>flash.display.BlendMode.LAYER</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.ERASE = "erase";
	    /**
	     * Adjusts the color of each pixel based on the darkness of the display
	     * object. If the display object is lighter than 50% gray, the display object
	     * and background colors are screened, which results in a lighter color. If
	     * the display object is darker than 50% gray, the colors are multiplied,
	     * which results in a darker color. This setting is commonly used for shading
	     * effects.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.HARDLIGHT = "hardlight";
	    /**
	     * Inverts the background.
	     */
	    BlendMode.INVERT = "invert";
	    /**
	     * Forces the creation of a transparency group for the display object. This
	     * means that the display object is precomposed in a temporary buffer before
	     * it is processed further. The precomposition is done automatically if the
	     * display object is precached by means of bitmap caching or if the display
	     * object is a display object container that has at least one child object
	     * with a <code>blendMode</code> setting other than <code>"normal"</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.LAYER = "layer";
	    /**
	     * Selects the lighter of the constituent colors of the display object and
	     * the colors of the background(the colors with the larger values). This
	     * setting is commonly used for superimposing type.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
	     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.LIGHTEN = "lighten";
	    /**
	     * Multiplies the values of the display object constituent colors by the
	     * constituent colors of the background color, and normalizes by dividing by
	     * 0xFF, resulting in darker colors. This setting is commonly used for
	     * shadows and depth effects.
	     *
	     * <p>For example, if a constituent color(such as red) of one pixel in the
	     * display object and the corresponding color of the pixel in the background
	     * both have the value 0x88, the multiplied result is 0x4840. Dividing by
	     * 0xFF yields a value of 0x48 for that constituent color, which is a darker
	     * shade than the color of the display object or the color of the
	     * background.</p>
	     */
	    BlendMode.MULTIPLY = "multiply";
	    /**
	     * The display object appears in front of the background. Pixel values of the
	     * display object override the pixel values of the background. Where the
	     * display object is transparent, the background is visible.
	     */
	    BlendMode.NORMAL = "normal";
	    /**
	     * Adjusts the color of each pixel based on the darkness of the background.
	     * If the background is lighter than 50% gray, the display object and
	     * background colors are screened, which results in a lighter color. If the
	     * background is darker than 50% gray, the colors are multiplied, which
	     * results in a darker color. This setting is commonly used for shading
	     * effects.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.OVERLAY = "overlay";
	    /**
	     * Multiplies the complement(inverse) of the display object color by the
	     * complement of the background color, resulting in a bleaching effect. This
	     * setting is commonly used for highlights or to remove black areas of the
	     * display object.
	     */
	    BlendMode.SCREEN = "screen";
	    /**
	     * Uses a shader to define the blend between objects.
	     *
	     * <p>Setting the <code>blendShader</code> property to a Shader instance
	     * automatically sets the display object's <code>blendMode</code> property to
	     * <code>BlendMode.SHADER</code>. If the <code>blendMode</code> property is
	     * set to <code>BlendMode.SHADER</code> without first setting the
	     * <code>blendShader</code> property, the <code>blendMode</code> property is
	     * set to <code>BlendMode.NORMAL</code> instead. If the
	     * <code>blendShader</code> property is set(which sets the
	     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
	     * later the value of the <code>blendMode</code> property is changed, the
	     * blend mode can be reset to use the blend shader simply by setting the
	     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
	     * <code>blendShader</code> property does not need to be set again except to
	     * change the shader that's used to define the blend mode.</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.SHADER = "shader";
	    /**
	     * Subtracts the values of the constituent colors in the display object from
	     * the values of the background color, applying a floor of 0. This setting is
	     * commonly used for animating a darkening dissolve between two objects.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
	     * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
	     * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>
	     */
	    BlendMode.SUBTRACT = "subtract";
	    return BlendMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BlendMode;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(12);
	var StyleEvent_1 = __webpack_require__(77);
	/**
	 *
	 */
	var Style = (function (_super) {
	    __extends(Style, _super);
	    function Style() {
	        _super.call(this);
	        this._samplers = new Object();
	        this._images = new Object();
	        this._color = 0xFFFFFF;
	    }
	    Object.defineProperty(Style.prototype, "sampler", {
	        get: function () {
	            return this._sampler;
	        },
	        set: function (value) {
	            if (this._sampler == value)
	                return;
	            this._sampler = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "image", {
	        get: function () {
	            return this._image;
	        },
	        set: function (value) {
	            if (this._image == value)
	                return;
	            this._image = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "uvMatrix", {
	        get: function () {
	            return this._uvMatrix;
	        },
	        set: function (value) {
	            if (this._uvMatrix == value)
	                return;
	            this._uvMatrix = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "color", {
	        /**
	         * The diffuse reflectivity color of the surface.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            this._color = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Style.prototype.getImageAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return (this._images[texture.id] ? this._images[texture.id][index] : null) || this._image;
	    };
	    Style.prototype.getSamplerAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return (this._samplers[texture.id] ? this._samplers[texture.id][index] : null) || this._sampler;
	    };
	    Style.prototype.addImageAt = function (image, texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._images[texture.id])
	            this._images[texture.id] = new Array();
	        this._images[texture.id][index] = image;
	    };
	    Style.prototype.addSamplerAt = function (sampler, texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._samplers[texture.id])
	            this._samplers[texture.id] = new Array();
	        this._samplers[texture.id][index] = sampler;
	        this._invalidateProperties();
	    };
	    Style.prototype.removeImageAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._images[texture.id])
	            return;
	        this._images[texture.id][index] = null;
	        this._invalidateProperties();
	    };
	    Style.prototype.removeSamplerAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._samplers[texture.id])
	            return;
	        this._samplers[texture.id][index] = null;
	        this._invalidateProperties();
	    };
	    Style.prototype._invalidateProperties = function () {
	        this.dispatchEvent(new StyleEvent_1.default(StyleEvent_1.default.INVALIDATE_PROPERTIES, this));
	    };
	    return Style;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Style;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Sampler2D_1 = __webpack_require__(157);
	var BitmapImage2D_1 = __webpack_require__(89);
	var BitmapImageCube_1 = __webpack_require__(159);
	var LineElements_1 = __webpack_require__(161);
	var Skybox_1 = __webpack_require__(165);
	var BasicMaterial_1 = __webpack_require__(168);
	var Single2DTexture_1 = __webpack_require__(169);
	var SingleCubeTexture_1 = __webpack_require__(166);
	var Graphic_1 = __webpack_require__(75);
	var DefaultMaterialManager = (function () {
	    function DefaultMaterialManager() {
	    }
	    DefaultMaterialManager.getDefaultMaterial = function (renderable) {
	        if (renderable === void 0) { renderable = null; }
	        if (renderable != null && renderable.isAsset(Graphic_1.default) && renderable.elements.isAsset(LineElements_1.default)) {
	            if (!DefaultMaterialManager._defaultColorMaterial)
	                DefaultMaterialManager.createDefaultColorMaterial();
	            return DefaultMaterialManager._defaultColorMaterial;
	        }
	        if (renderable != null && renderable.isAsset(Skybox_1.default)) {
	            if (!DefaultMaterialManager._defaultCubeTextureMaterial)
	                DefaultMaterialManager.createDefaultCubeTextureMaterial();
	            return DefaultMaterialManager._defaultCubeTextureMaterial;
	        }
	        if (!DefaultMaterialManager._defaultTextureMaterial)
	            DefaultMaterialManager.createDefaultTextureMaterial();
	        return DefaultMaterialManager._defaultTextureMaterial;
	    };
	    DefaultMaterialManager.getDefaultTexture = function (renderable) {
	        if (renderable === void 0) { renderable = null; }
	        if (renderable != null && renderable.isAsset(Skybox_1.default)) {
	            if (!DefaultMaterialManager._defaultCubeTexture)
	                DefaultMaterialManager.createDefaultCubeTexture();
	            return DefaultMaterialManager._defaultCubeTexture;
	        }
	        if (!DefaultMaterialManager._defaultTexture)
	            DefaultMaterialManager.createDefaultTexture();
	        return DefaultMaterialManager._defaultTexture;
	    };
	    DefaultMaterialManager.getDefaultImage2D = function () {
	        if (!DefaultMaterialManager._defaultBitmapImage2D)
	            DefaultMaterialManager.createDefaultImage2D();
	        return DefaultMaterialManager._defaultBitmapImage2D;
	    };
	    DefaultMaterialManager.getDefaultImageCube = function () {
	        if (!DefaultMaterialManager._defaultBitmapImageCube)
	            DefaultMaterialManager.createDefaultImageCube();
	        return DefaultMaterialManager._defaultBitmapImageCube;
	    };
	    DefaultMaterialManager.getDefaultSampler = function () {
	        if (!DefaultMaterialManager._defaultSampler2D)
	            DefaultMaterialManager.createDefaultSampler2D();
	        return DefaultMaterialManager._defaultSampler2D;
	    };
	    DefaultMaterialManager.createDefaultTexture = function () {
	        DefaultMaterialManager._defaultTexture = new Single2DTexture_1.default();
	        DefaultMaterialManager._defaultTexture.name = "defaultTexture";
	    };
	    DefaultMaterialManager.createDefaultCubeTexture = function () {
	        DefaultMaterialManager._defaultCubeTexture = new SingleCubeTexture_1.default();
	        DefaultMaterialManager._defaultCubeTexture.name = "defaultCubeTexture";
	    };
	    DefaultMaterialManager.createDefaultImageCube = function () {
	        if (!DefaultMaterialManager._defaultBitmapImage2D)
	            DefaultMaterialManager.createDefaultImage2D();
	        var b = new BitmapImageCube_1.default(DefaultMaterialManager._defaultBitmapImage2D.width);
	        for (var i = 0; i < 6; i++)
	            b.draw(i, DefaultMaterialManager._defaultBitmapImage2D);
	        DefaultMaterialManager._defaultBitmapImageCube = b;
	    };
	    DefaultMaterialManager.createDefaultImage2D = function () {
	        var b = new BitmapImage2D_1.default(8, 8, false, 0x000000);
	        //create chekerboard
	        var i, j;
	        for (i = 0; i < 8; i++)
	            for (j = 0; j < 8; j++)
	                if ((j & 1) ^ (i & 1))
	                    b.setPixel(i, j, 0XFFFFFF);
	        DefaultMaterialManager._defaultBitmapImage2D = b;
	    };
	    DefaultMaterialManager.createDefaultTextureMaterial = function () {
	        if (!DefaultMaterialManager._defaultTexture)
	            DefaultMaterialManager.createDefaultTexture();
	        DefaultMaterialManager._defaultTextureMaterial = new BasicMaterial_1.default();
	        DefaultMaterialManager._defaultTextureMaterial.texture = DefaultMaterialManager._defaultTexture;
	        DefaultMaterialManager._defaultTextureMaterial.name = "defaultTextureMaterial";
	    };
	    DefaultMaterialManager.createDefaultCubeTextureMaterial = function () {
	        if (!DefaultMaterialManager._defaultCubeTexture)
	            DefaultMaterialManager.createDefaultCubeTexture();
	        DefaultMaterialManager._defaultCubeTextureMaterial = new BasicMaterial_1.default();
	        DefaultMaterialManager._defaultCubeTextureMaterial.texture = DefaultMaterialManager._defaultCubeTexture;
	        DefaultMaterialManager._defaultCubeTextureMaterial.name = "defaultCubeTextureMaterial";
	    };
	    DefaultMaterialManager.createDefaultColorMaterial = function () {
	        DefaultMaterialManager._defaultColorMaterial = new BasicMaterial_1.default(0xFFFFFF);
	        DefaultMaterialManager._defaultColorMaterial.name = "defaultColorMaterial";
	    };
	    DefaultMaterialManager.createDefaultSampler2D = function () {
	        DefaultMaterialManager._defaultSampler2D = new Sampler2D_1.default();
	    };
	    return DefaultMaterialManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DefaultMaterialManager;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerBase_1 = __webpack_require__(158);
	/**
	 * The Sampler2D class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Sampler2D()</code> constructor.
	 *
	 * <p>The <code>Sampler2D()</code> constructor allows you to create a Sampler2D
	 * object that contains a reference to a Image2D object. After you create a
	 * Sampler2D object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Sampler2D object can share its Image2D reference among several Sampler2D
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Sampler2D objects that reference the same Image2D object,
	 * multiple texture objects can use the same complex Image2D object without
	 * incurring the memory overhead of a Image2D object for each texture
	 * object instance.</p>

	 */
	var Sampler2D = (function (_super) {
	    __extends(Sampler2D, _super);
	    /**
	     *
	     * @param image2D
	     * @param smoothing
	     */
	    function Sampler2D(repeat, smooth, mipmap) {
	        if (repeat === void 0) { repeat = false; }
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this, smooth, mipmap);
	        this._repeat = repeat;
	        this._updateRect();
	    }
	    Object.defineProperty(Sampler2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Sampler2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "repeat", {
	        /**
	         * Controls whether or not the Sampler2D object is snapped to the nearest pixel.
	         * This value is ignored in the native and HTML5 targets.
	         * The PixelSnapping class includes possible values:
	         * <ul>
	         *   <li><code>PixelSnapping.NEVER</code> - No pixel snapping occurs.</li>
	         *   <li><code>PixelSnapping.ALWAYS</code> - The image is always snapped to
	         * the nearest pixel, independent of transformation.</li>
	         *   <li><code>PixelSnapping.AUTO</code> - The image is snapped to the
	         * nearest pixel if it is drawn with no rotation or skew and it is drawn at a
	         * scale factor of 99.9% to 100.1%. If these conditions are satisfied, the
	         * bitmap image is drawn at 100% scale, snapped to the nearest pixel.
	         * When targeting Flash Player, this value allows the image to be drawn as fast
	         * as possible using the internal vector renderer.</li>
	         * </ul>
	         */
	        //var pixelSnapping:PixelSnapping;
	        /**
	         * Controls whether or not the bitmap is smoothed when scaled. If
	         * <code>true</code>, the bitmap is smoothed when scaled. If
	         * <code>false</code>, the bitmap is not smoothed when scaled.
	         */
	        /**
	         *
	         */
	        get: function () {
	            return this._repeat;
	        },
	        set: function (value) {
	            if (this._repeat == value)
	                return;
	            this._repeat = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "imageRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this._updateRect();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "frameRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._frameRect;
	        },
	        set: function (value) {
	            if (this._frameRect == value)
	                return;
	            this._frameRect = value;
	            this._updateRect();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Sampler2D.prototype._updateRect = function () {
	    };
	    Sampler2D.assetType = "[asset Sampler2D]";
	    return Sampler2D;
	}(SamplerBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Sampler2D;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 *
	 */
	var SamplerBase = (function (_super) {
	    __extends(SamplerBase, _super);
	    /**
	     *
	     */
	    function SamplerBase(smooth, mipmap) {
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this);
	        this._smooth = smooth;
	        this._mipmap = mipmap;
	    }
	    Object.defineProperty(SamplerBase.prototype, "smooth", {
	        /**
	         *
	         */
	        get: function () {
	            return this._smooth;
	        },
	        set: function (value) {
	            if (this._smooth == value)
	                return;
	            this._smooth = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SamplerBase.prototype, "mipmap", {
	        /**
	         *
	         */
	        get: function () {
	            return this._mipmap;
	        },
	        set: function (value) {
	            if (this._mipmap == value)
	                return;
	            this._mipmap = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SamplerBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SamplerBase;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(89);
	var ImageCube_1 = __webpack_require__(160);
	var Rectangle_1 = __webpack_require__(35);
	var ColorUtils_1 = __webpack_require__(47);
	var BitmapImageUtils_1 = __webpack_require__(93);
	/**
	 * The BitmapImage2D class lets you work with the data(pixels) of a Bitmap
	 * object. You can use the methods of the BitmapImage2D class to create
	 * arbitrarily sized transparent or opaque bitmap images and manipulate them
	 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
	 * image that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes.
	 *
	 * <p>This class lets you separate bitmap rendering operations from the
	 * internal display updating routines of flash. By manipulating a
	 * BitmapImage2D object directly, you can create complex images without incurring
	 * the per-frame overhead of constantly redrawing the content from vector
	 * data.</p>
	 *
	 * <p>The methods of the BitmapImage2D class support effects that are not
	 * available through the filters available to non-bitmap display objects.</p>
	 *
	 * <p>A BitmapImage2D object contains an array of pixel data. This data can
	 * represent either a fully opaque bitmap or a transparent bitmap that
	 * contains alpha channel data. Either type of BitmapImage2D object is stored as
	 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
	 * of a single pixel in the bitmap.</p>
	 *
	 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
	 * 0 to 255) that describe the alpha transparency and the red, green, and blue
	 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
	 * represents the alpha channel value, followed by red, green, and blue.)</p>
	 *
	 * <p>The four channels(alpha, red, green, and blue) are represented as
	 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
	 * method or the <code>DisplacementMapFilter.componentX</code> and
	 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
	 * are represented by the following constants in the BitmapImage2DChannel
	 * class:</p>
	 *
	 * <ul>
	 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	 *   <li><code>BitmapImage2DChannel.RED</code></li>
	 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	 * </ul>
	 *
	 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
	 * <code>bitmapData</code> property of the Bitmap object.</p>
	 *
	 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
	 * <code>Graphics.beginBitmapFill()</code> method.</p>
	 *
	 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
	 * using the <code>flash.display.Tilesheet</code> class.</p>
	 *
	 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
	 * is 8,191 pixels in width or height, and the total number of pixels cannot
	 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
	 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
	 * is 2,880 pixels in height and 2,880 in width.</p>
	 */
	var BitmapImageCube = (function (_super) {
	    __extends(BitmapImageCube, _super);
	    /**
	     * Creates a BitmapImage2D object with a specified width and height. If you
	     * specify a value for the <code>fillColor</code> parameter, every pixel in
	     * the bitmap is set to that color.
	     *
	     * <p>By default, the bitmap is created as transparent, unless you pass
	     * the value <code>false</code> for the transparent parameter. After you
	     * create an opaque bitmap, you cannot change it to a transparent bitmap.
	     * Every pixel in an opaque bitmap uses only 24 bits of color channel
	     * information. If you define the bitmap as transparent, every pixel uses 32
	     * bits of color channel information, including an alpha transparency
	     * channel.</p>
	     *
	     * @param width       The width of the bitmap image in pixels.
	     * @param height      The height of the bitmap image in pixels.
	     * @param transparent Specifies whether the bitmap image supports per-pixel
	     *                    transparency. The default value is <code>true</code>
	     *                    (transparent). To create a fully transparent bitmap,
	     *                    set the value of the <code>transparent</code>
	     *                    parameter to <code>true</code> and the value of the
	     *                    <code>fillColor</code> parameter to 0x00000000(or to
	     *                    0). Setting the <code>transparent</code> property to
	     *                    <code>false</code> can result in minor improvements
	     *                    in rendering performance.
	     * @param fillColor   A 32-bit ARGB color value that you use to fill the
	     *                    bitmap image area. The default value is
	     *                    0xFFFFFFFF(solid white).
	     */
	    function BitmapImageCube(size, transparent, fillColor) {
	        if (transparent === void 0) { transparent = true; }
	        if (fillColor === void 0) { fillColor = null; }
	        _super.call(this, size);
	        this._imageCanvas = new Array(6);
	        this._context = new Array(6);
	        this._imageData = new Array(6);
	        this._locked = false;
	        this._transparent = transparent;
	        for (var i = 0; i < 6; i++) {
	            this._imageCanvas[i] = document.createElement("canvas");
	            this._imageCanvas[i].width = size;
	            this._imageCanvas[i].height = size;
	            this._context[i] = this._imageCanvas[i].getContext("2d");
	            if (fillColor != null)
	                this.fillRect(i, new Rectangle_1.default(0, 0, size, size), fillColor);
	        }
	    }
	    Object.defineProperty(BitmapImageCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return BitmapImageCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapImageCube.prototype, "transparent", {
	        /**
	         * Defines whether the bitmap image supports per-pixel transparency. You can
	         * set this value only when you construct a BitmapImage2D object by passing in
	         * <code>true</code> for the <code>transparent</code> parameter of the
	         * constructor. Then, after you create a BitmapImage2D object, you can check
	         * whether it supports per-pixel transparency by determining if the value of
	         * the <code>transparent</code> property is <code>true</code>.
	         */
	        get: function () {
	            return this._transparent;
	        },
	        set: function (value) {
	            this._transparent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new BitmapImage2D object that is a clone of the original instance
	     * with an exact copy of the contained bitmap.
	     *
	     * @return A new BitmapImage2D object that is identical to the original.
	     */
	    BitmapImageCube.prototype.clone = function () {
	        var t = new BitmapImageCube(this._size, this.transparent);
	        for (var i = 0; i < 6; i++) {
	            t.draw(i, this.getCanvas(i));
	        }
	        return t;
	    };
	    /**
	     * Adjusts the color values in a specified area of a bitmap image by using a
	     * <code>ColorTransform</code> object. If the rectangle matches the
	     * boundaries of the bitmap image, this method transforms the color values of
	     * the entire image.
	     *
	     * @param rect           A Rectangle object that defines the area of the
	     *                       image in which the ColorTransform object is applied.
	     * @param colorTransform A ColorTransform object that describes the color
	     *                       transformation values to apply.
	     */
	    BitmapImageCube.prototype.colorTransform = function (side, rect, colorTransform) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var data = this._imageData[side].data;
	        var i /*uint*/, j /*uint*/, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
	                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
	                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
	                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Transfers data from one channel of another BitmapImage2D object or the
	     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
	     * All of the data in the other channels in the destination BitmapImage2D object
	     * are preserved.
	     *
	     * <p>The source channel value and destination channel value can be one of
	     * following values: </p>
	     *
	     * <ul>
	     *   <li><code>BitmapImage2DChannel.RED</code></li>
	     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	     * </ul>
	     *
	     * @param sourceBitmapImage2D The input bitmap image to use. The source image
	     *                         can be a different BitmapImage2D object or it can
	     *                         refer to the current BitmapImage2D object.
	     * @param sourceRect       The source Rectangle object. To copy only channel
	     *                         data from a smaller area within the bitmap,
	     *                         specify a source rectangle that is smaller than
	     *                         the overall size of the BitmapImage2D object.
	     * @param destPoint        The destination Point object that represents the
	     *                         upper-left corner of the rectangular area where
	     *                         the new channel data is placed. To copy only
	     *                         channel data from one area to a different area in
	     *                         the destination image, specify a point other than
	     *                        (0,0).
	     * @param sourceChannel    The source channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @param destChannel      The destination channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
	     */
	    BitmapImageCube.prototype.copyChannel = function (side, sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
	        var imageData = sourceBitmap.getImageData();
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var sourceData = sourceBitmap.getImageData().data;
	        var destData = this._imageData[side].data;
	        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
	        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
	        var i /*uint*/, j /*uint*/, sourceIndex /*uint*/, destIndex;
	        for (i = 0; i < sourceRect.width; ++i) {
	            for (j = 0; j < sourceRect.height; ++j) {
	                sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
	                destIndex = (i + destPoint.x + (j + destPoint.y) * this._size) * 4;
	                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    BitmapImageCube.prototype.copyPixels = function (side, source, sourceRect, destRect) {
	        if (source instanceof BitmapImage2D_1.default)
	            source = source.getCanvas();
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._copyPixels(this._context[side], source, sourceRect, destRect);
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.default._copyPixels(this._context[side], source, sourceRect, destRect);
	        }
	        this.invalidate();
	    };
	    /**
	     * Frees memory that is used to store the BitmapImage2D object.
	     *
	     * <p>When the <code>dispose()</code> method is called on an image, the width
	     * and height of the image are set to 0. All subsequent calls to methods or
	     * properties of this BitmapImage2D instance fail, and an exception is thrown.
	     * </p>
	     *
	     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
	     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
	     * object is no longer usable and an exception may be thrown if
	     * you call functions on the BitmapImage2D object. However,
	     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
	     * object(approximately 128 bytes); the memory occupied by the actual
	     * BitmapImage2D object is released at the time the BitmapImage2D object is
	     * collected by the garbage collector.</p>
	     *
	     */
	    BitmapImageCube.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        for (var i = 0; i < 6; i++) {
	            this._context[i] = null;
	            this._imageCanvas[i] = null;
	            this._imageData[i] = null;
	        }
	        this._transparent = null;
	        this._locked = null;
	    };
	    BitmapImageCube.prototype.draw = function (side, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        if (source instanceof BitmapImage2D_1.default)
	            source = source.getCanvas();
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.default._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
	        }
	        this.invalidate();
	    };
	    /**
	     * Fills a rectangular area of pixels with a specified ARGB color.
	     *
	     * @param rect  The rectangular area to fill.
	     * @param color The ARGB color value that fills the area. ARGB colors are
	     *              often specified in hexadecimal format; for example,
	     *              0xFF336699.
	     * @throws TypeError The rect is null.
	     */
	    BitmapImageCube.prototype.fillRect = function (side, rect, color) {
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) apply fill
	            //      3) read _imageData back out
	            if (this._imageData[side])
	                this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.default._fillRect(this._context[side], rect, color, this._transparent);
	            if (this._imageData[side])
	                this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.default._fillRect(this._context[side], rect, color, this._transparent);
	        }
	        this.invalidate();
	    };
	    /**
	     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
	     * object at a specific point(<i>x</i>, <i>y</i>). The
	     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	     * alpha information is returned.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, the
	     *         method returns 0.
	     */
	    BitmapImageCube.prototype.getPixel = function (side, x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context[side].getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._size) * 4;
	            r = this._imageData[side].data[index + 0];
	            g = this._imageData[side].data[index + 1];
	            b = this._imageData[side].data[index + 2];
	            a = this._imageData[side].data[index + 3];
	        }
	        //returns black if fully transparent
	        if (!a)
	            return 0x0;
	        return (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Returns an ARGB color value that contains alpha channel data and RGB data.
	     * This method is similar to the <code>getPixel()</code> method, which
	     * returns an RGB color without alpha channel data.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	     *         returned.
	     */
	    BitmapImageCube.prototype.getPixel32 = function (side, x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context[side].getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._size) * 4;
	            r = this._imageData[side].data[index + 0];
	            g = this._imageData[side].data[index + 1];
	            b = this._imageData[side].data[index + 2];
	            a = this._imageData[side].data[index + 3];
	        }
	        return (a << 24) | (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Locks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are not updated when this BitmapImage2D object
	     * changes. To improve performance, use this method along with the
	     * <code>unlock()</code> method before and after numerous calls to the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method.
	     *
	     */
	    BitmapImageCube.prototype.lock = function () {
	        if (this._locked)
	            return;
	        this._locked = true;
	        for (var i = 0; i < 6; i++)
	            this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
	    };
	    /**
	     * Converts an Array into a rectangular region of pixel data. For each pixel,
	     * an Array element is read and written into the BitmapImage2D pixel. The data
	     * in the Array is expected to be 32-bit ARGB pixel values.
	     *
	     * @param rect        Specifies the rectangular region of the BitmapImage2D
	     *                    object.
	     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
	     *                    values to be used in the rectangular region.
	     * @throws RangeError The vector array is not large enough to read all the
	     *                    pixel data.
	     */
	    BitmapImageCube.prototype.setArray = function (side, rect, inputArray) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var i /*uint*/, j /*uint*/, index /*uint*/, argb;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                argb = ColorUtils_1.default.float32ColorToARGB(inputArray[i + j * rect.width]);
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                this._imageData[side].data[index + 0] = argb[1];
	                this._imageData[side].data[index + 1] = argb[2];
	                this._imageData[side].data[index + 2] = argb[3];
	                this._imageData[side].data[index + 3] = argb[0];
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
	     * value of the image pixel is preserved during this operation. The value of
	     * the RGB color parameter is treated as an unmultiplied color value.
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting RGB color for the pixel.
	     */
	    BitmapImageCube.prototype.setPixel = function (side, x, y, color) {
	        var argb = ColorUtils_1.default.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var index = (x + y * this._size) * 4;
	        this._imageData[side].data[index + 0] = argb[1];
	        this._imageData[side].data[index + 1] = argb[2];
	        this._imageData[side].data[index + 2] = argb[3];
	        this._imageData[side].data[index + 3] = 255;
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets the color and alpha transparency values of a single pixel of a
	     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
	     * method; the main difference is that the <code>setPixel32()</code> method
	     * takes an ARGB color value that contains alpha channel information.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting ARGB color for the pixel. If the bitmap is
	     *              opaque(not transparent), the alpha transparency portion of
	     *              this color value is ignored.
	     */
	    BitmapImageCube.prototype.setPixel32 = function (side, x, y, color) {
	        var argb = ColorUtils_1.default.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var index = (x + y * this._size) * 4;
	        this._imageData[side].data[index + 0] = argb[1];
	        this._imageData[side].data[index + 1] = argb[2];
	        this._imageData[side].data[index + 2] = argb[3];
	        this._imageData[side].data[index + 3] = argb[0];
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Converts a byte array into a rectangular region of pixel data. For each
	     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	     * the return value is written into the pixel. If the byte array ends before
	     * the full rectangle is written, the function returns. The data in the byte
	     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	     * on the byte array before or after the pixels are read.
	     *
	     * @param rect           Specifies the rectangular region of the BitmapImage2D
	     *                       object.
	     * @param inputByteArray A ByteArray object that consists of 32-bit
	     *                       unmultiplied pixel values to be used in the
	     *                       rectangular region.
	     * @throws EOFError  The <code>inputByteArray</code> object does not include
	     *                   enough data to fill the area of the <code>rect</code>
	     *                   rectangle. The method fills as many pixels as possible
	     *                   before throwing the exception.
	     * @throws TypeError The rect or inputByteArray are null.
	     */
	    BitmapImageCube.prototype.setPixels = function (side, rect, inputByteArray) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        inputByteArray.position = 0;
	        var i /*uint*/, j /*uint*/, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                this._imageData[side].data[index + 0] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 1] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 2] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 3] = inputByteArray.readUnsignedInt();
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Unlocks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
	     * To improve performance, use this method along with the <code>lock()</code>
	     * method before and after numerous calls to the <code>setPixel()</code> or
	     * <code>setPixel32()</code> method.
	     *
	     * @param changeRect The area of the BitmapImage2D object that has changed. If
	     *                   you do not specify a value for this parameter, the
	     *                   entire area of the BitmapImage2D object is considered
	     *                   changed.
	     */
	    BitmapImageCube.prototype.unlock = function () {
	        if (!this._locked)
	            return;
	        this._locked = false;
	        for (var i = 0; i < 6; i++) {
	            this._context[i].putImageData(this._imageData[i], 0, 0); // at coords 0,0
	            this._imageData[i] = null;
	        }
	    };
	    /**
	     *
	     * @returns {ImageData}
	     */
	    BitmapImageCube.prototype.getImageData = function (side) {
	        if (!this._locked)
	            return this._context[side].getImageData(0, 0, this._size, this._size);
	        return this._imageData[side];
	    };
	    /**
	     *
	     * @returns {HTMLCanvasElement}
	     */
	    BitmapImageCube.prototype.getCanvas = function (side) {
	        return this._imageCanvas[side];
	    };
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    BitmapImageCube.prototype._setSize = function (size) {
	        _super.prototype._setSize.call(this, size);
	        for (var i = 0; i < 6; i++) {
	            if (this._locked)
	                this._context[i].putImageData(this._imageData[i], 0, 0);
	            this._imageCanvas[i].width = size;
	            this._imageCanvas[i].height = size;
	            if (this._locked)
	                this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
	        }
	    };
	    BitmapImageCube.assetType = "[image BitmapImageCube]";
	    BitmapImageCube.posX = 0;
	    BitmapImageCube.negX = 1;
	    BitmapImageCube.posY = 2;
	    BitmapImageCube.negY = 3;
	    BitmapImageCube.posZ = 4;
	    BitmapImageCube.negZ = 5;
	    return BitmapImageCube;
	}(ImageCube_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BitmapImageCube;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageBase_1 = __webpack_require__(91);
	var ImageUtils_1 = __webpack_require__(92);
	var ImageCube = (function (_super) {
	    __extends(ImageCube, _super);
	    /**
	     *
	     */
	    function ImageCube(size) {
	        _super.call(this);
	        this._size = size;
	        this._testDimensions();
	    }
	    Object.defineProperty(ImageCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return ImageCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageCube.prototype, "size", {
	        /**
	         * The size of the cube bitmap in pixels.
	         */
	        get: function () {
	            return this._size;
	        },
	        set: function (value) {
	            if (this._size == value)
	                return;
	            this._setSize(this._size);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    ImageCube.prototype._setSize = function (size) {
	        if (this._size != size)
	            this.clear();
	        this._size = size;
	        this._testDimensions();
	    };
	    /**
	     *
	     * @private
	     */
	    ImageCube.prototype._testDimensions = function () {
	        if (!ImageUtils_1.default.isDimensionValid(this._size))
	            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
	    };
	    ImageCube.assetType = "[image ImageCube]";
	    return ImageCube;
	}(ImageBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageCube;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Byte4Attributes_1 = __webpack_require__(84);
	var Float1Attributes_1 = __webpack_require__(162);
	var ElementsBase_1 = __webpack_require__(163);
	var ElementsUtils_1 = __webpack_require__(79);
	/**
	 * @class LineElements
	 */
	var LineElements = (function (_super) {
	    __extends(LineElements, _super);
	    /**
	     *
	     */
	    function LineElements(concatenatedBuffer) {
	        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
	        _super.call(this, concatenatedBuffer);
	        this._numVertices = 0;
	        this._positions = new AttributesView_1.default(Float32Array, 6, concatenatedBuffer);
	    }
	    Object.defineProperty(LineElements.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return LineElements.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "positions", {
	        /**
	         *
	         */
	        get: function () {
	            return this._positions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "thickness", {
	        /**
	         *
	         */
	        get: function () {
	            return this._thickness;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "colors", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._colors)
	                this.setColors(this._colors);
	            return this._colors;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "numVertices", {
	        /**
	         * The total amount of vertices in the LineElements.
	         */
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LineElements.prototype.getBoxBounds = function (target) {
	        if (target === void 0) { target = null; }
	        //TODO bounding calculations for lines
	        return target;
	    };
	    LineElements.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        //TODO bounding calculations for lines
	        return target;
	    };
	    LineElements.prototype.setPositions = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._positions);
	            this._positions = values;
	        }
	        else if (values) {
	            var i = 0;
	            var j = 0;
	            var index = 0;
	            var positions = new Float32Array(values.length * 4);
	            var indices = new Uint16Array(values.length);
	            while (i < values.length) {
	                if (index / 6 & 1) {
	                    positions[index] = values[i + 3];
	                    positions[index + 1] = values[i + 4];
	                    positions[index + 2] = values[i + 5];
	                    positions[index + 3] = values[i];
	                    positions[index + 4] = values[i + 1];
	                    positions[index + 5] = values[i + 2];
	                }
	                else {
	                    positions[index] = values[i];
	                    positions[index + 1] = values[i + 1];
	                    positions[index + 2] = values[i + 2];
	                    positions[index + 3] = values[i + 3];
	                    positions[index + 4] = values[i + 4];
	                    positions[index + 5] = values[i + 5];
	                }
	                index += 6;
	                if (++j == 4) {
	                    var o = index / 6 - 4;
	                    indices.set([o, o + 1, o + 2, o + 3, o + 2, o + 1], i);
	                    j = 0;
	                    i += 6;
	                }
	            }
	            this._positions.set(positions, offset * 4);
	            this.setIndices(indices, offset);
	        }
	        else {
	            this.clearVertices(this._positions);
	            this._positions = new AttributesView_1.default(Float32Array, 6, this._concatenatedBuffer);
	        }
	        this._numVertices = this._positions.count;
	        this.invalidateVertices(this._positions);
	        this._verticesDirty[this._positions.id] = false;
	    };
	    LineElements.prototype.setThickness = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof Float1Attributes_1.default) {
	            this._thickness = values;
	        }
	        else if (values) {
	            if (!this._thickness)
	                this._thickness = new Float1Attributes_1.default(this._concatenatedBuffer);
	            var i = 0;
	            var j = 0;
	            var index = 0;
	            var thickness = new Float32Array(values.length * 4);
	            while (i < values.length) {
	                thickness[index] = (Math.floor(0.5 * index + 0.5) & 1) ? -values[i] : values[i];
	                if (++j == 4) {
	                    j = 0;
	                    i++;
	                }
	                index++;
	            }
	            this._thickness.set(thickness, offset * 4);
	        }
	        else if (this._thickness) {
	            this._thickness.dispose();
	            this._thickness = null;
	        }
	        this.invalidateVertices(this._thickness);
	        this._verticesDirty[this._thickness.id] = false;
	    };
	    LineElements.prototype.setColors = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values) {
	            if (values == this._colors)
	                return;
	            if (values instanceof Byte4Attributes_1.default) {
	                this.clearVertices(this._colors);
	                this._colors = values;
	            }
	            else {
	                if (!this._colors)
	                    this._colors = new Byte4Attributes_1.default(this._concatenatedBuffer);
	                var i = 0;
	                var j = 0;
	                var index = 0;
	                var colors = new Uint8Array(values.length * 4);
	                while (i < values.length) {
	                    if (index / 4 & 1) {
	                        colors[index] = values[i + 4];
	                        colors[index + 1] = values[i + 5];
	                        colors[index + 2] = values[i + 6];
	                        colors[index + 3] = values[i + 7];
	                    }
	                    else {
	                        colors[index] = values[i];
	                        colors[index + 1] = values[i + 1];
	                        colors[index + 2] = values[i + 2];
	                        colors[index + 3] = values[i + 3];
	                    }
	                    if (++j == 4) {
	                        j = 0;
	                        i += 8;
	                    }
	                    index += 4;
	                }
	                this._colors.set(colors, offset * 4);
	            }
	        }
	        else {
	            //auto-derive colors
	            this._colors = ElementsUtils_1.default.generateColors(this.indices, this._colors, this._concatenatedBuffer, this._numVertices);
	        }
	        this.invalidateVertices(this._colors);
	        this._verticesDirty[this._colors.id] = false;
	    };
	    /**
	     *
	     */
	    LineElements.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._positions.dispose();
	        this._positions = null;
	        this._thickness.dispose();
	        this._thickness = null;
	        this._colors.dispose();
	        this._colors = null;
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    LineElements.prototype.clone = function () {
	        var clone = new LineElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
	        clone.setIndices(this.indices.clone());
	        clone.setPositions(this._positions.clone());
	        clone.setThickness(this._thickness.clone());
	        clone.setColors(this._colors.clone());
	        return clone;
	    };
	    LineElements.prototype._iTestCollision = function (pickingCollider, material, pickingCollision) {
	        return pickingCollider.testLineCollision(this, material, pickingCollision);
	    };
	    LineElements.assetType = "[asset LineElements]";
	    return LineElements;
	}(ElementsBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LineElements;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float1Attributes = (function (_super) {
	    __extends(Float1Attributes, _super);
	    function Float1Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 1, attributesBufferLength);
	    }
	    Object.defineProperty(Float1Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float1Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float1Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float1Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float1Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float1Attributes(attributesBuffer));
	    };
	    Float1Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float1Attributes.assetType = "[attributes Float1Attributes]";
	    return Float1Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Float1Attributes;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float3Attributes_1 = __webpack_require__(81);
	var Short3Attributes_1 = __webpack_require__(164);
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetBase_1 = __webpack_require__(24);
	var ElementsEvent_1 = __webpack_require__(78);
	/**
	 * @class away.base.TriangleElements
	 */
	var ElementsBase = (function (_super) {
	    __extends(ElementsBase, _super);
	    /**
	     *
	     */
	    function ElementsBase(concatenatedBuffer) {
	        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
	        _super.call(this);
	        this._customAttributesNames = new Array();
	        this._customAttributes = new Object();
	        this._numElements = 0;
	        this._verticesDirty = new Object();
	        this._invalidateVertices = new Object();
	        this._concatenatedBuffer = concatenatedBuffer;
	    }
	    Object.defineProperty(ElementsBase.prototype, "concatenatedBuffer", {
	        get: function () {
	            return this._concatenatedBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ElementsBase.prototype, "indices", {
	        /**
	         * The raw index data that define the faces.
	         */
	        get: function () {
	            return this._indices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    ElementsBase.prototype.getCustomAtributesNames = function () {
	        return this._customAttributesNames;
	    };
	    /**
	     *
	     */
	    ElementsBase.prototype.getCustomAtributes = function (name) {
	        return this._customAttributes[name];
	    };
	    Object.defineProperty(ElementsBase.prototype, "numElements", {
	        /**
	         * The total amount of triangles in the TriangleElements.
	         */
	        get: function () {
	            return this._numElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ElementsBase.prototype, "numVertices", {
	        get: function () {
	            throw new AbstractMethodError_1.default();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ElementsBase.prototype.copyTo = function (elements) {
	        if (this.indices)
	            elements.setIndices(this.indices.clone());
	        for (var name in this._customAttributes)
	            elements.setCustomAttributes(name, this.getCustomAtributes(name).clone());
	    };
	    /**
	     *
	     */
	    ElementsBase.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._indices) {
	            this._indices.dispose();
	            this._indices = null;
	        }
	        for (var name in this._customAttributes) {
	            this._customAttributes[name].dispose();
	            delete this._customAttributes;
	        }
	    };
	    ElementsBase.prototype.setIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof Short3Attributes_1.default) {
	            if (this._indices)
	                this.clearIndices();
	            this._indices = values;
	        }
	        else if (values) {
	            if (!this._indices)
	                this._indices = new Short3Attributes_1.default();
	            this._indices.set(values, offset);
	        }
	        else if (this._indices) {
	            this._indices.dispose();
	            this._indices = null;
	            this.clearIndices();
	        }
	        if (this._indices) {
	            this._numElements = this._indices.count;
	            this.invalidateIndicies();
	        }
	        else {
	            this._numElements = 0;
	        }
	    };
	    ElementsBase.prototype.setCustomAttributes = function (name, values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._customAttributes[name])
	            return;
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._customAttributes[name]);
	            this._customAttributes[name] = values;
	        }
	        else if (values) {
	            if (!this._customAttributes[name])
	                this._customAttributes[name] = new Float3Attributes_1.default(this._concatenatedBuffer); //default custom atrributes is Float3
	            this._customAttributes[name].set(values, offset);
	        }
	        else if (this._customAttributes[name]) {
	            this.clearVertices(this._customAttributes[name]);
	            this._customAttributesNames.splice(this._customAttributesNames.indexOf(name), 1);
	            delete this._customAttributes[name];
	            return;
	        }
	        this.invalidateVertices(this._customAttributes[name]);
	        this._verticesDirty[this._customAttributes[name].id] = false;
	        if (this._customAttributesNames.indexOf(name) == -1)
	            this._customAttributesNames.push(name);
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    ElementsBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    ElementsBase.prototype.applyTransformation = function (transform) {
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    ElementsBase.prototype.scale = function (scale) {
	    };
	    ElementsBase.prototype.scaleUV = function (scaleU, scaleV) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	    };
	    ElementsBase.prototype.getBoxBounds = function (target) {
	        if (target === void 0) { target = null; }
	        throw new AbstractMethodError_1.default();
	    };
	    ElementsBase.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        throw new AbstractMethodError_1.default();
	    };
	    ElementsBase.prototype.hitTestPoint = function (x, y, z, box) {
	        throw new AbstractMethodError_1.default();
	    };
	    ElementsBase.prototype.invalidateIndicies = function () {
	        if (!this._invalidateIndices)
	            this._invalidateIndices = new ElementsEvent_1.default(ElementsEvent_1.default.INVALIDATE_INDICES, this._indices);
	        this.dispatchEvent(this._invalidateIndices);
	    };
	    ElementsBase.prototype.clearIndices = function () {
	        this.dispatchEvent(new ElementsEvent_1.default(ElementsEvent_1.default.CLEAR_INDICES, this._indices));
	    };
	    ElementsBase.prototype.invalidateVertices = function (attributesView) {
	        if (!attributesView || this._verticesDirty[attributesView.id])
	            return;
	        this._verticesDirty[attributesView.id] = true;
	        if (!this._invalidateVertices[attributesView.id])
	            this._invalidateVertices[attributesView.id] = new ElementsEvent_1.default(ElementsEvent_1.default.INVALIDATE_VERTICES, attributesView);
	        this.dispatchEvent(this._invalidateVertices[attributesView.id]);
	    };
	    ElementsBase.prototype.clearVertices = function (attributesView) {
	        if (!attributesView)
	            return;
	        attributesView.dispose();
	        this.dispatchEvent(new ElementsEvent_1.default(ElementsEvent_1.default.CLEAR_VERTICES, attributesView));
	        this._verticesDirty[attributesView.id] = null;
	        this._invalidateVertices[attributesView.id] = null;
	    };
	    ElementsBase.prototype._iTestCollision = function (pickingCollider, material, pickingCollision) {
	        throw new AbstractMethodError_1.default();
	    };
	    return ElementsBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ElementsBase;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Short3Attributes = (function (_super) {
	    __extends(Short3Attributes, _super);
	    function Short3Attributes(attributesBufferLength, unsigned) {
	        if (unsigned === void 0) { unsigned = true; }
	        _super.call(this, unsigned ? Uint16Array : Int16Array, 3, attributesBufferLength, unsigned);
	    }
	    Object.defineProperty(Short3Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Short3Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Short3Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Short3Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Short3Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Short3Attributes(attributesBuffer, this._arrayClass == Uint16Array));
	    };
	    Short3Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Short3Attributes.assetType = "[attributes Short3Attributes]";
	    return Short3Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Short3Attributes;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var BlendMode_1 = __webpack_require__(154);
	var DisplayObject_1 = __webpack_require__(45);
	var BoundsType_1 = __webpack_require__(50);
	var RenderableEvent_1 = __webpack_require__(76);
	var SurfaceEvent_1 = __webpack_require__(152);
	var SingleCubeTexture_1 = __webpack_require__(166);
	var Style_1 = __webpack_require__(155);
	var StyleEvent_1 = __webpack_require__(77);
	/**
	 * A Skybox class is used to render a sky in the scene. It's always considered static and 'at infinity', and as
	 * such it's always centered at the camera's position and sized to exactly fit within the camera's frustum, ensuring
	 * the sky box is always as large as possible without being clipped.
	 */
	var Skybox = (function (_super) {
	    __extends(Skybox, _super);
	    /**
	     * Create a new Skybox object.
	     *
	     * @param material	The material with which to render the Skybox.
	     */
	    function Skybox(image) {
	        var _this = this;
	        if (image === void 0) { image = null; }
	        _super.call(this);
	        this._textures = new Array();
	        this._pAlphaThreshold = 0;
	        this._pBlendMode = BlendMode_1.default.NORMAL;
	        this._curves = false;
	        this._imageRect = false;
	        this._style = new Style_1.default();
	        this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	        this._pIsEntity = true;
	        this._owners = new Array(this);
	        this._style.image = image;
	        this.texture = new SingleCubeTexture_1.default();
	        //default bounds type
	        this._boundsType = BoundsType_1.default.NULL;
	    }
	    Object.defineProperty(Skybox.prototype, "alphaThreshold", {
	        /**
	         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
	         * invisible or entirely opaque, often used with textures for foliage, etc.
	         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
	         */
	        get: function () {
	            return this._pAlphaThreshold;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            if (this._pAlphaThreshold == value)
	                return;
	            this._pAlphaThreshold = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "curves", {
	        /**
	         * Indicates whether skybox should use curves. Defaults to false.
	         */
	        get: function () {
	            return this._curves;
	        },
	        set: function (value) {
	            if (this._curves == value)
	                return;
	            this._curves = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "imageRect", {
	        /**
	         * Indicates whether or not the Skybox texture should use imageRects. Defaults to false.
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "lightPicker", {
	        /**
	         * The light picker used by the material to provide lights to the material if it supports lighting.
	         *
	         * @see LightPickerBase
	         * @see StaticLightPicker
	         */
	        get: function () {
	            return this._pLightPicker;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "animationSet", {
	        /**
	         *
	         */
	        get: function () {
	            return this._animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "blendMode", {
	        /**
	         * The blend mode to use when drawing this renderable. The following blend modes are supported:
	         * <ul>
	         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	         * <li>BlendMode.MULTIPLY</li>
	         * <li>BlendMode.ADD</li>
	         * <li>BlendMode.ALPHA</li>
	         * </ul>
	         */
	        get: function () {
	            return this._pBlendMode;
	        },
	        set: function (value) {
	            if (this._pBlendMode == value)
	                return;
	            this._pBlendMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "iOwners", {
	        /**
	         * A list of the IRenderables that use this material
	         *
	         * @private
	         */
	        get: function () {
	            return this._owners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "animator", {
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "texture", {
	        /**
	        * The cube texture to use as the skybox.
	        */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.removeTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.addTexture(this._texture);
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Skybox.prototype.getNumTextures = function () {
	        return this._textures.length;
	    };
	    Skybox.prototype.getTextureAt = function (index) {
	        return this._textures[index];
	    };
	    Object.defineProperty(Skybox.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._style;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "assetType", {
	        get: function () {
	            return Skybox.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
	     *
	     * @private
	     */
	    Skybox.prototype.invalidatePasses = function () {
	        this.dispatchEvent(new SurfaceEvent_1.default(SurfaceEvent_1.default.INVALIDATE_PASSES, this));
	    };
	    Skybox.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.default(RenderableEvent_1.default.INVALIDATE_RENDER_OWNER, this));
	    };
	    Skybox.prototype.addTexture = function (texture) {
	        this._textures.push(texture);
	        texture.addEventListener(AssetEvent_1.default.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    Skybox.prototype.removeTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        texture.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    Skybox.prototype.onTextureInvalidate = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidate();
	    };
	    Skybox.prototype._onInvalidateProperties = function (event) {
	        this.invalidatePasses();
	    };
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Skybox.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return false;
	    };
	    Skybox.assetType = "[asset Skybox]";
	    return Skybox;
	}(DisplayObject_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Skybox;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBase_1 = __webpack_require__(167);
	var SingleCubeTexture = (function (_super) {
	    __extends(SingleCubeTexture, _super);
	    function SingleCubeTexture(imageCube) {
	        if (imageCube === void 0) { imageCube = null; }
	        _super.call(this);
	        this.setNumImages(1);
	        this.imageCube = imageCube;
	    }
	    Object.defineProperty(SingleCubeTexture.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return SingleCubeTexture.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SingleCubeTexture.prototype, "samplerCube", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._samplers[0];
	        },
	        set: function (value) {
	            if (this._samplers[0] == value)
	                return;
	            this.setSamplerAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SingleCubeTexture.prototype, "imageCube", {
	        /**
	         *
	         * @returns {ImageCube}
	         */
	        get: function () {
	            return this._images[0];
	        },
	        set: function (value) {
	            if (this._images[0] == value)
	                return;
	            this.setImageAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SingleCubeTexture.assetType = "[texture SingleCubeTexture]";
	    return SingleCubeTexture;
	}(TextureBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SingleCubeTexture;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 *
	 */
	var TextureBase = (function (_super) {
	    __extends(TextureBase, _super);
	    /**
	     *
	     */
	    function TextureBase() {
	        _super.call(this);
	        this._numImages = 0;
	        this._images = new Array();
	        this._samplers = new Array();
	    }
	    TextureBase.prototype.getNumImages = function () {
	        return this._numImages;
	    };
	    TextureBase.prototype.setNumImages = function (value) {
	        if (this._numImages == value)
	            return;
	        this._numImages = value;
	        this._images.length = value;
	        this._samplers.length = value;
	        this.invalidate();
	    };
	    TextureBase.prototype.getImageAt = function (index) {
	        return this._images[index];
	    };
	    TextureBase.prototype.setImageAt = function (image, index) {
	        this._images[index] = image;
	        this.invalidate();
	    };
	    TextureBase.prototype.getSamplerAt = function (index) {
	        return this._samplers[index];
	    };
	    TextureBase.prototype.setSamplerAt = function (sampler, index) {
	        this._samplers[index] = sampler;
	        this.invalidate();
	    };
	    return TextureBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextureBase;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(90);
	var MaterialBase_1 = __webpack_require__(153);
	var Single2DTexture_1 = __webpack_require__(169);
	/**
	 * BasicMaterial forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var BasicMaterial = (function (_super) {
	    __extends(BasicMaterial, _super);
	    function BasicMaterial(imageColor, alpha) {
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this, imageColor, alpha);
	        this._preserveAlpha = false;
	        //set a texture if an image is present
	        if (imageColor instanceof Image2D_1.default)
	            this.texture = new Single2DTexture_1.default();
	    }
	    Object.defineProperty(BasicMaterial.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return BasicMaterial.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BasicMaterial.prototype, "preserveAlpha", {
	        /**
	         * Indicates whether alpha should be preserved - defaults to false
	         */
	        get: function () {
	            return this._preserveAlpha;
	        },
	        set: function (value) {
	            if (this._preserveAlpha == value)
	                return;
	            this._preserveAlpha = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BasicMaterial.prototype, "texture", {
	        /**
	         * The texture object to use for the albedo colour.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.removeTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.addTexture(this._texture);
	            this.invalidateTexture();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BasicMaterial.assetType = "[materials BasicMaterial]";
	    return BasicMaterial;
	}(MaterialBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BasicMaterial;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	var ImageUtils_1 = __webpack_require__(92);
	var MappingMode_1 = __webpack_require__(170);
	var TextureBase_1 = __webpack_require__(167);
	var Single2DTexture = (function (_super) {
	    __extends(Single2DTexture, _super);
	    function Single2DTexture(image2D) {
	        if (image2D === void 0) { image2D = null; }
	        _super.call(this);
	        this.setNumImages(1);
	        this.image2D = image2D;
	        this._mappingMode = MappingMode_1.default.NORMAL;
	    }
	    Object.defineProperty(Single2DTexture.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Single2DTexture.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "mappingMode", {
	        get: function () {
	            return this._mappingMode;
	        },
	        set: function (value) {
	            if (this._mappingMode == value)
	                return;
	            this._mappingMode = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "sampler2D", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._samplers[0];
	        },
	        set: function (value) {
	            if (this._samplers[0] == value)
	                return;
	            this.setSamplerAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "image2D", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._images[0];
	        },
	        set: function (value) {
	            if (this._images[0] == value)
	                return;
	            if (!ImageUtils_1.default.isImage2DValid(value))
	                throw new ErrorBase_1.default("Invalid image2DData: Width and height must be power of 2 and cannot exceed 2048");
	            this.setImageAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Single2DTexture.assetType = "[texture Single2DTexture]";
	    return Single2DTexture;
	}(TextureBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Single2DTexture;


/***/ },
/* 170 */
/***/ function(module, exports) {

	"use strict";
	/**


	 */
	var MappingMode = (function () {
	    function MappingMode() {
	    }
	    /**
	     *
	     */
	    MappingMode.NORMAL = "normal";
	    /**
	     *
	     */
	    MappingMode.LINEAR_GRADIENT = "linearGradient";
	    /**
	     *
	     */
	    MappingMode.RADIAL_GRADIENT = "radialGradient";
	    return MappingMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MappingMode;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BlendMode_1 = __webpack_require__(154);
	var ArgumentError_1 = __webpack_require__(33);
	var ContextGLBlendFactor_1 = __webpack_require__(112);
	var ContextGLCompareMode_1 = __webpack_require__(98);
	var ContextGLTriangleFace_1 = __webpack_require__(125);
	var ElementsPool_1 = __webpack_require__(144);
	var CompilerBase_1 = __webpack_require__(172);
	/**
	 * ShaderBase keeps track of the number of dependencies for "named registers" used across a pass.
	 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
	 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
	 * each time a method has been compiled into the shader.
	 *
	 * @see RegisterPool.addUsage
	 */
	var ShaderBase = (function () {
	    /**
	     * Creates a new MethodCompilerVO object.
	     */
	    function ShaderBase(elementsClass, pass, stage) {
	        this._abstractionPool = new Object();
	        this._blendFactorSource = ContextGLBlendFactor_1.default.ONE;
	        this._blendFactorDest = ContextGLBlendFactor_1.default.ZERO;
	        this._invalidShader = true;
	        this._invalidProgram = true;
	        this._animationVertexCode = "";
	        this._animationFragmentCode = "";
	        this.usesBlending = false;
	        this.useImageRect = false;
	        this.usesCurves = false;
	        /**
	         * The depth compare mode used to render the renderables using this material.
	         *
	         * @see away.stagegl.ContextGLCompareMode
	         */
	        this.depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;
	        /**
	         * Indicate whether the shader should write to the depth buffer or not. Ignored when blending is enabled.
	         */
	        this.writeDepth = true;
	        this._defaultCulling = ContextGLTriangleFace_1.default.BACK;
	        this._pInverseSceneMatrix = new Float32Array(16);
	        //set ambient values to default
	        this.ambientR = 0xFF;
	        this.ambientG = 0xFF;
	        this.ambientB = 0xFF;
	        /**
	         * Indicates whether there are any dependencies on the world-space position vector.
	         */
	        this.usesGlobalPosFragment = false;
	        /**
	         * Indicates whether there are any dependencies on the local position vector.
	         */
	        this.usesPositionFragment = false;
	        /**
	         *
	         */
	        this.imageIndices = new Array();
	        this._elementsClass = elementsClass;
	        this._pass = pass;
	        this._stage = stage;
	        this.profile = this._stage.profile;
	        this._elementsPool = new ElementsPool_1.default(this, elementsClass);
	    }
	    Object.defineProperty(ShaderBase.prototype, "programData", {
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._programData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShaderBase.prototype.getAbstraction = function (texture) {
	        return (this._abstractionPool[texture.id] || (this._abstractionPool[texture.id] = new ShaderBase._abstractionClassPool[texture.assetType](texture, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    ShaderBase.prototype.clearAbstraction = function (texture) {
	        this._abstractionPool[texture.id] = null;
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    ShaderBase.registerAbstraction = function (gl_assetClass, assetClass) {
	        ShaderBase._abstractionClassPool[assetClass.assetType] = gl_assetClass;
	    };
	    ShaderBase.prototype.getImageIndex = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return this._pass.getImageIndex(texture, index);
	    };
	    ShaderBase.prototype._iIncludeDependencies = function () {
	        this._pass._iIncludeDependencies(this);
	    };
	    /**
	     * Factory method to create a concrete compiler object for this object
	     *
	     * @param elementsClass
	     * @param pass
	     * @param stage
	     * @returns {CompilerBase}
	     */
	    ShaderBase.prototype.createCompiler = function (elementsClass, pass) {
	        return new CompilerBase_1.default(elementsClass, pass, this);
	    };
	    /**
	     * Clears dependency counts for all registers. Called when recompiling a pass.
	     */
	    ShaderBase.prototype.reset = function () {
	        this.projectionDependencies = 0;
	        this.normalDependencies = 0;
	        this.colorDependencies = 0;
	        this.viewDirDependencies = 0;
	        this.uvDependencies = 0;
	        this.secondaryUVDependencies = 0;
	        this.globalPosDependencies = 0;
	        this.tangentDependencies = 0;
	        this.usesCommonData = false;
	        this.usesGlobalPosFragment = false;
	        this.usesPositionFragment = false;
	        this.usesFragmentAnimation = false;
	        this.usesTangentSpace = false;
	        this.outputsNormals = false;
	        this.outputsTangentNormals = false;
	    };
	    ShaderBase.prototype.pInitRegisterIndices = function () {
	        this.commonsDataIndex = -1;
	        this.cameraPositionIndex = -1;
	        this.curvesIndex = -1;
	        this.uvIndex = -1;
	        this.uvMatrixIndex = -1;
	        this.colorTransformIndex = -1;
	        this.secondaryUVIndex = -1;
	        this.normalIndex = -1;
	        this.colorBufferIndex = -1;
	        this.tangentIndex = -1;
	        this.sceneMatrixIndex = -1;
	        this.sceneNormalMatrixIndex = -1;
	        this.jointIndexIndex = -1;
	        this.jointWeightIndex = -1;
	        this.imageIndices.length = 0;
	    };
	    /**
	     * Initializes the unchanging constant data for this shader object.
	     */
	    ShaderBase.prototype.initConstantData = function (registerCache, animatableAttributes, animationTargetRegisters, uvSource, uvTarget) {
	        //Updates the amount of used register indices.
	        this.numUsedVertexConstants = registerCache.numUsedVertexConstants;
	        this.numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
	        this.numUsedStreams = registerCache.numUsedStreams;
	        this.numUsedTextures = registerCache.numUsedTextures;
	        this.numUsedVaryings = registerCache.numUsedVaryings;
	        this.numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
	        this.animatableAttributes = animatableAttributes;
	        this.animationTargetRegisters = animationTargetRegisters;
	        this.uvSource = uvSource;
	        this.uvTarget = uvTarget;
	        this.vertexConstantData = new Float32Array(this.numUsedVertexConstants * 4);
	        this.fragmentConstantData = new Float32Array(this.numUsedFragmentConstants * 4);
	        //Initializes commonly required constant values.
	        if (this.commonsDataIndex >= 0) {
	            this.fragmentConstantData[this.commonsDataIndex] = .5;
	            this.fragmentConstantData[this.commonsDataIndex + 1] = 0;
	            this.fragmentConstantData[this.commonsDataIndex + 2] = 1 / 255;
	            this.fragmentConstantData[this.commonsDataIndex + 3] = 1;
	        }
	        //Initializes the default UV transformation matrix.
	        if (this.uvMatrixIndex >= 0) {
	            this.vertexConstantData[this.uvMatrixIndex] = 1;
	            this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 2] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
	            this.vertexConstantData[this.uvMatrixIndex + 6] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
	        }
	        //Initializes the default colorTransform.
	        if (this.colorTransformIndex >= 0) {
	            this.fragmentConstantData[this.colorTransformIndex] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
	        }
	        if (this.cameraPositionIndex >= 0)
	            this.vertexConstantData[this.cameraPositionIndex + 3] = 1;
	    };
	    /**
	     * The blend mode to use when drawing this renderable. The following blend modes are supported:
	     * <ul>
	     * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	     * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	     * <li>BlendMode.MULTIPLY</li>
	     * <li>BlendMode.ADD</li>
	     * <li>BlendMode.ALPHA</li>
	     * </ul>
	     */
	    ShaderBase.prototype.setBlendMode = function (value) {
	        switch (value) {
	            case BlendMode_1.default.NORMAL:
	                this._blendFactorSource = ContextGLBlendFactor_1.default.ONE;
	                this._blendFactorDest = ContextGLBlendFactor_1.default.ZERO;
	                this.usesBlending = false;
	                break;
	            case BlendMode_1.default.LAYER:
	                this._blendFactorSource = ContextGLBlendFactor_1.default.SOURCE_ALPHA;
	                this._blendFactorDest = ContextGLBlendFactor_1.default.ONE_MINUS_SOURCE_ALPHA;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.default.MULTIPLY:
	                this._blendFactorSource = ContextGLBlendFactor_1.default.ZERO;
	                this._blendFactorDest = ContextGLBlendFactor_1.default.SOURCE_COLOR;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.default.ADD:
	                this._blendFactorSource = ContextGLBlendFactor_1.default.SOURCE_ALPHA;
	                this._blendFactorDest = ContextGLBlendFactor_1.default.ONE;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.default.ALPHA:
	                this._blendFactorSource = ContextGLBlendFactor_1.default.ZERO;
	                this._blendFactorDest = ContextGLBlendFactor_1.default.SOURCE_ALPHA;
	                this.usesBlending = true;
	                break;
	            default:
	                throw new ArgumentError_1.default("Unsupported blend mode!");
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShaderBase.prototype._iActivate = function (camera) {
	        if (this.usesAnimation)
	            this._pass.animationSet.activate(this, this._stage);
	        this._stage.context.setCulling(this.useBothSides ? ContextGLTriangleFace_1.default.NONE : this._defaultCulling, camera.projection.coordinateSystem);
	        if (!this.usesTangentSpace && this.cameraPositionIndex >= 0) {
	            var pos = camera.scenePosition;
	            this.vertexConstantData[this.cameraPositionIndex] = pos.x;
	            this.vertexConstantData[this.cameraPositionIndex + 1] = pos.y;
	            this.vertexConstantData[this.cameraPositionIndex + 2] = pos.z;
	        }
	        this._stage.context.setDepthTest((this.writeDepth && !this.usesBlending), this.depthCompareMode);
	        if (this.usesBlending)
	            this._stage.context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShaderBase.prototype._iDeactivate = function () {
	        if (this.usesAnimation)
	            this._pass.animationSet.deactivate(this, this._stage);
	        //For the love of god don't remove this if you want your multi-material shadows to not flicker like shit
	        this._stage.context.setDepthTest(true, ContextGLCompareMode_1.default.LESS_EQUAL);
	    };
	    /**
	     *
	     *
	     * @param renderable
	     * @param stage
	     * @param camera
	     */
	    ShaderBase.prototype._iRender = function (renderable, camera, viewProjection) {
	        if (renderable.renderable.animator)
	            renderable.renderable.animator.setRenderState(this, renderable, this._stage, camera, this.numUsedVertexConstants, this.numUsedStreams);
	        if (this.usesUVTransform) {
	            var uvMatrix = renderable.uvMatrix;
	            if (uvMatrix) {
	                this.vertexConstantData[this.uvMatrixIndex] = uvMatrix.a;
	                this.vertexConstantData[this.uvMatrixIndex + 1] = uvMatrix.b;
	                this.vertexConstantData[this.uvMatrixIndex + 3] = uvMatrix.tx;
	                this.vertexConstantData[this.uvMatrixIndex + 4] = uvMatrix.c;
	                this.vertexConstantData[this.uvMatrixIndex + 5] = uvMatrix.d;
	                this.vertexConstantData[this.uvMatrixIndex + 7] = uvMatrix.ty;
	            }
	            else {
	                this.vertexConstantData[this.uvMatrixIndex] = 1;
	                this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
	                this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
	            }
	        }
	        if (this.usesColorTransform) {
	            var colorTransform = renderable.sourceEntity._iAssignedColorTransform();
	            if (colorTransform) {
	                this.fragmentConstantData[this.colorTransformIndex] = colorTransform.redMultiplier;
	                this.fragmentConstantData[this.colorTransformIndex + 1] = colorTransform.greenMultiplier;
	                this.fragmentConstantData[this.colorTransformIndex + 2] = colorTransform.blueMultiplier;
	                this.fragmentConstantData[this.colorTransformIndex + 3] = colorTransform.alphaMultiplier;
	                this.fragmentConstantData[this.colorTransformIndex + 4] = colorTransform.redOffset / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 5] = colorTransform.greenOffset / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 6] = colorTransform.blueOffset / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 7] = colorTransform.alphaOffset / 255;
	            }
	            else {
	                this.fragmentConstantData[this.colorTransformIndex] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
	            }
	        }
	        if (this.sceneNormalMatrixIndex >= 0)
	            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this.vertexConstantData, this.sceneNormalMatrixIndex, false);
	        if (this.usesTangentSpace && this.cameraPositionIndex >= 0) {
	            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._pInverseSceneMatrix);
	            var pos = camera.scenePosition;
	            var x = pos.x;
	            var y = pos.y;
	            var z = pos.z;
	            this.vertexConstantData[this.cameraPositionIndex] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
	            this.vertexConstantData[this.cameraPositionIndex + 1] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
	            this.vertexConstantData[this.cameraPositionIndex + 2] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
	        }
	    };
	    ShaderBase.prototype.invalidateProgram = function () {
	        this._invalidProgram = true;
	    };
	    ShaderBase.prototype.invalidateShader = function () {
	        this._invalidShader = true;
	        this._invalidProgram = true;
	    };
	    ShaderBase.prototype.dispose = function () {
	        this._programData.dispose();
	        this._programData = null;
	    };
	    ShaderBase.prototype._updateProgram = function () {
	        this._invalidProgram = false;
	        var compiler;
	        if (this._invalidShader) {
	            this._invalidShader = false;
	            compiler = this.createCompiler(this._elementsClass, this._pass);
	            compiler.compile();
	        }
	        this._calcAnimationCode(compiler.shadedTarget);
	        var programData = this._stage.getProgramData(this._animationVertexCode + compiler.vertexCode, compiler.fragmentCode + this._animationFragmentCode + compiler.postAnimationFragmentCode);
	        //check program data hasn't changed, keep count of program usages
	        if (this._programData != programData) {
	            if (this._programData)
	                this._programData.dispose();
	            this._programData = programData;
	            programData.usages++;
	        }
	    };
	    ShaderBase.prototype._calcAnimationCode = function (shadedTarget) {
	        //reset code
	        this._animationVertexCode = "";
	        this._animationFragmentCode = "";
	        //check to see if GPU animation is used
	        if (this.usesAnimation) {
	            var animationSet = this._pass.animationSet;
	            this._animationVertexCode += animationSet.getAGALVertexCode(this);
	            if (this.uvDependencies > 0 && !this.usesUVTransform)
	                this._animationVertexCode += animationSet.getAGALUVCode(this);
	            if (this.usesFragmentAnimation)
	                this._animationFragmentCode += animationSet.getAGALFragmentCode(this, shadedTarget);
	            animationSet.doneAGALCode(this);
	        }
	        else {
	            // simply write attributes to targets, do not animate them
	            // projection will pick up on targets[0] to do the projection
	            var len = this.animatableAttributes.length;
	            for (var i = 0; i < len; ++i)
	                this._animationVertexCode += "mov " + this.animationTargetRegisters[i] + ", " + this.animatableAttributes[i] + "\n";
	            if (this.uvDependencies > 0 && !this.usesUVTransform)
	                this._animationVertexCode += "mov " + this.uvTarget + "," + this.uvSource + "\n";
	        }
	    };
	    ShaderBase._abstractionClassPool = new Object();
	    return ShaderBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShaderBase;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderRegisterCache_1 = __webpack_require__(173);
	var ShaderRegisterData_1 = __webpack_require__(176);
	/**
	 * CompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
	 * material. Concrete subclasses are used by the default materials.
	 *
	 * @see away.materials.ShadingMethodBase
	 */
	var CompilerBase = (function () {
	    /**
	     * Creates a new CompilerBase object.
	     * @param profile The compatibility profile of the renderer.
	     */
	    function CompilerBase(elementsClass, pass, shader) {
	        this._pVertexCode = ''; // Changed to emtpy string- AwayTS
	        this._pFragmentCode = ''; // Changed to emtpy string - AwayTS
	        this._pPostAnimationFragmentCode = ''; // Changed to emtpy string - AwayTS
	        //The attributes that need to be animated by animators.
	        this._pAnimatableAttributes = new Array();
	        //The target registers for animated properties, written to by the animators.
	        this._pAnimationTargetRegisters = new Array();
	        this._pElementsClass = elementsClass;
	        this._pRenderPass = pass;
	        this._pShader = shader;
	        this._pSharedRegisters = new ShaderRegisterData_1.default();
	        this._pRegisterCache = new ShaderRegisterCache_1.default(shader.profile);
	        this._pRegisterCache.vertexAttributesOffset = elementsClass.vertexAttributesOffset;
	        this._pRegisterCache.reset();
	    }
	    /**
	     * Compiles the code after all setup on the compiler has finished.
	     */
	    CompilerBase.prototype.compile = function () {
	        this._pShader.reset();
	        this._pShader._iIncludeDependencies();
	        this.pInitRegisterIndices();
	        this.pCompileDependencies();
	        //compile custom vertex & fragment codes
	        this._pVertexCode += this._pRenderPass._iGetVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pPostAnimationFragmentCode += this._pRenderPass._iGetFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        if (this._pShader.usesColorTransform)
	            this.compileColorTransformCode();
	        else
	            this._pShader.colorTransformIndex = -1;
	        //assign the final output color to the output register
	        this._pPostAnimationFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister + ", " + this._pSharedRegisters.shadedTarget + "\n";
	        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
	        //initialise the required shader constants
	        this._pShader.initConstantData(this._pRegisterCache, this._pAnimatableAttributes, this._pAnimationTargetRegisters, this._uvSource, this._uvTarget);
	        this._pRenderPass._iInitConstantData(this._pShader);
	    };
	    /**
	     * Calculate the transformed colours
	     */
	    CompilerBase.prototype.compileColorTransformCode = function () {
	        // rm, gm, bm, am - multiplier
	        // ro, go, bo, ao - offset
	        var ct1 = this._pRegisterCache.getFreeFragmentConstant();
	        var ct2 = this._pRegisterCache.getFreeFragmentConstant();
	        this._pShader.colorTransformIndex = ct1.index * 4;
	        this._pPostAnimationFragmentCode += "mul " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ", " + ct1 + "\n";
	        this._pPostAnimationFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ", " + ct2 + "\n";
	    };
	    /**
	     * Compile the code for the methods.
	     */
	    CompilerBase.prototype.pCompileDependencies = function () {
	        this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);
	        //compile the world-space position if required
	        if (this._pShader.globalPosDependencies > 0)
	            this.compileGlobalPositionCode();
	        //compile the local-space position if required
	        if (this._pShader.usesPositionFragment)
	            this.compilePositionCode();
	        if (this._pShader.usesCurves)
	            this.compileCurvesCode();
	        //Calculate the (possibly animated) UV coordinates.
	        if (this._pShader.uvDependencies > 0)
	            this.compileUVCode();
	        if (this._pShader.secondaryUVDependencies > 0)
	            this.compileSecondaryUVCode();
	        if (this._pShader.normalDependencies > 0)
	            this.compileNormalCode();
	        if (this._pShader.viewDirDependencies > 0)
	            this.compileViewDirCode();
	        //collect code from material
	        this._pVertexCode += this._pElementsClass._iGetVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pFragmentCode += this._pElementsClass._iGetFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        //collect code from pass
	        this._pVertexCode += this._pRenderPass._iGetPreLightingVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pFragmentCode += this._pRenderPass._iGetPreLightingFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	    };
	    CompilerBase.prototype.compileGlobalPositionCode = function () {
	        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp(), this._pShader.globalPosDependencies);
	        var sceneMatrixReg = this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pShader.sceneMatrixIndex = sceneMatrixReg.index * 4;
	        this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex + ", " + this._pSharedRegisters.animatedPosition + ", " + sceneMatrixReg + "\n";
	        if (this._pShader.usesGlobalPosFragment) {
	            this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
	            this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
	        }
	    };
	    CompilerBase.prototype.compilePositionCode = function () {
	        this._pSharedRegisters.positionVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.positionVarying + ", " + this._pSharedRegisters.animatedPosition + "\n";
	    };
	    CompilerBase.prototype.compileCurvesCode = function () {
	        this._pSharedRegisters.curvesInput = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.curvesIndex = this._pSharedRegisters.curvesInput.index;
	        this._pSharedRegisters.curvesVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.curvesVarying + ", " + this._pSharedRegisters.curvesInput + "\n";
	        var temp = this._pRegisterCache.getFreeFragmentSingleTemp();
	        this._pFragmentCode += "mul " + temp + ", " + this._pSharedRegisters.curvesVarying + ".y, " + this._pSharedRegisters.curvesVarying + ".y\n" +
	            "sub " + temp + ", " + temp + ", " + this._pSharedRegisters.curvesVarying + ".z\n" +
	            "mul " + temp + ", " + temp + ", " + this._pSharedRegisters.curvesVarying + ".x\n" +
	            "kil " + temp + "\n";
	    };
	    /**
	     * Calculate the (possibly animated) UV coordinates.
	     */
	    CompilerBase.prototype.compileUVCode = function () {
	        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.uvIndex = uvAttributeReg.index;
	        var varying = this._pSharedRegisters.uvVarying = this._pRegisterCache.getFreeVarying();
	        if (this._pShader.usesUVTransform) {
	            // a, b, 0, tx
	            // c, d, 0, ty
	            var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
	            var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
	            this._pShader.uvMatrixIndex = uvTransform1.index * 4;
	            this._pVertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" +
	                "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" +
	                "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
	        }
	        else {
	            this._pShader.uvMatrixIndex = -1;
	            this._uvTarget = varying.toString();
	            this._uvSource = uvAttributeReg.toString();
	        }
	    };
	    /**
	     * Provide the secondary UV coordinates.
	     */
	    CompilerBase.prototype.compileSecondaryUVCode = function () {
	        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.secondaryUVIndex = uvAttributeReg.index;
	        this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
	    };
	    /**
	     * Calculate the view direction.
	     */
	    CompilerBase.prototype.compileViewDirCode = function () {
	        var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
	        this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
	        this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pShader.viewDirDependencies);
	        this._pShader.cameraPositionIndex = cameraPositionReg.index * 4;
	        if (this._pShader.usesTangentSpace) {
	            var temp = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.animatedPosition + "\n" +
	                "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.animatedPosition + ".w\n";
	        }
	        else {
	            this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
	            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
	        }
	        //TODO is this required in all cases? (re: distancemappass)
	        this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" +
	            "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w\n";
	    };
	    /**
	     * Calculate the normal.
	     */
	    CompilerBase.prototype.compileNormalCode = function () {
	        this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pShader.normalDependencies);
	        //simple normal aquisition if no tangent space is being used
	        if (this._pShader.outputsNormals && !this._pShader.outputsTangentNormals) {
	            this._pVertexCode += this._pRenderPass._iGetNormalVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            return;
	        }
	        var normalMatrix;
	        if (!this._pShader.outputsNormals || !this._pShader.usesTangentSpace) {
	            normalMatrix = new Array(3);
	            normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
	            normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
	            normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();
	            this._pRegisterCache.getFreeVertexConstant();
	            this._pShader.sceneNormalMatrixIndex = normalMatrix[0].index * 4;
	            this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();
	        }
	        if (this._pShader.outputsNormals) {
	            if (this._pShader.usesTangentSpace) {
	                // normalize normal + tangent vector and generate (approximated) bitangent used in m33 operation for view
	                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";
	                this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            }
	            else {
	                //Compiles the vertex shader code for tangent-space normal maps.
	                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
	                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();
	                var temp = this._pRegisterCache.getFreeVertexVectorTemp();
	                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + temp + "\n" +
	                    "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + temp + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".x  \n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".x  \n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".y  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".y  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".z  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".z  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "crs " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".y, " + temp + ".z    \n";
	                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
	                //Compiles the fragment shader code for tangent-space normal maps.
	                var t;
	                var b;
	                var n;
	                t = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(t, 1);
	                b = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(b, 1);
	                n = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(n, 1);
	                this._pFragmentCode += "nrm " + t + ".xyz, " + this._pSharedRegisters.tangentVarying + "\n" +
	                    "mov " + t + ".w, " + this._pSharedRegisters.tangentVarying + ".w	\n" +
	                    "nrm " + b + ".xyz, " + this._pSharedRegisters.bitangentVarying + "\n" +
	                    "nrm " + n + ".xyz, " + this._pSharedRegisters.normalVarying + "\n";
	                //compile custom fragment code for normal calcs
	                this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters) +
	                    "m33 " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalFragment + ", " + t + "\n" +
	                    "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
	                this._pRegisterCache.removeFragmentTempUsage(b);
	                this._pRegisterCache.removeFragmentTempUsage(t);
	                this._pRegisterCache.removeFragmentTempUsage(n);
	            }
	        }
	        else {
	            // no output, world space is enough
	            this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
	                "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w\n";
	            this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" +
	                "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
	            if (this._pShader.tangentDependencies > 0) {
	                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
	                this._pVertexCode += "m33 " + this._pSharedRegisters.tangentVarying + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.animatedTangent + ".w\n";
	            }
	        }
	        if (!this._pShader.usesTangentSpace)
	            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
	    };
	    /**
	     * Reset all the indices to "unused".
	     */
	    CompilerBase.prototype.pInitRegisterIndices = function () {
	        this._pShader.pInitRegisterIndices();
	        this._pSharedRegisters.animatedPosition = this._pRegisterCache.getFreeVertexVectorTemp();
	        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedPosition, 1);
	        this._pAnimatableAttributes.push("va0");
	        this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedPosition.toString());
	        this._pVertexCode = "";
	        this._pFragmentCode = "";
	        this._pPostAnimationFragmentCode = "";
	        //create commonly shared constant registers
	        if (this._pShader.usesCommonData || this._pShader.normalDependencies > 0) {
	            this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
	            this._pShader.commonsDataIndex = this._pSharedRegisters.commons.index * 4;
	        }
	        //Creates the registers to contain the tangent data.
	        //Needs to be created FIRST and in this order (for when using tangent space)
	        if (this._pShader.tangentDependencies > 0 || this._pShader.outputsNormals) {
	            this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.tangentIndex = this._pSharedRegisters.tangentInput.index;
	            this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
	            if (this._pShader.usesTangentSpace) {
	                this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
	                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);
	            }
	            this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
	            this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
	        }
	        if (this._pShader.normalDependencies > 0) {
	            this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.normalIndex = this._pSharedRegisters.normalInput.index;
	            this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
	            this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
	            this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
	        }
	        if (this._pShader.colorDependencies > 0) {
	            this._pSharedRegisters.colorInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.colorBufferIndex = this._pSharedRegisters.colorInput.index;
	            this._pSharedRegisters.colorVarying = this._pRegisterCache.getFreeVarying();
	            this._pVertexCode += "mov " + this._pSharedRegisters.colorVarying + ", " + this._pSharedRegisters.colorInput + "\n";
	        }
	    };
	    /**
	     * Disposes all resources used by the compiler.
	     */
	    CompilerBase.prototype.dispose = function () {
	        this._pRegisterCache.dispose();
	        this._pRegisterCache = null;
	        this._pSharedRegisters = null;
	    };
	    Object.defineProperty(CompilerBase.prototype, "vertexCode", {
	        /**
	         * The generated vertex code.
	         */
	        get: function () {
	            return this._pVertexCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "fragmentCode", {
	        /**
	         * The generated fragment code.
	         */
	        get: function () {
	            return this._pFragmentCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "postAnimationFragmentCode", {
	        /**
	         * The generated fragment code.
	         */
	        get: function () {
	            return this._pPostAnimationFragmentCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "shadedTarget", {
	        /**
	         * The register name containing the final shaded colour.
	         */
	        get: function () {
	            return this._pSharedRegisters.shadedTarget.toString();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CompilerBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CompilerBase;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RegisterPool_1 = __webpack_require__(174);
	var ShaderRegisterElement_1 = __webpack_require__(175);
	/**
	 * ShaderRegister Cache provides the usage management system for all registers during shading compilers.
	 */
	var ShaderRegisterCache = (function () {
	    /**
	     * Create a new ShaderRegisterCache object.
	     *
	     * @param profile The compatibility profile used by the renderer.
	     */
	    function ShaderRegisterCache(profile) {
	        this._numUsedVertexConstants = 0;
	        this._numUsedFragmentConstants = 0;
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._numUsedVaryings = 0;
	        this._profile = profile;
	    }
	    /**
	     * Resets all registers.
	     */
	    ShaderRegisterCache.prototype.reset = function () {
	        this._fragmentTempCache = new RegisterPool_1.default("ft", 8, false);
	        this._vertexTempCache = new RegisterPool_1.default("vt", 8, false);
	        this._varyingCache = new RegisterPool_1.default("v", 8);
	        this._textureCache = new RegisterPool_1.default("fs", 8);
	        this._vertexAttributesCache = new RegisterPool_1.default("va", 8);
	        this._fragmentConstantsCache = new RegisterPool_1.default("fc", 28);
	        this._vertexConstantsCache = new RegisterPool_1.default("vc", 128);
	        this._fragmentOutputRegister = new ShaderRegisterElement_1.default("oc", -1);
	        this._vertexOutputRegister = new ShaderRegisterElement_1.default("op", -1);
	        this._numUsedVertexConstants = 0;
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._numUsedVaryings = 0;
	        this._numUsedFragmentConstants = 0;
	        var i;
	        for (i = 0; i < this._vertexAttributesOffset; ++i)
	            this.getFreeVertexAttribute();
	        for (i = 0; i < this._vertexConstantOffset; ++i)
	            this.getFreeVertexConstant();
	        for (i = 0; i < this._varyingsOffset; ++i)
	            this.getFreeVarying();
	        for (i = 0; i < this._fragmentConstantOffset; ++i)
	            this.getFreeFragmentConstant();
	    };
	    /**
	     * Disposes all resources used.
	     */
	    ShaderRegisterCache.prototype.dispose = function () {
	        this._fragmentTempCache.dispose();
	        this._vertexTempCache.dispose();
	        this._varyingCache.dispose();
	        this._fragmentConstantsCache.dispose();
	        this._vertexAttributesCache.dispose();
	        this._fragmentTempCache = null;
	        this._vertexTempCache = null;
	        this._varyingCache = null;
	        this._fragmentConstantsCache = null;
	        this._vertexAttributesCache = null;
	        this._fragmentOutputRegister = null;
	        this._vertexOutputRegister = null;
	    };
	    /**
	     * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
	        this._fragmentTempCache.addUsage(register, usageCount);
	    };
	    /**
	     * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
	        this._fragmentTempCache.removeUsage(register);
	    };
	    /**
	     * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
	     * until removeUsage has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
	        this._vertexTempCache.addUsage(register, usageCount);
	    };
	    /**
	     * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
	        this._vertexTempCache.removeUsage(register);
	    };
	    /**
	     * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
	        return this._fragmentTempCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve a single component from a fragment temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
	        return this._fragmentTempCache.requestFreeRegComponent();
	    };
	    /**
	     * Retrieve an available varying register
	     */
	    ShaderRegisterCache.prototype.getFreeVarying = function () {
	        ++this._numUsedVaryings;
	        return this._varyingCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available fragment constant register
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
	        ++this._numUsedFragmentConstants;
	        return this._fragmentConstantsCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available vertex constant register
	     */
	    ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
	        ++this._numUsedVertexConstants;
	        return this._vertexConstantsCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an entire vertex temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
	        return this._vertexTempCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve a single component from a vertex temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
	        return this._vertexTempCache.requestFreeRegComponent();
	    };
	    /**
	     * Retrieve an available vertex attribute register
	     */
	    ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
	        ++this._numUsedStreams;
	        return this._vertexAttributesCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available texture register
	     */
	    ShaderRegisterCache.prototype.getFreeTextureReg = function () {
	        ++this._numUsedTextures;
	        return this._textureCache.requestFreeVectorReg();
	    };
	    Object.defineProperty(ShaderRegisterCache.prototype, "vertexConstantOffset", {
	        /**
	         * Indicates the start index from which to retrieve vertex constants.
	         */
	        get: function () {
	            return this._vertexConstantOffset;
	        },
	        set: function (vertexConstantOffset) {
	            this._vertexConstantOffset = vertexConstantOffset;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "vertexAttributesOffset", {
	        /**
	         * Indicates the start index from which to retrieve vertex attributes.
	         */
	        get: function () {
	            return this._vertexAttributesOffset;
	        },
	        set: function (value) {
	            this._vertexAttributesOffset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "varyingsOffset", {
	        /**
	         * Indicates the start index from which to retrieve varying registers.
	         */
	        get: function () {
	            return this._varyingsOffset;
	        },
	        set: function (value) {
	            this._varyingsOffset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentConstantOffset", {
	        /**
	         * Indicates the start index from which to retrieve fragment constants.
	         */
	        get: function () {
	            return this._fragmentConstantOffset;
	        },
	        set: function (value) {
	            this._fragmentConstantOffset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
	        /**
	         * The fragment output register.
	         */
	        get: function () {
	            return this._fragmentOutputRegister;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
	        /**
	         * The amount of used vertex constant registers.
	         */
	        get: function () {
	            return this._numUsedVertexConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
	        /**
	         * The amount of used fragment constant registers.
	         */
	        get: function () {
	            return this._numUsedFragmentConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
	        /**
	         * The amount of used vertex streams.
	         */
	        get: function () {
	            return this._numUsedStreams;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
	        /**
	         * The amount of used texture slots.
	         */
	        get: function () {
	            return this._numUsedTextures;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
	        /**
	         * The amount of used varying registers.
	         */
	        get: function () {
	            return this._numUsedVaryings;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ShaderRegisterCache;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShaderRegisterCache;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderRegisterElement_1 = __webpack_require__(175);
	/**
	 * RegisterPool is used by the shader compilers process to keep track of which registers of a certain type are
	 * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
	 * or single components (x, y, z, w) of a single register.
	 * It is used by ShaderRegisterCache to track usages of individual register types.
	 *
	 * @see away.materials.ShaderRegisterCache
	 */
	var RegisterPool = (function () {
	    /**
	     * Creates a new RegisterPool object.
	     * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
	     * @param regCount The amount of available registers of this type.
	     * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
	     */
	    function RegisterPool(regName, regCount, persistent) {
	        if (persistent === void 0) { persistent = true; }
	        this._regName = regName;
	        this._regCount = regCount;
	        this._persistent = persistent;
	        this.initRegisters(regName, regCount);
	    }
	    /**
	     * Retrieve an entire vector register that's still available.
	     */
	    RegisterPool.prototype.requestFreeVectorReg = function () {
	        for (var i = 0; i < this._regCount; ++i) {
	            if (!this.isRegisterUsed(i)) {
	                if (this._persistent)
	                    this._usedVectorCount[i]++;
	                return this._vectorRegisters[i];
	            }
	        }
	        throw new Error("Register overflow!");
	    };
	    /**
	     * Retrieve a single vector component that's still available.
	     */
	    RegisterPool.prototype.requestFreeRegComponent = function () {
	        for (var i = 0; i < this._regCount; ++i) {
	            if (this._usedVectorCount[i] > 0)
	                continue;
	            for (var j = 0; j < 4; ++j) {
	                if (this._usedSingleCount[j][i] == 0) {
	                    if (this._persistent)
	                        this._usedSingleCount[j][i]++;
	                    return this._registerComponents[j][i];
	                }
	            }
	        }
	        throw new Error("Register overflow!");
	    };
	    /**
	     * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    RegisterPool.prototype.addUsage = function (register, usageCount) {
	        if (register._component > -1)
	            this._usedSingleCount[register._component][register.index] += usageCount;
	        else
	            this._usedVectorCount[register.index] += usageCount;
	    };
	    /**
	     * Removes a usage from a register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    RegisterPool.prototype.removeUsage = function (register) {
	        if (register._component > -1) {
	            if (--this._usedSingleCount[register._component][register.index] < 0)
	                throw new Error("More usages removed than exist!");
	        }
	        else {
	            if (--this._usedVectorCount[register.index] < 0)
	                throw new Error("More usages removed than exist!");
	        }
	    };
	    /**
	     * Disposes any resources used by the current RegisterPool object.
	     */
	    RegisterPool.prototype.dispose = function () {
	        this._vectorRegisters = null;
	        this._registerComponents = null;
	        this._usedSingleCount = null;
	        this._usedVectorCount = null;
	    };
	    /**
	     * Indicates whether or not any registers are in use.
	     */
	    RegisterPool.prototype.hasRegisteredRegs = function () {
	        for (var i = 0; i < this._regCount; ++i)
	            if (this.isRegisterUsed(i))
	                return true;
	        return false;
	    };
	    /**
	     * Initializes all registers.
	     */
	    RegisterPool.prototype.initRegisters = function (regName, regCount) {
	        var hash = RegisterPool._initPool(regName, regCount);
	        this._vectorRegisters = RegisterPool._regPool[hash];
	        this._registerComponents = RegisterPool._regCompsPool[hash];
	        this._usedVectorCount = this._initArray(Array(regCount), 0);
	        this._usedSingleCount = new Array(4);
	        this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
	    };
	    RegisterPool._initPool = function (regName, regCount) {
	        var hash = regName + regCount;
	        if (RegisterPool._regPool[hash] != undefined)
	            return hash;
	        var vectorRegisters = new Array(regCount);
	        RegisterPool._regPool[hash] = vectorRegisters;
	        var registerComponents = [
	            [],
	            [],
	            [],
	            []
	        ];
	        RegisterPool._regCompsPool[hash] = registerComponents;
	        for (var i = 0; i < regCount; ++i) {
	            vectorRegisters[i] = new ShaderRegisterElement_1.default(regName, i);
	            for (var j = 0; j < 4; ++j)
	                registerComponents[j][i] = new ShaderRegisterElement_1.default(regName, i, j);
	        }
	        return hash;
	    };
	    /**
	     * Check if the temp register is either used for single or vector use
	     */
	    RegisterPool.prototype.isRegisterUsed = function (index) {
	        if (this._usedVectorCount[index] > 0)
	            return true;
	        for (var i = 0; i < 4; ++i)
	            if (this._usedSingleCount[i][index] > 0)
	                return true;
	        return false;
	    };
	    RegisterPool.prototype._initArray = function (a, val) {
	        var l = a.length;
	        for (var c = 0; c < l; c++)
	            a[c] = val;
	        return a;
	    };
	    RegisterPool._regPool = new Object();
	    RegisterPool._regCompsPool = new Object();
	    return RegisterPool;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RegisterPool;


/***/ },
/* 175 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A single register element (an entire register or a single register's component) used by the RegisterPool.
	 */
	var ShaderRegisterElement = (function () {
	    /**
	     * Creates a new ShaderRegisterElement object.
	     *
	     * @param regName The name of the register.
	     * @param index The index of the register.
	     * @param component The register's component, if not the entire register is represented.
	     */
	    function ShaderRegisterElement(regName, index, component) {
	        if (component === void 0) { component = -1; }
	        this._component = component;
	        this._regName = regName;
	        this._index = index;
	        this._toStr = this._regName;
	        if (this._index >= 0)
	            this._toStr += this._index;
	        if (component > -1)
	            this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
	    }
	    /**
	     * Converts the register or the components AGAL string representation.
	     */
	    ShaderRegisterElement.prototype.toString = function () {
	        return this._toStr;
	    };
	    Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
	        /**
	         * The register's name.
	         */
	        get: function () {
	            return this._regName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterElement.prototype, "index", {
	        /**
	         * The register's index.
	         */
	        get: function () {
	            return this._index;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
	    return ShaderRegisterElement;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShaderRegisterElement;


/***/ },
/* 176 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
	 */
	var ShaderRegisterData = (function () {
	    function ShaderRegisterData() {
	        this.textures = Array();
	    }
	    return ShaderRegisterData;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShaderRegisterData;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var RendererBase_1 = __webpack_require__(100);
	var GL_DistanceSurface_1 = __webpack_require__(178);
	/**
	 * The DistanceRenderer class renders 32-bit depth information encoded as RGBA
	 *
	 * @class away.render.DistanceRenderer
	 */
	var DistanceRenderer = (function (_super) {
	    __extends(DistanceRenderer, _super);
	    /**
	     * Creates a new DistanceRenderer object.
	     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
	     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
	     */
	    function DistanceRenderer(stage) {
	        if (stage === void 0) { stage = null; }
	        _super.call(this, stage, GL_DistanceSurface_1.default);
	        this._iBackgroundR = 1;
	        this._iBackgroundG = 1;
	        this._iBackgroundB = 1;
	    }
	    /**
	     *
	     */
	    DistanceRenderer.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase_1.default._iCollectionMark && node.isCastingShadow();
	        if (!enter) {
	            node._iCollectionMark = RendererBase_1.default._iCollectionMark;
	            return false;
	        }
	        return _super.prototype.enterNode.call(this, node);
	    };
	    return DistanceRenderer;
	}(RendererBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DistanceRenderer;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SurfacePassBase_1 = __webpack_require__(148);
	var ShaderBase_1 = __webpack_require__(171);
	/**
	 * DistanceRender is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
	 * This is used to render omnidirectional shadow maps.
	 */
	var DistanceRender = (function (_super) {
	    __extends(DistanceRender, _super);
	    /**
	     * Creates a new DistanceRender object.
	     *
	     * @param material The material to which this pass belongs.
	     */
	    function DistanceRender(surface, elementsClass, renderPool) {
	        _super.call(this, surface, elementsClass, renderPool);
	        this._shader = new ShaderBase_1.default(elementsClass, this, this._stage);
	        this._pAddPass(this);
	    }
	    DistanceRender.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._textureVO = this._surface.getTextureAt(0) ? this._shader.getAbstraction(this._surface.getTextureAt(0)) : null;
	    };
	    /**
	     * Initializes the unchanging constant data for this material.
	     */
	    DistanceRender.prototype._iInitConstantData = function (shader) {
	        _super.prototype._iInitConstantData.call(this, shader);
	        var index = this._fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index + 4] = 1.0 / 255.0;
	        data[index + 5] = 1.0 / 255.0;
	        data[index + 6] = 1.0 / 255.0;
	        data[index + 7] = 0.0;
	    };
	    DistanceRender.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        shader.projectionDependencies++;
	        shader.viewDirDependencies++;
	        if (shader.alphaThreshold > 0)
	            shader.uvDependencies++;
	        if (shader.viewDirDependencies > 0)
	            shader.globalPosDependencies++;
	    };
	    /**
	     * @inheritDoc
	     */
	    DistanceRender.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code;
	        var targetReg = sharedRegisters.shadedTarget;
	        var dataReg1 = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        this._fragmentConstantsIndex = dataReg1.index * 4;
	        var temp1 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp1, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // squared distance to view
	        code = "dp3 " + temp1 + ".z, " + sharedRegisters.viewDirVarying + ".xyz, " + sharedRegisters.viewDirVarying + ".xyz\n" +
	            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
	            "frc " + temp1 + ", " + temp1 + "\n" +
	            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
	        if (this._textureVO && shader.alphaThreshold > 0) {
	            var albedo = registerCache.getFreeFragmentVectorTemp();
	            code += this._textureVO._iGetFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            var cutOffReg = registerCache.getFreeFragmentConstant();
	            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
	                "kil " + albedo + ".w\n";
	        }
	        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DistanceRender.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        var f = camera.projection.far;
	        f = 1 / (2 * f * f);
	        // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
	        var index = this._fragmentConstantsIndex;
	        var data = this._shader.fragmentConstantData;
	        data[index] = 1.0 * f;
	        data[index + 1] = 255.0 * f;
	        data[index + 2] = 65025.0 * f;
	        data[index + 3] = 16581375.0 * f;
	        if (this._textureVO && this._shader.alphaThreshold > 0) {
	            this._textureVO.activate(this);
	            data[index + 8] = this._shader.alphaThreshold;
	        }
	    };
	    return DistanceRender;
	}(GL_SurfacePassBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DistanceRender;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ContextGLDrawMode_1 = __webpack_require__(122);
	var ContextGLBlendFactor_1 = __webpack_require__(112);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(119);
	var RTTEvent_1 = __webpack_require__(180);
	var RTTBufferManager_1 = __webpack_require__(181);
	/**
	 * @class away.render.Filter3DRenderer
	 */
	var Filter3DRenderer = (function () {
	    function Filter3DRenderer(stage) {
	        var _this = this;
	        this._filterSizesInvalid = true;
	        this._onRTTResizeDelegate = function (event) { return _this.onRTTResize(event); };
	        this._stage = stage;
	        this._rttManager = RTTBufferManager_1.default.getInstance(stage);
	        this._rttManager.addEventListener(RTTEvent_1.default.RESIZE, this._onRTTResizeDelegate);
	    }
	    Filter3DRenderer.prototype.onRTTResize = function (event) {
	        this._filterSizesInvalid = true;
	    };
	    Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
	        get: function () {
	            return this._requireDepthRender;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DRenderer.prototype.getMainInputTexture = function (stage) {
	        if (this._filterTasksInvalid)
	            this.updateFilterTasks(stage);
	        return this._mainInputTexture;
	    };
	    Object.defineProperty(Filter3DRenderer.prototype, "filters", {
	        get: function () {
	            return this._filters;
	        },
	        set: function (value) {
	            this._filters = value;
	            this._filterTasksInvalid = true;
	            this._requireDepthRender = false;
	            if (!this._filters)
	                return;
	            for (var i = 0; i < this._filters.length; ++i)
	                if (this._filters[i].requireDepthRender)
	                    this._requireDepthRender = true;
	            this._filterSizesInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DRenderer.prototype.updateFilterTasks = function (stage) {
	        var len;
	        if (this._filterSizesInvalid)
	            this.updateFilterSizes();
	        if (!this._filters) {
	            this._tasks = null;
	            return;
	        }
	        this._tasks = new Array();
	        len = this._filters.length - 1;
	        var filter;
	        for (var i = 0; i <= len; ++i) {
	            // make sure all internal tasks are linked together
	            filter = this._filters[i];
	            filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stage), stage);
	            this._tasks = this._tasks.concat(filter.tasks);
	        }
	        this._mainInputTexture = this._filters[0].getMainInputTexture(stage);
	    };
	    Filter3DRenderer.prototype.render = function (stage, camera, depthTexture) {
	        var len;
	        var i;
	        var task;
	        var context = stage.context;
	        var indexBuffer = this._rttManager.indexBuffer;
	        var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;
	        if (!this._filters)
	            return;
	        if (this._filterSizesInvalid)
	            this.updateFilterSizes();
	        if (this._filterTasksInvalid)
	            this.updateFilterTasks(stage);
	        len = this._filters.length;
	        for (i = 0; i < len; ++i)
	            this._filters[i].update(stage, camera);
	        len = this._tasks.length;
	        if (len > 1) {
	            context.setProgram(this._tasks[0].getProgram(stage));
	            context.setVertexBufferAt(0, vertexBuffer, 0, ContextGLVertexBufferFormat_1.default.FLOAT_2);
	            context.setVertexBufferAt(1, vertexBuffer, 8, ContextGLVertexBufferFormat_1.default.FLOAT_2);
	        }
	        for (i = 0; i < len; ++i) {
	            task = this._tasks[i];
	            stage.setRenderTarget(task.target);
	            context.setProgram(task.getProgram(stage));
	            stage.getAbstraction(task.getMainInputTexture(stage)).activate(0, false);
	            if (!task.target) {
	                stage.scissorRect = null;
	                vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
	                context.setVertexBufferAt(0, vertexBuffer, 0, ContextGLVertexBufferFormat_1.default.FLOAT_2);
	                context.setVertexBufferAt(1, vertexBuffer, 8, ContextGLVertexBufferFormat_1.default.FLOAT_2);
	            }
	            context.clear(0.0, 0.0, 0.0, 0.0);
	            task.activate(stage, camera, depthTexture);
	            context.setBlendFactors(ContextGLBlendFactor_1.default.ONE, ContextGLBlendFactor_1.default.ZERO);
	            context.drawIndices(ContextGLDrawMode_1.default.TRIANGLES, indexBuffer, 0, 6);
	            task.deactivate(stage);
	        }
	        context.setTextureAt(0, null);
	        context.setVertexBufferAt(0, null);
	        context.setVertexBufferAt(1, null);
	    };
	    Filter3DRenderer.prototype.updateFilterSizes = function () {
	        for (var i = 0; i < this._filters.length; ++i) {
	            this._filters[i].textureWidth = this._rttManager.textureWidth;
	            this._filters[i].textureHeight = this._rttManager.textureHeight;
	            this._filters[i].rttManager = this._rttManager;
	        }
	        this._filterSizesInvalid = true;
	    };
	    Filter3DRenderer.prototype.dispose = function () {
	        this._rttManager.removeEventListener(RTTEvent_1.default.RESIZE, this._onRTTResizeDelegate);
	        this._rttManager = null;
	        this._stage = null;
	    };
	    return Filter3DRenderer;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Filter3DRenderer;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var RTTEvent = (function (_super) {
	    __extends(RTTEvent, _super);
	    function RTTEvent(type, rttManager) {
	        _super.call(this, type);
	        this._rttManager = rttManager;
	    }
	    Object.defineProperty(RTTEvent.prototype, "rttManager", {
	        /**
	         *
	         */
	        get: function () {
	            return this._rttManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    RTTEvent.prototype.clone = function () {
	        return new RTTEvent(this.type, this._rttManager);
	    };
	    /**
	     *
	     */
	    RTTEvent.RESIZE = "rttManagerResize";
	    return RTTEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RTTEvent;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Rectangle_1 = __webpack_require__(35);
	var EventDispatcher_1 = __webpack_require__(12);
	var ImageUtils_1 = __webpack_require__(92);
	var RTTEvent_1 = __webpack_require__(180);
	var RTTBufferManager = (function (_super) {
	    __extends(RTTBufferManager, _super);
	    function RTTBufferManager(stage) {
	        _super.call(this);
	        this._viewWidth = -1;
	        this._viewHeight = -1;
	        this._textureWidth = -1;
	        this._textureHeight = -1;
	        this._buffersInvalid = true;
	        this._renderToTextureRect = new Rectangle_1.default();
	        this._stage = stage;
	    }
	    RTTBufferManager.getInstance = function (stage) {
	        if (!stage)
	            throw new Error("stage key cannot be null!");
	        if (RTTBufferManager._instances == null)
	            RTTBufferManager._instances = new Array();
	        var rttBufferManager = RTTBufferManager.getRTTBufferManagerFromStage(stage);
	        if (rttBufferManager == null) {
	            rttBufferManager = new RTTBufferManager(stage);
	            var vo = new RTTBufferManagerVO();
	            vo.stage3d = stage;
	            vo.rttbfm = rttBufferManager;
	            RTTBufferManager._instances.push(vo);
	        }
	        return rttBufferManager;
	    };
	    RTTBufferManager.getRTTBufferManagerFromStage = function (stage) {
	        var l = RTTBufferManager._instances.length;
	        var r;
	        for (var c = 0; c < l; c++) {
	            r = RTTBufferManager._instances[c];
	            if (r.stage3d === stage)
	                return r.rttbfm;
	        }
	        return null;
	    };
	    RTTBufferManager.deleteRTTBufferManager = function (stage) {
	        var l = RTTBufferManager._instances.length;
	        var r;
	        for (var c = 0; c < l; c++) {
	            r = RTTBufferManager._instances[c];
	            if (r.stage3d === stage) {
	                RTTBufferManager._instances.splice(c, 1);
	                return;
	            }
	        }
	    };
	    Object.defineProperty(RTTBufferManager.prototype, "textureRatioX", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._textureRatioX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureRatioY", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._textureRatioY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "viewWidth", {
	        get: function () {
	            return this._viewWidth;
	        },
	        set: function (value) {
	            if (value == this._viewWidth)
	                return;
	            this._viewWidth = value;
	            this._buffersInvalid = true;
	            this._textureWidth = ImageUtils_1.default.getBestPowerOf2(this._viewWidth);
	            if (this._textureWidth > this._viewWidth) {
	                this._renderToTextureRect.x = Math.floor((this._textureWidth - this._viewWidth) * .5);
	                this._renderToTextureRect.width = this._viewWidth;
	            }
	            else {
	                this._renderToTextureRect.x = 0;
	                this._renderToTextureRect.width = this._textureWidth;
	            }
	            this.dispatchEvent(new RTTEvent_1.default(RTTEvent_1.default.RESIZE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "viewHeight", {
	        get: function () {
	            return this._viewHeight;
	        },
	        set: function (value) {
	            if (value == this._viewHeight)
	                return;
	            this._viewHeight = value;
	            this._buffersInvalid = true;
	            this._textureHeight = ImageUtils_1.default.getBestPowerOf2(this._viewHeight);
	            if (this._textureHeight > this._viewHeight) {
	                this._renderToTextureRect.y = Math.floor((this._textureHeight - this._viewHeight) * .5);
	                this._renderToTextureRect.height = this._viewHeight;
	            }
	            else {
	                this._renderToTextureRect.y = 0;
	                this._renderToTextureRect.height = this._textureHeight;
	            }
	            this.dispatchEvent(new RTTEvent_1.default(RTTEvent_1.default.RESIZE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureVertexBuffer", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToTextureVertexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToScreenVertexBuffer", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToScreenVertexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "indexBuffer", {
	        get: function () {
	            return this._indexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureRect", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToTextureRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureWidth", {
	        get: function () {
	            return this._textureWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureHeight", {
	        get: function () {
	            return this._textureHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RTTBufferManager.prototype.dispose = function () {
	        RTTBufferManager.deleteRTTBufferManager(this._stage);
	        if (this._indexBuffer) {
	            this._indexBuffer.dispose();
	            this._renderToScreenVertexBuffer.dispose();
	            this._renderToTextureVertexBuffer.dispose();
	            this._renderToScreenVertexBuffer = null;
	            this._renderToTextureVertexBuffer = null;
	            this._indexBuffer = null;
	        }
	    };
	    // todo: place all this in a separate model, since it's used all over the place
	    // maybe it even has a place in the core (together with screenRect etc)?
	    // needs to be stored per view of course
	    RTTBufferManager.prototype.updateRTTBuffers = function () {
	        var context = this._stage.context;
	        var textureVerts;
	        var screenVerts;
	        var x;
	        var y;
	        if (this._renderToTextureVertexBuffer == null)
	            this._renderToTextureVertexBuffer = context.createVertexBuffer(4, 20);
	        if (this._renderToScreenVertexBuffer == null)
	            this._renderToScreenVertexBuffer = context.createVertexBuffer(4, 20);
	        if (!this._indexBuffer) {
	            this._indexBuffer = context.createIndexBuffer(6);
	            this._indexBuffer.uploadFromArray([2, 1, 0, 3, 2, 0], 0, 6);
	        }
	        this._textureRatioX = x = Math.min(this._viewWidth / this._textureWidth, 1);
	        this._textureRatioY = y = Math.min(this._viewHeight / this._textureHeight, 1);
	        var u1 = (1 - x) * .5;
	        var u2 = (x + 1) * .5;
	        var v1 = (1 - y) * .5;
	        var v2 = (y + 1) * .5;
	        // last element contains indices for data per vertex that can be passed to the vertex shader if necessary (ie: frustum corners for deferred rendering)
	        textureVerts = [-x, -y, u1, v1, 0, x, -y, u2, v1, 1, x, y, u2, v2, 2, -x, y, u1, v2, 3];
	        screenVerts = [-1, -1, u1, v1, 0, 1, -1, u2, v1, 1, 1, 1, u2, v2, 2, -1, 1, u1, v2, 3];
	        this._renderToTextureVertexBuffer.uploadFromArray(textureVerts, 0, 4);
	        this._renderToScreenVertexBuffer.uploadFromArray(screenVerts, 0, 4);
	        this._buffersInvalid = false;
	    };
	    return RTTBufferManager;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RTTBufferManager;
	var RTTBufferManagerVO = (function () {
	    function RTTBufferManagerVO() {
	    }
	    return RTTBufferManagerVO;
	}());


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_TriangleElements_1 = __webpack_require__(183);
	/**
	 *
	 * @class away.pool.GL_SkyboxElements
	 */
	var GL_SkyboxElements = (function (_super) {
	    __extends(GL_SkyboxElements, _super);
	    function GL_SkyboxElements() {
	        _super.apply(this, arguments);
	    }
	    GL_SkyboxElements._iIncludeDependencies = function (shader) {
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_SkyboxElements._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "mul vt0, va0, vc5\n" +
	            "add vt0, vt0, vc4\n" +
	            "m44 op, vt0, vc0\n";
	    };
	    GL_SkyboxElements._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SkyboxElements.vertexAttributesOffset = 1;
	    return GL_SkyboxElements;
	}(GL_TriangleElements_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_SkyboxElements;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(27);
	var ContextGLDrawMode_1 = __webpack_require__(122);
	var ContextGLProgramType_1 = __webpack_require__(123);
	var GL_ElementsBase_1 = __webpack_require__(184);
	/**
	 *
	 * @class away.pool.GL_TriangleElements
	 */
	var GL_TriangleElements = (function (_super) {
	    __extends(GL_TriangleElements, _super);
	    function GL_TriangleElements(triangleElements, shader, pool) {
	        _super.call(this, triangleElements, shader, pool);
	        this._triangleElements = triangleElements;
	    }
	    GL_TriangleElements._iIncludeDependencies = function (shader) {
	    };
	    GL_TriangleElements._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        //get the projection coordinates
	        var position = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
	        //reserving vertex constants for projection matrix
	        var viewMatrixReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        shader.viewMatrixIndex = viewMatrixReg.index * 4;
	        if (shader.projectionDependencies > 0) {
	            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
	            var temp = registerCache.getFreeVertexVectorTemp();
	            code += "m44 " + temp + ", " + position + ", " + viewMatrixReg + "\n" +
	                "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" +
	                "mov op, " + temp + "\n";
	        }
	        else {
	            code += "m44 op, " + position + ", " + viewMatrixReg + "\n";
	        }
	        return code;
	    };
	    GL_TriangleElements._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_TriangleElements.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._triangleElements = null;
	    };
	    GL_TriangleElements.prototype._render = function (renderable, camera, viewProjection) {
	        //set buffers
	        //TODO: find a better way to update a concatenated buffer when autoderiving
	        if (this._shader.normalIndex >= 0 && this._triangleElements.autoDeriveNormals)
	            this._triangleElements.normals;
	        if (this._shader.tangentIndex >= 0 && this._triangleElements.autoDeriveTangents)
	            this._triangleElements.tangents;
	        if (this._shader.curvesIndex >= 0)
	            this.activateVertexBufferVO(this._shader.curvesIndex, this._triangleElements.getCustomAtributes("curves"));
	        if (this._shader.uvIndex >= 0)
	            this.activateVertexBufferVO(this._shader.uvIndex, this._triangleElements.uvs || this._triangleElements.positions);
	        if (this._shader.secondaryUVIndex >= 0)
	            this.activateVertexBufferVO(this._shader.secondaryUVIndex, this._triangleElements.getCustomAtributes("secondaryUVs") || this._triangleElements.uvs || this._triangleElements.positions);
	        if (this._shader.normalIndex >= 0)
	            this.activateVertexBufferVO(this._shader.normalIndex, this._triangleElements.normals);
	        if (this._shader.tangentIndex >= 0)
	            this.activateVertexBufferVO(this._shader.tangentIndex, this._triangleElements.tangents);
	        if (this._shader.jointIndexIndex >= 0)
	            this.activateVertexBufferVO(this._shader.jointIndexIndex, this._triangleElements.jointIndices);
	        if (this._shader.jointWeightIndex >= 0)
	            this.activateVertexBufferVO(this._shader.jointIndexIndex, this._triangleElements.jointWeights);
	        this.activateVertexBufferVO(0, this._triangleElements.positions);
	        //set constants
	        if (this._shader.sceneMatrixIndex >= 0) {
	            renderable.renderSceneTransform.copyRawDataTo(this._shader.vertexConstantData, this._shader.sceneMatrixIndex, true);
	            viewProjection.copyRawDataTo(this._shader.vertexConstantData, this._shader.viewMatrixIndex, true);
	        }
	        else {
	            var matrix3D = Matrix3DUtils_1.default.CALCULATION_MATRIX;
	            matrix3D.copyFrom(renderable.renderSceneTransform);
	            matrix3D.append(viewProjection);
	            matrix3D.copyRawDataTo(this._shader.vertexConstantData, this._shader.viewMatrixIndex, true);
	        }
	        var context = this._stage.context;
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, 0, this._shader.vertexConstantData, this._shader.numUsedVertexConstants);
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.default.FRAGMENT, 0, this._shader.fragmentConstantData, this._shader.numUsedFragmentConstants);
	        _super.prototype._render.call(this, renderable, camera, viewProjection);
	    };
	    GL_TriangleElements.prototype._drawElements = function (firstIndex, numIndices) {
	        this.getIndexBufferGL().draw(ContextGLDrawMode_1.default.TRIANGLES, firstIndex, numIndices);
	    };
	    GL_TriangleElements.prototype._drawArrays = function (firstVertex, numVertices) {
	        this._stage.context.drawVertices(ContextGLDrawMode_1.default.TRIANGLES, firstVertex, numVertices);
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.GL_GraphicRenderable}
	     * @protected
	     */
	    GL_TriangleElements.prototype._pGetOverflowElements = function () {
	        return new GL_TriangleElements(this._triangleElements, this._shader, this._pool);
	    };
	    GL_TriangleElements.vertexAttributesOffset = 1;
	    return GL_TriangleElements;
	}(GL_ElementsBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_TriangleElements;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(151);
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetEvent_1 = __webpack_require__(1);
	var ElementsEvent_1 = __webpack_require__(78);
	var ElementsUtils_1 = __webpack_require__(79);
	/**
	 *
	 * @class away.pool.GL_ElementsBaseBase
	 */
	var GL_ElementsBase = (function (_super) {
	    __extends(GL_ElementsBase, _super);
	    function GL_ElementsBase(elements, shader, pool) {
	        var _this = this;
	        _super.call(this, elements, pool);
	        this.usages = 0;
	        this._vertices = new Object();
	        this._verticesUpdated = new Object();
	        this._indexMappings = Array();
	        this._numIndices = 0;
	        this._elements = elements;
	        this._shader = shader;
	        this._stage = shader._stage;
	        this._onInvalidateIndicesDelegate = function (event) { return _this._onInvalidateIndices(event); };
	        this._onClearIndicesDelegate = function (event) { return _this._onClearIndices(event); };
	        this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
	        this._onClearVerticesDelegate = function (event) { return _this._onClearVertices(event); };
	        this._elements.addEventListener(ElementsEvent_1.default.CLEAR_INDICES, this._onClearIndicesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.default.INVALIDATE_INDICES, this._onInvalidateIndicesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.default.CLEAR_VERTICES, this._onClearVerticesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.default.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	    }
	    Object.defineProperty(GL_ElementsBase.prototype, "elements", {
	        get: function () {
	            return this._elements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_ElementsBase.prototype, "numIndices", {
	        /**
	         *
	         */
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getIndexMappings = function () {
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        return this._indexMappings;
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getIndexBufferGL = function () {
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        return this._indices;
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getVertexBufferGL = function (attributesView) {
	        //first check if indices need updating which may affect vertices
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        var bufferId = attributesView.buffer.id;
	        if (!this._verticesUpdated[bufferId])
	            this._updateVertices(attributesView);
	        return this._vertices[bufferId];
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.activateVertexBufferVO = function (index, attributesView, dimensions, offset) {
	        if (dimensions === void 0) { dimensions = 0; }
	        if (offset === void 0) { offset = 0; }
	        this.getVertexBufferGL(attributesView).activate(index, attributesView.size, dimensions || attributesView.dimensions, attributesView.offset + offset, attributesView.unsigned);
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._elements.removeEventListener(ElementsEvent_1.default.CLEAR_INDICES, this._onClearIndicesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.default.INVALIDATE_INDICES, this._onInvalidateIndicesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.default.CLEAR_VERTICES, this._onClearVerticesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.default.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        this._elements = null;
	        if (this._overflow) {
	            this._overflow.onClear(event);
	            this._overflow = null;
	        }
	    };
	    GL_ElementsBase.prototype._iRender = function (renderable, camera, viewProjection) {
	        if (!this._verticesUpdated)
	            this._updateIndices();
	        this._render(renderable, camera, viewProjection);
	        if (this._overflow)
	            this._overflow._iRender(renderable, camera, viewProjection);
	    };
	    GL_ElementsBase.prototype._render = function (renderable, camera, viewProjection) {
	        if (this._indices)
	            this._drawElements(0, this._numIndices);
	        else
	            this._drawArrays(0, this._numVertices);
	    };
	    GL_ElementsBase.prototype._drawElements = function (firstIndex, numIndices) {
	        throw new AbstractMethodError_1.default();
	    };
	    GL_ElementsBase.prototype._drawArrays = function (firstVertex, numVertices) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    GL_ElementsBase.prototype._updateIndices = function (indexOffset) {
	        if (indexOffset === void 0) { indexOffset = 0; }
	        var indices = this._elements.indices;
	        if (indices) {
	            this._indices = this._stage.getAbstraction(ElementsUtils_1.default.getSubIndices(indices, this._elements.numVertices, this._indexMappings, indexOffset));
	            this._numIndices = this._indices._attributesBuffer.count * indices.dimensions;
	        }
	        else {
	            this._indices = null;
	            this._numIndices = 0;
	            this._indexMappings = Array();
	        }
	        indexOffset += this._numIndices;
	        //check if there is more to split
	        if (indices && indexOffset < indices.count * this._elements.indices.dimensions) {
	            if (!this._overflow)
	                this._overflow = this._pGetOverflowElements();
	            this._overflow._updateIndices(indexOffset);
	        }
	        else if (this._overflow) {
	            this._overflow.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._elements));
	            this._overflow = null;
	        }
	        this._indicesUpdated = true;
	        //invalidate vertices if index mappings exist
	        if (this._indexMappings.length)
	            for (var key in this._verticesUpdated)
	                this._verticesUpdated[key] = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param attributesView
	     * @private
	     */
	    GL_ElementsBase.prototype._updateVertices = function (attributesView) {
	        this._numVertices = attributesView.count;
	        var bufferId = attributesView.buffer.id;
	        this._vertices[bufferId] = this._stage.getAbstraction(ElementsUtils_1.default.getSubVertices(attributesView.buffer, this._indexMappings));
	        this._verticesUpdated[bufferId] = true;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onInvalidateIndices = function (event) {
	        if (!event.attributesView)
	            return;
	        this._indicesUpdated = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onClearIndices = function (event) {
	        if (!event.attributesView)
	            return;
	        this._indices.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, event.attributesView));
	        this._indices = null;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onInvalidateVertices = function (event) {
	        if (!event.attributesView)
	            return;
	        var bufferId = event.attributesView.buffer.id;
	        this._verticesUpdated[bufferId] = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onClearVertices = function (event) {
	        if (!event.attributesView)
	            return;
	        var bufferId = event.attributesView.buffer.id;
	        if (this._vertices[bufferId]) {
	            this._vertices[bufferId].onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, event.attributesView));
	            delete this._vertices[bufferId];
	            delete this._verticesUpdated[bufferId];
	        }
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.GL_GraphicRenderable}
	     * @protected
	     */
	    GL_ElementsBase.prototype._pGetOverflowElements = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    return GL_ElementsBase;
	}(AbstractionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GL_ElementsBase;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(80);
	var Float3Attributes_1 = __webpack_require__(81);
	var Float2Attributes_1 = __webpack_require__(186);
	var Byte4Attributes_1 = __webpack_require__(84);
	var BitmapImageCube_1 = __webpack_require__(159);
	var BlendMode_1 = __webpack_require__(154);
	var Sampler2D_1 = __webpack_require__(157);
	var ColorTransform_1 = __webpack_require__(46);
	var Matrix3D_1 = __webpack_require__(28);
	var Vector3D_1 = __webpack_require__(30);
	var URLLoaderDataFormat_1 = __webpack_require__(9);
	var URLRequest_1 = __webpack_require__(25);
	var ParserBase_1 = __webpack_require__(187);
	var ParserUtils_1 = __webpack_require__(189);
	var PerspectiveProjection_1 = __webpack_require__(66);
	var OrthographicProjection_1 = __webpack_require__(26);
	var OrthographicOffCenterProjection_1 = __webpack_require__(191);
	var ByteArray_1 = __webpack_require__(107);
	var DisplayObjectContainer_1 = __webpack_require__(43);
	var Graphics_1 = __webpack_require__(74);
	var TriangleElements_1 = __webpack_require__(192);
	var DirectionalLight_1 = __webpack_require__(193);
	var PointLight_1 = __webpack_require__(199);
	var Camera_1 = __webpack_require__(64);
	var Sprite_1 = __webpack_require__(73);
	var Billboard_1 = __webpack_require__(201);
	var Skybox_1 = __webpack_require__(165);
	var DefaultMaterialManager_1 = __webpack_require__(156);
	var StaticLightPicker_1 = __webpack_require__(202);
	var CubeMapShadowMapper_1 = __webpack_require__(200);
	var DirectionalShadowMapper_1 = __webpack_require__(196);
	var PrefabBase_1 = __webpack_require__(206);
	var PrimitiveCapsulePrefab_1 = __webpack_require__(207);
	var PrimitiveConePrefab_1 = __webpack_require__(210);
	var PrimitiveCubePrefab_1 = __webpack_require__(212);
	var PrimitiveCylinderPrefab_1 = __webpack_require__(211);
	var PrimitivePlanePrefab_1 = __webpack_require__(213);
	var PrimitiveSpherePrefab_1 = __webpack_require__(214);
	var PrimitiveTorusPrefab_1 = __webpack_require__(215);
	var SingleCubeTexture_1 = __webpack_require__(166);
	var Single2DTexture_1 = __webpack_require__(169);
	var VertexAnimationSet_1 = __webpack_require__(216);
	var VertexAnimator_1 = __webpack_require__(220);
	var SkeletonAnimationSet_1 = __webpack_require__(223);
	var SkeletonAnimator_1 = __webpack_require__(224);
	var JointPose_1 = __webpack_require__(225);
	var Skeleton_1 = __webpack_require__(229);
	var SkeletonPose_1 = __webpack_require__(227);
	var SkeletonJoint_1 = __webpack_require__(230);
	var SkeletonClipNode_1 = __webpack_require__(231);
	var VertexClipNode_1 = __webpack_require__(237);
	var MethodMaterialMode_1 = __webpack_require__(239);
	var MethodMaterial_1 = __webpack_require__(240);
	var AmbientEnvMapMethod_1 = __webpack_require__(248);
	var DiffuseDepthMethod_1 = __webpack_require__(249);
	var DiffuseCelMethod_1 = __webpack_require__(250);
	var DiffuseGradientMethod_1 = __webpack_require__(252);
	var DiffuseLightMapMethod_1 = __webpack_require__(253);
	var DiffuseWrapMethod_1 = __webpack_require__(254);
	var EffectAlphaMaskMethod_1 = __webpack_require__(255);
	var EffectColorMatrixMethod_1 = __webpack_require__(257);
	var EffectColorTransformMethod_1 = __webpack_require__(258);
	var EffectEnvMapMethod_1 = __webpack_require__(259);
	var EffectFogMethod_1 = __webpack_require__(260);
	var EffectFresnelEnvMapMethod_1 = __webpack_require__(261);
	var EffectLightMapMethod_1 = __webpack_require__(262);
	var EffectRimLightMethod_1 = __webpack_require__(263);
	var NormalSimpleWaterMethod_1 = __webpack_require__(264);
	var ShadowDitheredMethod_1 = __webpack_require__(265);
	var ShadowFilteredMethod_1 = __webpack_require__(268);
	var SpecularFresnelMethod_1 = __webpack_require__(269);
	var ShadowHardMethod_1 = __webpack_require__(271);
	var SpecularAnisotropicMethod_1 = __webpack_require__(272);
	var SpecularCelMethod_1 = __webpack_require__(273);
	var SpecularPhongMethod_1 = __webpack_require__(274);
	var ShadowNearMethod_1 = __webpack_require__(275);
	var ShadowSoftMethod_1 = __webpack_require__(276);
	var BasicMaterial_1 = __webpack_require__(168);
	var AS2SceneGraphFactory_1 = __webpack_require__(278);
	var Timeline_1 = __webpack_require__(283);
	var AssetLibrary_1 = __webpack_require__(4);
	var Font_1 = __webpack_require__(287);
	var TextFormat_1 = __webpack_require__(290);
	var AWDBlock_1 = __webpack_require__(291);
	var Rectangle_1 = __webpack_require__(35);
	var Style_1 = __webpack_require__(155);
	var Matrix_1 = __webpack_require__(96);
	var MappingMode_1 = __webpack_require__(170);
	var ElementsType_1 = __webpack_require__(208);
	/**
	 * AWDParser provides a parser for the AWD data type.
	 */
	var AWDParser = (function (_super) {
	    __extends(AWDParser, _super);
	    /**
	     * Creates a new AWD3Parserutils object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function AWDParser(view) {
	        if (view === void 0) { view = null; }
	        _super.call(this, URLLoaderDataFormat_1.default.ARRAY_BUFFER);
	        //set to "true" to have some console.logs in the Console
	        this._debug = false;
	        this._debugTimers = true;
	        this._startedParsing = false;
	        this._texture_users = {};
	        this._parsed_header = false;
	        this._time_all = 0;
	        this._time_graphics = 0;
	        this._time_graphics_bytes = 0;
	        this._time_timeline = 0;
	        this._time_fonts = 0;
	        this._time_textfields = 0;
	        this._time_sounds = 0;
	        this._time_textures = 0;
	        this._time_materials = 0;
	        this._time_sprites = 0;
	        this._num_graphics = 0;
	        this._num_timeline = 0;
	        this._num_fonts = 0;
	        this._num_textfields = 0;
	        this._num_sounds = 0;
	        this._num_textures = 0;
	        this._num_materials = 0;
	        this._num_sprites = 0;
	        //--Parser UTILS---------------------------------------------------------------------------
	        this.shadowMethodListProperties = {
	            1: AWDParser.BADDR,
	            2: AWDParser.BADDR,
	            3: AWDParser.BADDR,
	            101: AWDParser.PROPERTY_NUMBER,
	            102: AWDParser.PROPERTY_NUMBER,
	            103: AWDParser.PROPERTY_NUMBER,
	            201: AWDParser.UINT32,
	            202: AWDParser.UINT32,
	            301: AWDParser.UINT16,
	            302: AWDParser.UINT16,
	            401: AWDParser.UINT8,
	            402: AWDParser.UINT8,
	            601: AWDParser.COLOR,
	            602: AWDParser.COLOR,
	            701: AWDParser.BOOL,
	            702: AWDParser.BOOL,
	            801: AWDParser.MTX4x4 };
	        this.spritePoseAnimationProperties = {
	            1: AWDParser.BOOL,
	            2: AWDParser.BOOL };
	        this.sharedMethodListProperties = {
	            1: AWDParser.BADDR,
	            2: AWDParser.BADDR,
	            3: AWDParser.BADDR,
	            101: AWDParser.PROPERTY_NUMBER,
	            102: AWDParser.PROPERTY_NUMBER,
	            103: AWDParser.PROPERTY_NUMBER,
	            104: AWDParser.PROPERTY_NUMBER,
	            105: AWDParser.PROPERTY_NUMBER,
	            106: AWDParser.PROPERTY_NUMBER,
	            107: AWDParser.PROPERTY_NUMBER,
	            201: AWDParser.UINT32,
	            202: AWDParser.UINT32,
	            301: AWDParser.UINT16,
	            302: AWDParser.UINT16,
	            401: AWDParser.UINT8,
	            402: AWDParser.UINT8,
	            601: AWDParser.COLOR,
	            602: AWDParser.COLOR,
	            701: AWDParser.BOOL,
	            702: AWDParser.BOOL };
	        this._view = view;
	        this._blocks = new Array();
	        this._blocks[0] = new AWDBlock_1.default(0, 255);
	        this._blocks[0].data = null; // Zero address means null in AWD
	        this.blendModeDic = new Array(); // used to translate ints to blendMode-strings
	        this.blendModeDic.push(BlendMode_1.default.NORMAL);
	        this.blendModeDic.push(BlendMode_1.default.ADD);
	        this.blendModeDic.push(BlendMode_1.default.ALPHA);
	        this.blendModeDic.push(BlendMode_1.default.DARKEN);
	        this.blendModeDic.push(BlendMode_1.default.DIFFERENCE);
	        this.blendModeDic.push(BlendMode_1.default.ERASE);
	        this.blendModeDic.push(BlendMode_1.default.HARDLIGHT);
	        this.blendModeDic.push(BlendMode_1.default.INVERT);
	        this.blendModeDic.push(BlendMode_1.default.LAYER);
	        this.blendModeDic.push(BlendMode_1.default.LIGHTEN);
	        this.blendModeDic.push(BlendMode_1.default.MULTIPLY);
	        this.blendModeDic.push(BlendMode_1.default.NORMAL);
	        this.blendModeDic.push(BlendMode_1.default.OVERLAY);
	        this.blendModeDic.push(BlendMode_1.default.SCREEN);
	        this.blendModeDic.push(BlendMode_1.default.SHADER);
	        this.blendModeDic.push(BlendMode_1.default.OVERLAY);
	        this._depthSizeDic = new Array(); // used to translate ints to depthSize-values
	        this._depthSizeDic.push(256);
	        this._depthSizeDic.push(512);
	        this._depthSizeDic.push(2048);
	        this._depthSizeDic.push(1024);
	        this._version = Array(); // will contain 2 int (major-version, minor-version) for awd-version-check
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    AWDParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "awd";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    AWDParser.supportsData = function (data) {
	        return (ParserUtils_1.default.toString(data, 3) == 'AWD');
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._iResolveDependency = function (resourceDependency) {
	        // this will be called when Dependency has finished loading.
	        // the ressource dependecniy has a id that point to the awd_block waiting for it.
	        //console.log("AWDParser resolve dependencies";
	        if (resourceDependency.assets.length == 1) {
	            var this_block = this._blocks[parseInt(resourceDependency.id)];
	            if (this_block.type == 82) {
	                var image_asset = resourceDependency.assets[0];
	                this_block.data = image_asset; // Store finished asset
	                // Finalize texture asset to dispatch texture event, which was
	                // previously suppressed while the dependency was loaded.
	                this._pFinalizeAsset(image_asset, this_block.name);
	                if (this._debug)
	                    console.log("Parsed Texture: Name = " + this_block.name);
	            }
	            else if (this_block.type == 44) {
	                var audio_asset = resourceDependency.assets[0];
	                this_block.data = audio_asset; // Store finished asset
	                // Finalize texture asset to dispatch texture event, which was
	                // previously suppressed while the dependency was loaded.
	                //console.log("Parsing audio " + this_block.name);
	                this._pFinalizeAsset(audio_asset, this_block.name);
	                if (this._debug)
	                    console.log("Parsed WaveAudio: Name = " + this_block.name);
	            }
	            else if (this_block.type == 83) {
	                this_block.loaded_dependencies[resourceDependency.sub_id] = resourceDependency.assets[0];
	                this_block.loaded_dependencies_cnt++;
	                if (this._debug)
	                    console.log("Successfully loaded Bitmap " + resourceDependency.sub_id + " / 6 for Cubetexture");
	                if (this_block.loaded_dependencies_cnt == 6) {
	                    var cube_image_asset = new BitmapImageCube_1.default(this_block.loaded_dependencies[0].width);
	                    for (var i = 0; i < 6; i++)
	                        cube_image_asset.draw(i, this_block.loaded_dependencies[i]);
	                    this_block.data = cube_image_asset; // Store finished asset
	                    this._pFinalizeAsset(cube_image_asset, this_block.name);
	                    if (this._debug)
	                        console.log("Parsed CubeTexture: Name = " + this_block.name);
	                }
	            }
	            if (this._debugTimers && !this._isParsing)
	                this.updateTimers(this_block.type);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
	        // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
	    };
	    /**
	     * Resolve a dependency name
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
	        var oldName = asset.name;
	        if (asset) {
	            var block = this._blocks[parseInt(resourceDependency.id)];
	            // Reset name of texture to the one defined in the AWD file,
	            // as opposed to whatever the image parser came up with.
	            asset.resetAssetPath(block.name, null, true);
	        }
	        var newName = asset.name;
	        asset.name = oldName;
	        return newName;
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._pProceedParsing = function () {
	        if (!this._startedParsing) {
	            this._byteData = this._pGetByteData(); //getByteData();
	            this._startedParsing = true;
	        }
	        if (!this._parsed_header) {
	            //----------------------------------------------------------------------------
	            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	            //----------------------------------------------------------------------------
	            //this._byteData.endian = Endian.LITTLE_ENDIAN;
	            //----------------------------------------------------------------------------
	            //----------------------------------------------------------------------------
	            // Parse header and decompress body if needed
	            this.parseHeader();
	            switch (this._compression) {
	                case AWDParser.DEFLATE:
	                case AWDParser.LZMA:
	                    this._pDieWithError('Compressed AWD formats not yet supported');
	                    break;
	                case AWDParser.UNCOMPRESSED:
	                    this._body = this._byteData;
	                    break;
	            }
	            this._parsed_header = true;
	        }
	        if (this._body) {
	            while (this._body.getBytesAvailable() > 0 && !this.parsingPaused)
	                this.parseNextBlock();
	            //----------------------------------------------------------------------------
	            // Return complete status
	            if (this._body.getBytesAvailable() == 0) {
	                this.dispose();
	                if (this._debugTimers)
	                    console.log("Parsing total: " + (this._time_all | 0) + "ms", " | graphics: " + this._num_graphics + ", " + (this._time_graphics | 0) + "ms", " | graphics bytes: " + this._num_graphics + ", " + (this._time_graphics_bytes | 0) + "ms", " | timelines: " + this._num_timeline + ", " + (this._time_timeline | 0) + "ms", " | fonts: " + this._num_fonts + ", " + (this._time_fonts | 0) + "ms", " | sounds: " + this._num_sounds + ", " + (this._time_sounds | 0) + "ms", " | mats: " + this._num_materials + ", " + (this._time_materials | 0) + "ms", " | textures: " + this._num_textures + ", " + (this._time_textures | 0) + "ms", " | sprites: " + this._num_sprites + ", " + (this._time_sprites | 0) + "ms");
	                return ParserBase_1.default.PARSING_DONE;
	            }
	            else {
	                return ParserBase_1.default.MORE_TO_PARSE;
	            }
	        }
	        else {
	            switch (this._compression) {
	                case AWDParser.DEFLATE:
	                case AWDParser.LZMA:
	                    if (this._debug)
	                        console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
	                    break;
	            }
	            // Error - most likely _body not set because we do not support compression.
	            return ParserBase_1.default.PARSING_DONE;
	        }
	    };
	    AWDParser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.default();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    AWDParser.prototype.dispose = function () {
	        for (var c in this._blocks) {
	            var b = this._blocks[c];
	            b.dispose();
	        }
	    };
	    AWDParser.prototype.parseNextBlock = function () {
	        var block;
	        var isParsed = false;
	        var ns;
	        var type;
	        var flags;
	        var len;
	        //*
	        if (this._debugTimers)
	            this.start_timeing = performance.now();
	        //*/
	        this._cur_block_id = this._body.readUnsignedInt();
	        ns = this._body.readUnsignedByte();
	        type = this._body.readUnsignedByte();
	        flags = this._body.readUnsignedByte();
	        len = this._body.readUnsignedInt();
	        var blockCompression = BitFlags.test(flags, BitFlags.FLAG4);
	        var blockCompressionLZMA = BitFlags.test(flags, BitFlags.FLAG5);
	        if (this._accuracyOnBlocks) {
	            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG1);
	            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG2);
	            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG3);
	        }
	        var blockEndAll = this._body.position + len;
	        if (len > this._body.getBytesAvailable()) {
	            this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
	            this._body.position += this._body.getBytesAvailable();
	            return;
	        }
	        //----------------------------------------------------------------------------
	        // Compressed AWD Formats not yet supported
	        if (blockCompression) {
	            this._pDieWithError('Compressed AWD formats not yet supported');
	            this._newBlockBytes = new ByteArray_1.default();
	            this._body.readBytes(this._newBlockBytes, 0, len);
	            this._newBlockBytes.position = 0;
	        }
	        else {
	            this._newBlockBytes = this._body;
	        }
	        //----------------------------------------------------------------------------
	        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	        //----------------------------------------------------------------------------
	        //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
	        //----------------------------------------------------------------------------
	        block = new AWDBlock_1.default(this._cur_block_id, type);
	        block.len = len;
	        var blockEndBlock = this._newBlockBytes.position + len;
	        if (blockCompression) {
	            this._pDieWithError('Compressed AWD formats not yet supported');
	        }
	        if (this._debug)
	            console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
	        this._blocks[this._cur_block_id] = block;
	        if ((this._version[0] == 3) && (this._version[1] == 0)) {
	            // probably should contain some info about the type of animation
	            var factory = new AS2SceneGraphFactory_1.default(this._view);
	            switch (type) {
	                case 24:
	                    this.parseSpriteLibraryBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 25:
	                    this.parseBillBoardLibraryBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 4444:
	                    this.parseAudioBlock(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 133:
	                    this.parseMovieClip(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 134:
	                    this.parseTextField(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 135:
	                    this.parseTesselatedFont(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 136:
	                    this.parseTextFormat(this._cur_block_id);
	                    isParsed = true;
	                    break;
	            }
	        }
	        if ((this._version[0] > 2) || ((this._version[0] >= 2) && (this._version[1] >= 1))) {
	            switch (type) {
	                case 11:
	                    this.parsePrimitves(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 31:
	                    this.parseSkyboxInstance(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 41:
	                    this.parseLight(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 42:
	                    this.parseCamera(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                //  case 43:
	                //      parseTextureProjector(_cur_block_id);
	                //      isParsed = true;
	                //      break;
	                case 51:
	                    this.parseLightPicker(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 81:
	                    this.parseMaterial_v1(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 83:
	                    this.parseCubeTexture(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 91:
	                    this.parseSharedMethodBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 92:
	                    this.parseShadowMethodBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 111:
	                    this.parseSpritePoseAnimation(this._cur_block_id, true);
	                    isParsed = true;
	                    break;
	                case 112:
	                    this.parseSpritePoseAnimation(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 113:
	                    this.parseVertexAnimationSet(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 122:
	                    this.parseAnimatorSet(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 253:
	                    this.parseCommand(this._cur_block_id);
	                    isParsed = true;
	                    break;
	            }
	        }
	        if (isParsed == false) {
	            switch (type) {
	                case 1:
	                    this.parseGraphics(this._cur_block_id);
	                    break;
	                case 22:
	                    this.parseContainer(this._cur_block_id);
	                    break;
	                case 23:
	                    this.parseSpriteInstance(this._cur_block_id);
	                    break;
	                case 81:
	                    this.parseMaterial(this._cur_block_id);
	                    break;
	                case 82:
	                    this.parseTexture(this._cur_block_id);
	                    break;
	                case 101:
	                    this.parseSkeleton(this._cur_block_id);
	                    break;
	                case 102:
	                    this.parseSkeletonPose(this._cur_block_id);
	                    break;
	                case 103:
	                    this.parseSkeletonAnimation(this._cur_block_id);
	                    break;
	                case 121:
	                //this.parseUVAnimation(this._cur_block_id);
	                //break;
	                case 254:
	                    this.parseNameSpace(this._cur_block_id);
	                    break;
	                case 255:
	                    this.parseMetaData(this._cur_block_id);
	                    break;
	                default:
	                    if (this._debug)
	                        console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
	                    this._newBlockBytes.position += len;
	                    break;
	            }
	        }
	        if (this._debug) {
	            if (this._newBlockBytes.position != blockEndBlock)
	                console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");
	            if (block.errorMessages) {
	                var len = block.errorMessages.length;
	                for (var msgCnt = 0; msgCnt < len; msgCnt++)
	                    console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
	            }
	            console.log("\n");
	        }
	        if (this._debugTimers && !this.parsingPaused)
	            this.updateTimers(type);
	        this._body.position = blockEndAll;
	        this._newBlockBytes = null;
	    };
	    AWDParser.prototype.updateTimers = function (type) {
	        var end_timing = performance.now();
	        var time_delta = end_timing - this.start_timeing;
	        this._time_all += time_delta;
	        if (type == 1) {
	            this._time_graphics += time_delta;
	            this._num_graphics++;
	        }
	        else if (type == 133) {
	            this._time_timeline += time_delta;
	            this._num_timeline++;
	        }
	        else if (type == 135) {
	            this._time_fonts += time_delta;
	            this._num_fonts++;
	        }
	        else if (type == 134) {
	            this._time_textfields += time_delta;
	            this._num_textfields++;
	        }
	        else if (type == 44) {
	            this._time_sounds += time_delta;
	            this._num_sounds++;
	        }
	        else if (type == 82) {
	            this._time_textures += time_delta;
	            this._num_textures++;
	        }
	        else if (type == 81) {
	            this._time_materials += time_delta;
	            this._num_materials++;
	        }
	        else if (type == 24) {
	            this._time_sprites += time_delta;
	            this._num_sprites++;
	        }
	    };
	    //--Parser Blocks---------------------------------------------------------------------------
	    AWDParser.prototype.parseTesselatedFont = function (blockID) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var new_font = AssetLibrary_1.default.getAsset(this._blocks[blockID].name);
	        var newfont = false;
	        if (new_font == undefined) {
	            new_font = new Font_1.default();
	            newfont = true;
	        }
	        var font_style_cnt = this._newBlockBytes.readUnsignedInt();
	        var font_style_char_cnt;
	        var font_style_name;
	        var new_font_style;
	        var font_style_char;
	        var attr_count = 0;
	        var sm_len;
	        var sm_end;
	        var str_ftype, str_type, str_len, str_end;
	        for (var i = 0; i < font_style_cnt; ++i) {
	            font_style_name = this.parseVarStr();
	            // dirty hack for icycle
	            // we use bold chars for non-latin chars, but we use regular for � sign,
	            // so the dirty hack is to merge the regular and the bold style
	            if ((this._blocks[blockID].name == "Tahoma") && (font_style_name == "RegularStyle")) {
	                font_style_name = "BoldStyle";
	            }
	            new_font_style = new_font.get_font_table(font_style_name);
	            new_font_style.set_font_em_size(this._newBlockBytes.readUnsignedInt());
	            new_font_style.set_whitespace_width(this._newBlockBytes.readUnsignedInt());
	            new_font_style.ascent = this._newBlockBytes.readFloat();
	            new_font_style.descent = this._newBlockBytes.readFloat();
	            //console.log(new_font_style.get_whitespace_width());
	            font_style_char_cnt = this._newBlockBytes.readUnsignedInt();
	            for (var j = 0; j < font_style_char_cnt; ++j) {
	                // todo: this is basically a simplified version of the elements-parsing done in parseGraphics. Make a parseElements() instead (?)
	                font_style_char = this._newBlockBytes.readUnsignedInt();
	                var char_width = this._newBlockBytes.readFloat();
	                sm_len = this._newBlockBytes.readUnsignedInt();
	                sm_end = this._newBlockBytes.position + sm_len;
	                // Loop through data streams
	                while (this._newBlockBytes.position < sm_end) {
	                    // Type, field type, length
	                    str_type = this._newBlockBytes.readUnsignedByte();
	                    str_ftype = this._newBlockBytes.readUnsignedByte();
	                    str_len = this._newBlockBytes.readUnsignedInt();
	                    str_end = this._newBlockBytes.position + str_len;
	                    if (str_type == 2) {
	                        var indices = new Array();
	                        for (var idx = 0; this._newBlockBytes.position < str_end; idx++)
	                            indices[idx] = this._newBlockBytes.readUnsignedShort();
	                    }
	                    else if (str_type == 11) {
	                        attr_count = 20;
	                        var curveData = new ByteArray_1.default(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else if (str_type == 12) {
	                        attr_count = 12;
	                        var curveData = new ByteArray_1.default(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else if (str_type == 10) {
	                        attr_count = 28;
	                        var curveData = new ByteArray_1.default(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else {
	                        this._newBlockBytes.position = str_end;
	                    }
	                }
	                if (curveData) {
	                    var vertexBuffer = new AttributesBuffer_1.default(attr_count, str_len / attr_count);
	                    vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
	                    var curve_elements = new TriangleElements_1.default(vertexBuffer);
	                    curve_elements.setPositions(new Float2Attributes_1.default(vertexBuffer));
	                    if (attr_count == 20)
	                        curve_elements.setCustomAttributes("curves", new Float3Attributes_1.default(vertexBuffer));
	                    else if (attr_count == 12)
	                        curve_elements.setCustomAttributes("curves", new Byte4Attributes_1.default(vertexBuffer, false));
	                    //add UVs if they exist in the data
	                    if (attr_count == 28)
	                        curve_elements.setUVs(new Float2Attributes_1.default(vertexBuffer));
	                    new_font_style.setChar(font_style_char.toString(), curve_elements, char_width);
	                }
	            }
	        }
	        this.parseProperties(null);
	        this.parseUserAttributes();
	        if (newfont) {
	            this._pFinalizeAsset(new_font, name);
	        }
	        this._blocks[blockID].data = new_font;
	        if (this._debug)
	            console.log("Parsed a font: Name = '" + name);
	    };
	    AWDParser.prototype.parseTextFormat = function (blockID) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var font = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var font_style_name = this.parseVarStr();
	        var newTextFormat = new TextFormat_1.default();
	        newTextFormat.font_name = font.name;
	        var font_table = font.get_font_table(font_style_name);
	        if (font_table != null) {
	            newTextFormat.font_style = font_style_name;
	            newTextFormat.font_table = font_table;
	        }
	        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mat.bothSides = true;
	        mat.curves = true;
	        var num_uv_values = this._newBlockBytes.readUnsignedByte();
	        var uv_values = [];
	        for (var uvcnt = 0; uvcnt < num_uv_values; uvcnt++)
	            uv_values[uvcnt] = this._newBlockBytes.readFloat();
	        newTextFormat.uv_values = uv_values;
	        var format_props = this.parseProperties(AWDParser.textFormatProperties);
	        newTextFormat.size = format_props.get(1, 12);
	        newTextFormat.letterSpacing = format_props.get(2, 0);
	        //newTextFormat.rotated = format_props.get(3,false);
	        newTextFormat.kerning = format_props.get(4, true);
	        //newTextFormat.baseline_shift = format_props.get(5,1);
	        var tf_align_int = format_props.get(6, 0);
	        if (tf_align_int == 1) {
	            newTextFormat.align = "right";
	        }
	        else if (tf_align_int == 2) {
	            newTextFormat.align = "center";
	        }
	        newTextFormat.indent = format_props.get(7, 0);
	        newTextFormat.leftMargin = format_props.get(8, 0);
	        newTextFormat.rightMargin = format_props.get(9, 0);
	        newTextFormat.leading = format_props.get(10, 0);
	        newTextFormat.material = mat;
	        this.parseUserAttributes(); // textformat has no extra-properties
	        //newTextFormat.extra =
	        this._pFinalizeAsset(newTextFormat, name);
	        this._blocks[blockID].data = newTextFormat;
	        if (this._debug)
	            console.log("Parsed a TextFormat: Name = '" + name + " font: " + font.name);
	    };
	    AWDParser.prototype.parseTextField = function (blockID, factory) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var newTextField = factory.createTextField();
	        var text_field_type = this._newBlockBytes.readUnsignedByte();
	        newTextField.type = AWDParser.textFieldTypes[text_field_type];
	        if (text_field_type == 3)
	            newTextField.displayAsPassword = true;
	        //
	        newTextField.textWidth = Math.abs(this._newBlockBytes.readFloat());
	        newTextField.textHeight = Math.abs(this._newBlockBytes.readFloat());
	        var num_paragraphs = this._newBlockBytes.readUnsignedInt();
	        var complete_text = "";
	        //console.log("num_paragraphs  '" + num_paragraphs);
	        for (var paracnt = 0; paracnt < num_paragraphs; paracnt++) {
	            var num_textruns = this._newBlockBytes.readUnsignedInt();
	            //console.log("num_textruns  '" + num_textruns);
	            for (var textrun_cnt = 0; textrun_cnt < num_textruns; textrun_cnt++) {
	                var text_format = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	                var txt_length = this._newBlockBytes.readUnsignedInt();
	                //console.log("txt_length  '" + txt_length);
	                if (txt_length > 0) {
	                    var this_txt = this._newBlockBytes.readUTFBytes(txt_length);
	                    //newTextField.appendText(this_txt, text_format);
	                    complete_text += this_txt;
	                }
	            }
	        }
	        newTextField.textFormat = text_format;
	        newTextField.text = complete_text;
	        //newTextField.construct_graphics();
	        // todo: optional matrix etc can be put in properties.
	        var props = this.parseProperties(AWDParser.textFieldProperties);
	        newTextField.selectable = props.get(1, false);
	        newTextField.border = props.get(3, false);
	        //newTextField.renderHTML =  props.get(4, false);
	        //newTextField.scrollable =  props.get(5, false);
	        //newTextField.text_flow =  props.get(7, 0);
	        //newTextField.orientationMode =  props.get(8, 0);
	        //newTextField.line_mode =  props.get(9, 0);
	        newTextField.extra = this.parseUserAttributes();
	        //console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
	        this._pFinalizeAsset(newTextField, name);
	        this._blocks[blockID].data = newTextField;
	        if (this._debug)
	            console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
	    };
	    // Block ID = 25
	    AWDParser.prototype.parseBillBoardLibraryBlock = function (blockID) {
	        var name = this.parseVarStr();
	        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mat.bothSides = true;
	        var billboard = new Billboard_1.default(mat);
	        // todo: optional matrix etc can be put in properties.
	        this.parseProperties(null);
	        billboard.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(billboard, name);
	        this._blocks[blockID].data = billboard;
	        if (this._debug)
	            console.log("Parsed a Library-Billboard: Name = '" + name + "| Material-Name = " + mat.name);
	    };
	    // Block ID = 24
	    AWDParser.prototype.parseSpriteLibraryBlock = function (blockID) {
	        var name = this.parseVarStr();
	        var data_id = this._newBlockBytes.readUnsignedInt();
	        var graphics = this._blocks[data_id].data;
	        this._blocks[blockID].geoID = data_id;
	        var num_materials = this._newBlockBytes.readUnsignedShort();
	        var materials = new Array();
	        var materialNames = new Array();
	        var mat;
	        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
	            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.default.getDefaultMaterial());
	            //mat.preserveAlpha = true;
	            mat.alphaBlending = true;
	            mat.useColorTransform = true;
	            materials[materials_parsed] = mat;
	            materialNames[materials_parsed] = mat.name;
	        }
	        var start_timeing = performance.now();
	        var sprite = new Sprite_1.default();
	        graphics.copyTo(sprite.graphics);
	        var end_timing = performance.now();
	        var time_delta = end_timing - start_timeing;
	        this._time_graphics_bytes += time_delta;
	        if (materials.length >= 1 && sprite.graphics.count == 1) {
	            sprite.material = materials[0];
	        }
	        else if (materials.length > 1) {
	            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
	            // than materials, repeat the last material for all remaining sub-sprites.
	            for (var i = 0; i < sprite.graphics.count; i++)
	                sprite.graphics.getGraphicAt(i).material = materials[Math.min(materials.length - 1, i)];
	        }
	        var count = this._newBlockBytes.readUnsignedShort();
	        //if(count != sprite.graphics.count)
	        //	throw new Error("num elements does not match num subsprites";
	        for (var i = 0; i < count; i++) {
	            var type = this._newBlockBytes.readUnsignedByte();
	            var sampler = new Sampler2D_1.default();
	            var graphic = sprite.graphics.getGraphicAt(i);
	            if (graphic) {
	                graphic.style = new Style_1.default();
	                graphic.style.addSamplerAt(sampler, graphic.material.getTextureAt(0));
	            }
	            if (type == 3) {
	                var tx = this._newBlockBytes.readFloat();
	                var ty = this._newBlockBytes.readFloat();
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.default(0, 0, 0, 0, tx, ty);
	                }
	            }
	            else if (type == 4) {
	                var matrix = this.parseMatrix32RawData();
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.default(matrix[0], matrix[2], matrix[1], matrix[3], matrix[4], matrix[5]);
	                }
	            }
	            else if (type == 5) {
	                var newMatrix = new Matrix_1.default(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat(), 0, 0, this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = newMatrix;
	                }
	            }
	            else if (type == 6) {
	                var x = this._newBlockBytes.readFloat();
	                var y = this._newBlockBytes.readFloat();
	                var width = this._newBlockBytes.readFloat();
	                var height = this._newBlockBytes.readFloat();
	                var matrix = this.parseMatrix32RawData();
	                if (graphic) {
	                    sampler.imageRect = new Rectangle_1.default(x, y, width, height);
	                    graphic.material.imageRect = true;
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.default(matrix[0], matrix[2], matrix[1], matrix[3], matrix[4], matrix[5]);
	                }
	            }
	            if (graphic) {
	                //check if curves are needed
	                if (graphic.elements.getCustomAtributes("curves"))
	                    graphic.material.curves = true;
	            }
	            // todo: finish optional properties (spreadmode + focalpoint)
	            this._newBlockBytes.readUnsignedInt();
	        }
	        this.parseProperties(null);
	        sprite.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(sprite, name);
	        this._blocks[blockID].data = sprite;
	        if (this._debug)
	            console.log("Parsed a Library-Sprite: Name = '" + name + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	    };
	    AWDParser.prototype.parseAudioBlock = function (blockID, factory) {
	        //var asset:Audio;todo create asset for audio
	        this._blocks[blockID].name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        var data_len;
	        // External
	        if (type == 0) {
	            data_len = this._newBlockBytes.readUnsignedInt();
	            var url;
	            url = this._newBlockBytes.readUTFBytes(data_len);
	            // todo parser needs to be able to handle mp3 and wav files if we trigger the loading of external ressource
	            this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.default(url), false, null, true);
	        }
	        else {
	            // todo: exporter does not export embed sounds yet
	            data_len = this._newBlockBytes.readUnsignedInt();
	            var data = new ByteArray_1.default(data_len);
	            this._newBlockBytes.readBytes(data, 0, data_len);
	            // todo parse sound from bytes
	            // this._pAddDependency(this._cur_block_id.toString(), null, false, ParserUtils.by(data), true);
	            this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        //this._blocks[blockID].data = asset;todo
	        if (this._debug)
	            console.log("Start parsing a " + ["external", "embed"][type] + " Audio file");
	    };
	    //Block ID = 4
	    AWDParser.prototype.parseMovieClip = function (blockID, factory) {
	        var i;
	        var j;
	        var cmd_asset;
	        var new_timeline = new Timeline_1.default();
	        var new_mc = factory.createMovieClip(new_timeline);
	        var name = this.parseVarStr();
	        // register list of potential childs
	        // a potential child can be reused on a timeline (added / removed / added)
	        // However, for each potential child, we need to register the max-number of instances that a frame contains
	        // we parse 2 lists of potential-childs:
	        // -	the first list contains potential-childs that are only ever instanced once per frame.
	        // -	the second list contains potential-childs that are instanced multiple times on some frames.
	        // on registering a child, the child gets a incremental-id assigned. This is the id, that the commands are using to access the childs.
	        // hence we need to be careful to register all objects in correct order.
	        var num_potential_childs = this._newBlockBytes.readUnsignedShort();
	        for (i = 0; i < num_potential_childs; i++) {
	            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            if (cmd_asset != null) {
	                new_timeline.registerPotentialChild(cmd_asset);
	            }
	            else {
	                //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
	                //new_mc.registerPotentialChild(cmd_asset);
	                console.log("ERROR when collecting objects for timeline");
	            }
	        }
	        var num_all_display_instances = num_potential_childs;
	        var num_potential_childs_multi_instanced = this._newBlockBytes.readUnsignedShort();
	        for (i = 0; i < num_potential_childs_multi_instanced; i++) {
	            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            var num_instances = this._newBlockBytes.readUnsignedShort();
	            num_all_display_instances += num_instances;
	            if (cmd_asset != null) {
	                for (j = 0; j < num_instances; j++)
	                    new_timeline.registerPotentialChild(cmd_asset);
	            }
	            else {
	                for (j = 0; j < num_instances; j++) {
	                    //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
	                    //new_mc.registerPotentialChild(cmd_asset);
	                    console.log("ERROR when collecting objects for timeline");
	                }
	            }
	        }
	        if (this._debug)
	            console.log("Parsed " + (num_potential_childs + num_potential_childs_multi_instanced) + " potential childs. They will be used by " + num_all_display_instances + " instances.");
	        // register list of potential sounds - for now we always have 0 sounds
	        var num_potential_sounds = this._newBlockBytes.readUnsignedShort();
	        var str_cnt = this._newBlockBytes.readUnsignedByte();
	        var str_len = 0;
	        var str_data_type = 0;
	        var str_type = 0;
	        var str_counter = 0;
	        for (i = 0; i < str_cnt; i++) {
	            // the first 6 lists are not optional and always in same order
	            // hence we can get type by incremental counter instead of stored uint8
	            if (str_counter < 6)
	                str_type = str_counter;
	            else
	                str_type = this._newBlockBytes.readUnsignedByte();
	            // get the data type for this stream (1:UINT8 - 2:UINT16 - 3:UINT32)
	            str_data_type = this._newBlockBytes.readUnsignedByte();
	            // size of this stream in byte
	            str_len = this._newBlockBytes.readUnsignedInt();
	            if (str_len > 0) {
	                var keyframes_start_indices_data = new ByteArray_1.default(str_len);
	                this._newBlockBytes.readBytes(keyframes_start_indices_data, 0, str_len);
	                var new_buffer;
	                //console.log("str_data_type = "+str_type);
	                switch (str_data_type) {
	                    case 1:
	                        new_buffer = new Uint8Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                    case 2:
	                        new_buffer = new Uint16Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                    case 4:
	                        new_buffer = new Uint32Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                }
	                switch (str_type) {
	                    case 0:
	                        new_timeline.keyframe_durations = new_buffer;
	                        new_timeline.numKeyFrames = str_len / str_data_type;
	                        break;
	                    case 1:
	                        new_timeline.frame_command_indices = new_buffer;
	                        break;
	                    case 2:
	                        new_timeline.frame_recipe = new_buffer;
	                        break;
	                    case 3:
	                        new_timeline.command_length_stream = new_buffer;
	                        break;
	                    case 4:
	                        new_timeline.command_index_stream = new_buffer;
	                        break;
	                    case 5:
	                        new_timeline.add_child_stream = new_buffer;
	                        break;
	                    case 6:
	                        new_timeline.remove_child_stream = new_buffer;
	                        break;
	                    case 7:
	                        new_timeline.update_child_stream = new_buffer;
	                        break;
	                    case 8:
	                        new_timeline.update_child_props_indices_stream = new_buffer;
	                        break;
	                    case 9:
	                        new_timeline.update_child_props_length_stream = new_buffer;
	                        break;
	                    case 10:
	                        new_timeline.property_type_stream = new_buffer;
	                        break;
	                    case 11:
	                        new_timeline.property_index_stream = new_buffer;
	                        break;
	                    case 12:
	                        new_timeline.properties_stream_int = new_buffer;
	                        break;
	                }
	            }
	            str_counter++;
	        }
	        var lc = 0;
	        var float_array_data;
	        str_cnt = this._newBlockBytes.readUnsignedByte();
	        for (i = 0; i < str_cnt; i++) {
	            str_type = this._newBlockBytes.readUnsignedByte();
	            str_len = this._newBlockBytes.readUnsignedInt();
	            switch (str_type) {
	                case 0:
	                    float_array_data = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_scale_rot = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 1:
	                    float_array_data = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_pos = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 2:
	                    float_array_data = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_all = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 3:
	                    float_array_data = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_ct = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 4:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    //console.log("start reading labels "+str_len);
	                    for (lc = 0; lc < str_len; lc++) {
	                        new_timeline._labels[this.parseVarStr()] = this._newBlockBytes.readUnsignedShort();
	                    }
	                    break;
	                case 5:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    var string_props_array = [];
	                    for (lc = 0; lc < str_len; lc++) {
	                        string_props_array.push(this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort()));
	                    }
	                    new_timeline.properties_stream_strings = string_props_array;
	                    break;
	                case 6:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    for (lc = 0; lc < str_len; lc++) {
	                        var frame_index = this._newBlockBytes.readUnsignedShort();
	                        var one_str_len = this._newBlockBytes.readUnsignedInt();
	                        //this._newBlockBytes.readUTFBytes(one_str_len);
	                        new_timeline.add_framescript(this._newBlockBytes.readUTFBytes(one_str_len), frame_index);
	                    }
	                    break;
	            }
	        }
	        new_timeline.init();
	        var sceneID = 0;
	        var fps = 25;
	        this.parseProperties(AWDParser.movieClipProperties);
	        this.parseUserAttributes();
	        this._pFinalizeAsset(new_mc, name);
	        this._blocks[blockID].data = new_mc;
	        if (this._debug)
	            console.log("Parsed a TIMELINE: Name = " + name + "| sceneID = " + sceneID + "| numFrames = " + new_mc.timeline.numFrames);
	    };
	    //Block ID = 1
	    AWDParser.prototype.parseGraphics = function (blockID) {
	        var graphics = new Graphics_1.default();
	        // Read name and sub count
	        var name = this.parseVarStr();
	        var numElements = this._newBlockBytes.readUnsignedShort();
	        // Read optional properties
	        var props = this.parseProperties(AWDParser.graphicsProperties);
	        var geoScaleU = props.get(1, 1);
	        var geoScaleV = props.get(2, 1);
	        //console.log("numElements "+numElements);
	        // Loop through sub sprites
	        for (var elements_parsed = 0; elements_parsed < numElements; elements_parsed++) {
	            var is_curve_elements = false;
	            var attr_count = 0;
	            var sm_len, sm_end;
	            var w_indices;
	            var weights;
	            sm_len = this._newBlockBytes.readUnsignedInt();
	            sm_end = this._newBlockBytes.position + sm_len;
	            var elementsProps = this.parseProperties(AWDParser.elementsProperties);
	            // Loop through data streams
	            while (this._newBlockBytes.position < sm_end) {
	                var idx = 0;
	                var str_ftype, str_type, str_len, str_end;
	                // Type, field type, length
	                str_type = this._newBlockBytes.readUnsignedByte();
	                str_ftype = this._newBlockBytes.readUnsignedByte();
	                str_len = this._newBlockBytes.readUnsignedInt();
	                str_end = this._newBlockBytes.position + str_len;
	                var x, y, z;
	                if (str_type == 1) {
	                    var verts = new Array();
	                    while (this._newBlockBytes.position < str_end) {
	                        x = this.readNumber(this._accuracyGeo);
	                        y = this.readNumber(this._accuracyGeo);
	                        z = this.readNumber(this._accuracyGeo);
	                        verts[idx++] = x;
	                        verts[idx++] = y;
	                        verts[idx++] = z;
	                    }
	                }
	                else if (str_type == 2) {
	                    var indices = new Array();
	                    while (this._newBlockBytes.position < str_end)
	                        indices[idx++] = this._newBlockBytes.readUnsignedShort();
	                }
	                else if (str_type == 3) {
	                    var uvs = new Array();
	                    while (this._newBlockBytes.position < str_end)
	                        uvs[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 4) {
	                    var normals = new Array();
	                    while (this._newBlockBytes.position < str_end)
	                        normals[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 6) {
	                    w_indices = Array();
	                    while (this._newBlockBytes.position < str_end)
	                        w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3;
	                }
	                else if (str_type == 7) {
	                    weights = new Array();
	                    while (this._newBlockBytes.position < str_end)
	                        weights[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 8) {
	                    this._newBlockBytes.position = str_end;
	                }
	                else if (str_type == 9) {
	                    this._newBlockBytes.position = str_end;
	                }
	                else if (str_type == 10) {
	                    is_curve_elements = true;
	                    attr_count = 28;
	                    var curveData = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else if (str_type == 11) {
	                    is_curve_elements = true;
	                    attr_count = 20;
	                    var curveData = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else if (str_type == 12) {
	                    is_curve_elements = true;
	                    attr_count = 12;
	                    var curveData = new ByteArray_1.default(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else {
	                    this._newBlockBytes.position = str_end;
	                }
	            }
	            this.parseUserAttributes(); // Ignore sub-sprite attributes for now
	            if (is_curve_elements) {
	                var vertexBuffer = new AttributesBuffer_1.default(attr_count, str_len / attr_count);
	                vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
	                var curve_elements = new TriangleElements_1.default(vertexBuffer);
	                curve_elements.setPositions(new Float2Attributes_1.default(vertexBuffer));
	                if (attr_count == 20) {
	                    curve_elements.setCustomAttributes("curves", new Float3Attributes_1.default(vertexBuffer));
	                }
	                else if (attr_count == 12) {
	                    curve_elements.setCustomAttributes("curves", new Byte4Attributes_1.default(vertexBuffer, false));
	                }
	                if (attr_count == 28)
	                    curve_elements.setUVs(new Float2Attributes_1.default(vertexBuffer));
	                graphics.addGraphic(curve_elements);
	                if (this._debug)
	                    console.log("Parsed a TriangleElements with curves");
	            }
	            else {
	                var triangle_elements = new TriangleElements_1.default(new AttributesBuffer_1.default());
	                if (weights)
	                    triangle_elements.jointsPerVertex = weights.length / (verts.length / 3);
	                if (normals)
	                    triangle_elements.autoDeriveNormals = false;
	                triangle_elements.autoDeriveTangents = true;
	                triangle_elements.setIndices(indices);
	                triangle_elements.setPositions(verts);
	                triangle_elements.setNormals(normals);
	                triangle_elements.setUVs(uvs);
	                triangle_elements.setJointWeights(weights);
	                triangle_elements.setJointIndices(w_indices);
	                var scaleU = elementsProps.get(1, 1);
	                var scaleV = elementsProps.get(2, 1);
	                var setSubUVs = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the graphics
	                if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
	                    setSubUVs = true;
	                    scaleU = geoScaleU / scaleU;
	                    scaleV = geoScaleV / scaleV;
	                }
	                if (setSubUVs)
	                    triangle_elements.scaleUV(scaleU, scaleV);
	                graphics.addGraphic(triangle_elements);
	                if (this._debug)
	                    console.log("Parsed a TriangleElements");
	            }
	        }
	        if ((geoScaleU != 1) || (geoScaleV != 1))
	            graphics.scaleUV(geoScaleU, geoScaleV);
	        this.parseUserAttributes();
	        this._pFinalizeAsset(graphics, name);
	        this._blocks[blockID].data = graphics;
	        if (this._debug)
	            console.log("Parsed Graphics: Name = " + name);
	    };
	    //Block ID = 11
	    AWDParser.prototype.parsePrimitves = function (blockID) {
	        var name;
	        var prefab;
	        var primType;
	        var elements_parsed;
	        var props;
	        var bsm;
	        // Read name and sub count
	        name = this.parseVarStr();
	        primType = this._newBlockBytes.readUnsignedByte();
	        props = this.parseProperties(AWDParser.primitiveProperties);
	        // to do, not all properties are set on all primitives
	        switch (primType) {
	            case 1:
	                prefab = new PrimitivePlanePrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
	                break;
	            case 2:
	                prefab = new PrimitiveCubePrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
	                break;
	            case 3:
	                prefab = new PrimitiveSpherePrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
	                break;
	            case 4:
	                prefab = new PrimitiveCylinderPrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true); // bool701, bool702, bool703, bool704);
	                if (!props.get(701, true))
	                    prefab.topClosed = false;
	                if (!props.get(702, true))
	                    prefab.bottomClosed = false;
	                if (!props.get(703, true))
	                    prefab.yUp = false;
	                break;
	            case 5:
	                prefab = new PrimitiveConePrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
	                break;
	            case 6:
	                prefab = new PrimitiveCapsulePrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
	                break;
	            case 7:
	                prefab = new PrimitiveTorusPrefab_1.default(null, ElementsType_1.default.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
	                break;
	            default:
	                prefab = new PrefabBase_1.default();
	                console.log("ERROR: UNSUPPORTED PREFAB_TYPE");
	                break;
	        }
	        if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
	        }
	        this.parseUserAttributes();
	        prefab.name = name;
	        this._pFinalizeAsset(prefab, name);
	        this._blocks[blockID].data = prefab;
	        if (this._debug) {
	            if ((primType < 0) || (primType > 7))
	                primType = 0;
	            console.log("Parsed a Primivite: Name = " + name + "| type = " + AWDParser.primitiveTypes[primType]);
	        }
	    };
	    // Block ID = 22
	    AWDParser.prototype.parseContainer = function (blockID) {
	        var name;
	        var mtx;
	        var ctr;
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mtx = this.parseMatrix3D();
	        name = this.parseVarStr();
	        var parentName = "Root (TopLevel)";
	        ctr = new DisplayObjectContainer_1.default();
	        ctr.transform.matrix3D = mtx;
	        if (parent) {
	            parent.addChild(ctr);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(ctr);
	        }
	        // in AWD version 2.1 we read the Container properties
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            var props = this.parseProperties(AWDParser.containerProperties);
	            ctr.pivot = new Vector3D_1.default(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	        }
	        else {
	            this.parseProperties(null);
	        }
	        // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
	        ctr.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(ctr, name);
	        this._blocks[blockID].data = ctr;
	        if (this._debug)
	            console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
	    };
	    // Block ID = 23
	    AWDParser.prototype.parseSpriteInstance = function (blockID) {
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var data_id = this._newBlockBytes.readUnsignedInt();
	        var asset = this._blocks[data_id].data;
	        var graphics;
	        var prefab;
	        var isPrefab = false;
	        if (asset.isAsset(Graphics_1.default)) {
	            graphics = asset;
	        }
	        else {
	            isPrefab = true;
	            prefab = asset;
	        }
	        this._blocks[blockID].geoID = data_id;
	        var num_materials = this._newBlockBytes.readUnsignedShort();
	        var materials = new Array();
	        var materialNames = new Array();
	        var mat;
	        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
	            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.default.getDefaultMaterial());
	            materials[materials_parsed] = mat;
	            materialNames[materials_parsed] = mat.name;
	        }
	        var sprite;
	        if (isPrefab) {
	            sprite = prefab.getNewObject();
	        }
	        else {
	            sprite = new Sprite_1.default();
	            graphics.copyTo(sprite.graphics);
	        }
	        sprite.transform.matrix3D = mtx;
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(sprite);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(sprite);
	        }
	        if (materials.length >= 1 && sprite.graphics.count == 1) {
	            sprite.material = materials[0];
	        }
	        else if (materials.length > 1) {
	            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
	            // than materials, repeat the last material for all remaining sub-sprites.
	            for (var i = 0; i < sprite.graphics.count; i++)
	                sprite.graphics.getGraphicAt(i).material = materials[Math.min(materials.length - 1, i)];
	        }
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            var props = this.parseProperties(AWDParser.spriteInstanceProperties);
	            sprite.pivot = new Vector3D_1.default(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	            sprite.castsShadows = props.get(5, true);
	        }
	        else {
	            this.parseProperties(null);
	        }
	        sprite.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(sprite, name);
	        this._blocks[blockID].data = sprite;
	        if (this._debug) {
	            if (isPrefab)
	                console.log("Parsed a Sprite for Prefab: Name = '" + name + "' | Parent-Name = " + parentName + "| Prefab-Name = " + prefab.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	            else
	                console.log("Parsed a Sprite for Graphics: Name = '" + name + "' | Parent-Name = " + parentName + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	        }
	    };
	    //Block ID 31
	    AWDParser.prototype.parseSkyboxInstance = function (blockID) {
	        var name = this.parseVarStr();
	        var asset = new Skybox_1.default();
	        var tex = new SingleCubeTexture_1.default(this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.default.getDefaultImageCube());
	        asset.texture = tex;
	        this.parseProperties(null);
	        asset.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(asset, name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a Skybox: Name = '" + name + "' | CubeTexture-Name = " + tex.name);
	    };
	    //Block ID = 41
	    AWDParser.prototype.parseLight = function (blockID) {
	        var light;
	        var newShadowMapper;
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var lightType = this._newBlockBytes.readUnsignedByte();
	        var props = this.parseProperties(AWDParser.lightProperties);
	        var shadowMapperType = props.get(9, 0);
	        var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
	        var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];
	        if (lightType == 1) {
	            light = new PointLight_1.default();
	            light.radius = props.get(1, 90000);
	            light.fallOff = props.get(2, 100000);
	            if (shadowMapperType > 0) {
	                if (shadowMapperType == 4) {
	                    newShadowMapper = new CubeMapShadowMapper_1.default();
	                }
	            }
	            light.transform.matrix3D = mtx;
	        }
	        if (lightType == 2) {
	            light = new DirectionalLight_1.default(props.get(21, 0), props.get(22, -1), props.get(23, 1));
	            if (shadowMapperType > 0) {
	                if (shadowMapperType == 1) {
	                    newShadowMapper = new DirectionalShadowMapper_1.default();
	                }
	            }
	        }
	        light.color = props.get(3, 0xffffff);
	        light.specular = props.get(4, 1.0);
	        light.diffuse = props.get(5, 1.0);
	        light.ambientColor = props.get(7, 0xffffff);
	        light.ambient = props.get(8, 0.0);
	        // if a shadowMapper has been created, adjust the depthMapSize if needed, assign to light and set castShadows to true
	        if (newShadowMapper) {
	            if (newShadowMapper instanceof CubeMapShadowMapper_1.default) {
	                if (props.get(10, 1) != 1)
	                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
	            }
	            else {
	                if (props.get(10, 2) != 2)
	                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
	            }
	            light.shadowMapper = newShadowMapper;
	            light.castsShadows = true;
	        }
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(light);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(light);
	        }
	        this.parseUserAttributes();
	        this._pFinalizeAsset(light, name);
	        this._blocks[blockID].data = light;
	        if (this._debug)
	            console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
	    };
	    //Block ID = 43
	    AWDParser.prototype.parseCamera = function (blockID) {
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var projection;
	        this._newBlockBytes.readUnsignedByte(); //set as active camera
	        this._newBlockBytes.readShort(); //lengthof lenses - not used yet
	        var projectiontype = this._newBlockBytes.readShort();
	        var props = this.parseProperties(AWDParser.cameraProperties);
	        switch (projectiontype) {
	            case 5001:
	                projection = new PerspectiveProjection_1.default(props.get(101, 60));
	                break;
	            case 5002:
	                projection = new OrthographicProjection_1.default(props.get(101, 500));
	                break;
	            case 5003:
	                projection = new OrthographicOffCenterProjection_1.default(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
	                break;
	            default:
	                console.log("unsupportedLenstype");
	                return;
	        }
	        var camera = new Camera_1.default(projection);
	        camera.transform.matrix3D = mtx;
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(camera);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(camera);
	        }
	        camera.name = name;
	        props = this.parseProperties(AWDParser.cameraPivotProperties);
	        camera.pivot = new Vector3D_1.default(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	        camera.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(camera, name);
	        this._blocks[blockID].data = camera;
	        if (this._debug)
	            console.log("Parsed a Camera: Name = '" + name + "' | Projectiontype = " + projection + " | Parent-Name = " + parentName);
	    };
	    //Block ID = 51
	    AWDParser.prototype.parseLightPicker = function (blockID) {
	        var name = this.parseVarStr();
	        var numLights = this._newBlockBytes.readUnsignedShort();
	        var lightsArray = new Array();
	        var lightsArrayNames = new Array();
	        for (var k = 0; k < numLights; k++) {
	            var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            lightsArray.push(light);
	            lightsArrayNames.push(light.name);
	        }
	        if (lightsArray.length == 0) {
	            this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
	            this.parseUserAttributes();
	            return; //return without any more parsing for this block
	        }
	        var lightPick = new StaticLightPicker_1.default(lightsArray);
	        lightPick.name = name;
	        this.parseUserAttributes();
	        this._pFinalizeAsset(lightPick, name);
	        this._blocks[blockID].data = lightPick;
	        if (this._debug)
	            console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames);
	    };
	    //Block ID = 81
	    AWDParser.prototype.parseMaterial = function (blockID) {
	        // TODO: not used
	        ////blockLength = block.len;
	        var name;
	        var type;
	        var props;
	        var mat;
	        var finalize;
	        var num_methods;
	        var methods_parsed;
	        var returnedArray;
	        name = this.parseVarStr();
	        type = this._newBlockBytes.readUnsignedByte();
	        num_methods = this._newBlockBytes.readUnsignedByte();
	        // Read material numerical properties
	        props = this.parseProperties(AWDParser.materialProperties);
	        methods_parsed = 0;
	        while (methods_parsed < num_methods) {
	            var method_type;
	            method_type = this._newBlockBytes.readUnsignedShort();
	            this.parseProperties(null);
	            this.parseUserAttributes();
	            methods_parsed += 1;
	        }
	        var debugString = "";
	        if (type === 1) {
	            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
	            var color = props.get(1, 0xffffff);
	            if (this.materialMode < 2) {
	                mat = new MethodMaterial_1.default(color, props.get(10, 1.0));
	            }
	            else {
	                mat = new MethodMaterial_1.default(color);
	                mat.mode = MethodMaterialMode_1.default.MULTI_PASS;
	            }
	        }
	        else if (type === 2) {
	            var texture = new Single2DTexture_1.default(this._blocks[props.get(2, 0)].data);
	            mat = new MethodMaterial_1.default();
	            mat.ambientMethod.texture = texture;
	            if (this.materialMode < 2) {
	                mat.alphaBlending = props.get(11, false);
	                mat.alpha = props.get(10, 1.0);
	                debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	            }
	            else {
	                mat.mode = MethodMaterialMode_1.default.MULTI_PASS;
	                debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	            }
	        }
	        mat.extra = this.parseUserAttributes();
	        mat.alphaThreshold = props.get(12, 0.0);
	        mat.style.sampler = new Sampler2D_1.default(props.get(13, false));
	        this._pFinalizeAsset(mat, name);
	        this._blocks[blockID].data = mat;
	        if (this._debug)
	            console.log(debugString);
	    };
	    // Block ID = 81 AWD2.1
	    AWDParser.prototype.parseMaterial_v1 = function (blockID) {
	        var mat;
	        var diffuseImage;
	        var normalImage;
	        var specImage;
	        var name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        var num_methods = this._newBlockBytes.readUnsignedByte();
	        var props = this.parseProperties(AWDParser.material_v1Properties);
	        var spezialType = props.get(4, 0);
	        var debugString = "Parsed Material ";
	        if (spezialType >= 2) {
	            this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
	            return;
	        }
	        if (type <= 2) {
	            if (this.materialMode == 1)
	                spezialType = 0;
	            else if (this.materialMode == 2)
	                spezialType = 1;
	            if (spezialType < 2) {
	                if (type == 1) {
	                    var color = props.get(1, 0xcccccc); //TODO temporarily swapped so that diffuse color goes to ambient
	                    if (spezialType == 1) {
	                        mat = new MethodMaterial_1.default(color);
	                        mat.mode = MethodMaterialMode_1.default.MULTI_PASS;
	                        debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
	                    }
	                    else {
	                        mat = new MethodMaterial_1.default(color, props.get(10, 1.0));
	                        mat.alphaBlending = props.get(11, false);
	                        debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
	                    }
	                }
	                else if (type == 2) {
	                    var texture = new Single2DTexture_1.default(this._blocks[props.get(2, 0)].data);
	                    mat = new MethodMaterial_1.default();
	                    mat.ambientMethod.texture = texture;
	                    if (spezialType == 1) {
	                        mat.mode = MethodMaterialMode_1.default.MULTI_PASS;
	                        debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	                    }
	                    else {
	                        mat.alpha = props.get(10, 1.0);
	                        mat.alphaBlending = props.get(11, false);
	                        debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	                    }
	                }
	                diffuseImage = this._blocks[props.get(17, 0)].data;
	                normalImage = this._blocks[props.get(3, 0)].data;
	                specImage = this._blocks[props.get(21, 0)].data;
	                mat.lightPicker = this._blocks[props.get(22, 0)].data;
	                mat.style.sampler = new Sampler2D_1.default(props.get(13, false), props.get(5, true), props.get(6, true));
	                mat.bothSides = props.get(7, false);
	                mat.alphaPremultiplied = props.get(8, false);
	                mat.blendMode = this.blendModeDic[props.get(9, 0)];
	                if (diffuseImage) {
	                    mat.diffuseTexture = new Single2DTexture_1.default(diffuseImage);
	                    debugString += " | DiffuseTexture-Name = " + diffuseImage.name;
	                }
	                if (normalImage) {
	                    mat.normalMethod.texture = new Single2DTexture_1.default(normalImage);
	                    debugString += " | NormalTexture-Name = " + normalImage.name;
	                }
	                if (specImage) {
	                    mat.specularMethod.texture = new Single2DTexture_1.default(specImage);
	                    debugString += " | SpecularTexture-Name = " + specImage.name;
	                }
	                mat.alphaThreshold = props.get(12, 0.0);
	                mat.ambientMethod.strength = props.get(15, 1.0);
	                mat.diffuseMethod.color = props.get(16, 0xffffff);
	                mat.specularMethod.strength = props.get(18, 1.0);
	                mat.specularMethod.gloss = props.get(19, 50);
	                mat.specularMethod.color = props.get(20, 0xffffff);
	                for (var methods_parsed = 0; methods_parsed < num_methods; methods_parsed++) {
	                    var method_type;
	                    method_type = this._newBlockBytes.readUnsignedShort();
	                    props = this.parseProperties(AWDParser.method_v1Properties);
	                    switch (method_type) {
	                        case 999:
	                            var effectMethod = this._blocks[props.get(1, 0)].data;
	                            mat.addEffectMethod(effectMethod);
	                            debugString += " | EffectMethod-Name = " + effectMethod.name;
	                            break;
	                        case 998:
	                            var shadowMapMethod = this._blocks[props.get(1, 0)].data;
	                            mat.shadowMethod = shadowMapMethod;
	                            debugString += " | ShadowMethod-Name = " + shadowMapMethod.name;
	                            break;
	                        case 1:
	                            var cubeTexture = new SingleCubeTexture_1.default(this._blocks[props.get(1, 0)].data);
	                            mat.ambientMethod = new AmbientEnvMapMethod_1.default();
	                            mat.ambientMethod.texture = cubeTexture;
	                            debugString += " | AmbientEnvMapMethod | EnvMap-Name =" + cubeTexture.name;
	                            break;
	                        case 51:
	                            mat.diffuseMethod = new DiffuseDepthMethod_1.default();
	                            debugString += " | DiffuseDepthMethod";
	                            break;
	                        case 52:
	                            var texture = new Single2DTexture_1.default(this._blocks[props.get(1, 0)].data);
	                            mat.diffuseMethod = new DiffuseGradientMethod_1.default(texture);
	                            debugString += " | DiffuseGradientMethod | GradientDiffuseTexture-Name =" + texture.name;
	                            break;
	                        case 53:
	                            mat.diffuseMethod = new DiffuseWrapMethod_1.default(props.get(101, 5));
	                            debugString += " | DiffuseWrapMethod";
	                            break;
	                        case 54:
	                            var texture = new Single2DTexture_1.default(this._blocks[props.get(1, 0)].data);
	                            mat.diffuseMethod = new DiffuseLightMapMethod_1.default(texture, this.blendModeDic[props.get(401, 10)], false, mat.diffuseMethod);
	                            debugString += " | DiffuseLightMapMethod | LightMapTexture-Name =" + texture.name;
	                            break;
	                        case 55:
	                            mat.diffuseMethod = new DiffuseCelMethod_1.default(props.get(401, 3), mat.diffuseMethod);
	                            mat.diffuseMethod.smoothness = props.get(101, 0.1);
	                            debugString += " | DiffuseCelMethod";
	                            break;
	                        case 56:
	                            //							mat.diffuseMethod = new DiffuseSubSurfaceMethod(); //depthMapSize and depthMapOffset ?
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scattering = props.get(101, 0.2);
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).translucency = props.get(102, 1);
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scatterColor = props.get(601, 0xffffff);
	                            //							debugString += " | DiffuseSubSurfaceMethod";
	                            break;
	                        case 101:
	                            mat.specularMethod = new SpecularAnisotropicMethod_1.default();
	                            debugString += " | SpecularAnisotropicMethod";
	                            break;
	                        case 102:
	                            mat.specularMethod = new SpecularPhongMethod_1.default();
	                            debugString += " | SpecularPhongMethod";
	                            break;
	                        case 103:
	                            mat.specularMethod = new SpecularCelMethod_1.default(props.get(101, 0.5), mat.specularMethod);
	                            mat.specularMethod.smoothness = props.get(102, 0.1);
	                            debugString += " | SpecularCelMethod";
	                            break;
	                        case 104:
	                            mat.specularMethod = new SpecularFresnelMethod_1.default(props.get(701, true), mat.specularMethod);
	                            mat.specularMethod.fresnelPower = props.get(101, 5);
	                            mat.specularMethod.normalReflectance = props.get(102, 0.1);
	                            debugString += " | SpecularFresnelMethod";
	                            break;
	                        case 151:
	                            break;
	                        case 152:
	                            var texture = new Single2DTexture_1.default(this._blocks[props.get(1, 0)].data);
	                            mat.normalMethod = new NormalSimpleWaterMethod_1.default(mat.normalMethod.texture || texture, texture);
	                            debugString += " | NormalSimpleWaterMethod | Second-NormalTexture-Name = " + texture.name;
	                            break;
	                    }
	                    this.parseUserAttributes();
	                }
	            }
	        }
	        else if ((type >= 3) && (type <= 7)) {
	            // if this is a basic material, we create it, finalize it, assign it to block-cache and return.
	            var color = props.get(1, 0xcccccc);
	            debugString += color;
	            var diffuseTexture = new Single2DTexture_1.default(this._blocks[props.get(2, 0)].data);
	            if (type == 5) {
	                diffuseTexture.mappingMode = MappingMode_1.default.LINEAR_GRADIENT;
	            }
	            else if (type == 6) {
	                diffuseTexture.mappingMode = MappingMode_1.default.RADIAL_GRADIENT;
	            }
	            var basic_mat = new BasicMaterial_1.default();
	            basic_mat.texture = diffuseTexture;
	            basic_mat.bothSides = true;
	            //basic_mat.preserveAlpha = true;
	            basic_mat.alphaBlending = true;
	            basic_mat.extra = this.parseUserAttributes();
	            this._pFinalizeAsset(basic_mat, name);
	            this._blocks[blockID].data = basic_mat;
	            if (this._debug)
	                console.log(debugString);
	            return;
	        }
	        mat.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(mat, name);
	        this._blocks[blockID].data = mat;
	        if (this._debug)
	            console.log(debugString);
	    };
	    //Block ID = 82
	    AWDParser.prototype.parseTexture = function (blockID) {
	        this._blocks[blockID].name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        this._texture_users[this._cur_block_id] = [];
	        // External
	        if (type == 0) {
	            var url = this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedInt());
	            this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.default(url), false, null, true);
	        }
	        else {
	            var data_len = this._newBlockBytes.readUnsignedInt();
	            var data = new ByteArray_1.default(data_len);
	            this._newBlockBytes.readBytes(data, 0, data_len);
	            //
	            // AWD3Parserutils - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
	            //
	            // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
	            // This gives the browser time to initialise image width / height.
	            this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        if (this._debug)
	            console.log("Start parsing a " + ["external", "embed"][type] + " Bitmap for Texture");
	    };
	    //Block ID = 83
	    AWDParser.prototype.parseCubeTexture = function (blockID) {
	        //blockLength = block.len;
	        var data_len;
	        var i;
	        this._texture_users[this._cur_block_id] = [];
	        var type = this._newBlockBytes.readUnsignedByte();
	        this._blocks[blockID].name = this.parseVarStr();
	        for (i = 0; i < 6; i++) {
	            this._texture_users[this._cur_block_id] = [];
	            // External
	            if (type == 0) {
	                data_len = this._newBlockBytes.readUnsignedInt();
	                var url;
	                url = this._newBlockBytes.readUTFBytes(data_len);
	                this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.default(url), false, null, true, i);
	            }
	            else {
	                data_len = this._newBlockBytes.readUnsignedInt();
	                var data = new ByteArray_1.default(data_len);
	                this._newBlockBytes.readBytes(data, 0, data_len);
	                this._pAddDependency(this._cur_block_id.toString(), null, false, ParserUtils_1.default.byteArrayToImage(data), true, i);
	            }
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        if (this._debug)
	            console.log("Start parsing 6 " + ["external", "embed"][type] + " Bitmaps for CubeTexture");
	    };
	    //Block ID = 91
	    AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
	        var asset;
	        this._blocks[blockID].name = this.parseVarStr();
	        asset = this.parseSharedMethodList(blockID);
	        this.parseUserAttributes();
	        this._blocks[blockID].data = asset;
	        this._pFinalizeAsset(asset, this._blocks[blockID].name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
	    };
	    //Block ID = 92
	    AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
	        this._blocks[blockID].name = this.parseVarStr();
	        var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var asset = this.parseShadowMethodList(light, blockID);
	        if (!asset)
	            return;
	        this.parseUserAttributes(); // Ignore for now
	        this._pFinalizeAsset(asset, this._blocks[blockID].name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", light.name);
	    };
	    //Block ID = 253
	    AWDParser.prototype.parseCommand = function (blockID) {
	        var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
	        var parentObject = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var targetObject;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var numCommands = this._newBlockBytes.readShort();
	        var typeCommand = this._newBlockBytes.readShort();
	        var props = this.parseProperties(AWDParser.commandProperties);
	        switch (typeCommand) {
	            case 1:
	                targetObject = this._blocks[props.get(1, 0)].data;
	                targetObject.transform.matrix3D = mtx;
	                if (parentObject)
	                    parentObject.addChild(targetObject);
	                break;
	        }
	        if (targetObject) {
	            props = this.parseProperties(AWDParser.targetProperties);
	            targetObject.pivot = new Vector3D_1.default(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	            targetObject.extra = this.parseUserAttributes();
	        }
	        this._blocks[blockID].data = targetObject;
	        if (this._debug)
	            console.log("Parsed a CommandBlock: Name = '" + name);
	    };
	    //blockID 255
	    AWDParser.prototype.parseMetaData = function (blockID) {
	        var props = this.parseProperties(AWDParser.metaDataProperties);
	        if (this._debug) {
	            console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
	            console.log("                        EncoderName       = " + props.get(2, "unknown"));
	            console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
	            console.log("                        GeneratorName     = " + props.get(4, "unknown"));
	            console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
	        }
	    };
	    //blockID 254
	    AWDParser.prototype.parseNameSpace = function (blockID) {
	        var id = this._newBlockBytes.readUnsignedByte();
	        var nameSpaceString = this.parseVarStr();
	        if (this._debug)
	            console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
	    };
	    // this functions reads and creates a ShadowMethodMethod
	    AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
	        var methodType = this._newBlockBytes.readUnsignedShort();
	        var shadowMethod;
	        var props = this.parseProperties(this.shadowMethodListProperties);
	        var targetID;
	        var returnedArray;
	        switch (methodType) {
	            //				case 1001: //CascadeShadowMapMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [ShadowMapMethodBase.assetType]);
	            //					if (!returnedArray[0]) {
	            //						_blocks[blockID].addError("Could not find the ShadowBaseMethod (ID = " + targetID + " ) for this CascadeShadowMapMethod - ShadowMethod not created");
	            //						return shadowMethod;
	            //					}
	            //					shadowMethod = new CascadeShadowMapMethod(returnedArray[1]);
	            //					break;
	            case 1002:
	                shadowMethod = new ShadowNearMethod_1.default(this._blocks[props.get(1, 0)].data);
	                break;
	            case 1101:
	                shadowMethod = new ShadowFilteredMethod_1.default(light);
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                break;
	            case 1102:
	                shadowMethod = new ShadowDitheredMethod_1.default(light, props.get(201, 5));
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                shadowMethod.range = props.get(103, 1);
	                break;
	            case 1103:
	                shadowMethod = new ShadowSoftMethod_1.default(light, props.get(201, 5));
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                shadowMethod.range = props.get(103, 1);
	                break;
	            case 1104:
	                shadowMethod = new ShadowHardMethod_1.default(light);
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                break;
	        }
	        this.parseUserAttributes();
	        return shadowMethod;
	    };
	    //Block ID 101
	    AWDParser.prototype.parseSkeleton = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_joints = this._newBlockBytes.readUnsignedShort();
	        var skeleton = new Skeleton_1.default();
	        this.parseProperties(null); // Discard properties for now
	        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
	            var joint;
	            var ibp;
	            // Ignore joint id
	            this._newBlockBytes.readUnsignedShort();
	            joint = new SkeletonJoint_1.default();
	            joint.parentIndex = this._newBlockBytes.readUnsignedShort() - 1; // 0=null in AWD
	            joint.name = this.parseVarStr();
	            ibp = this.parseMatrix3D();
	            joint.inverseBindPose = ibp.rawData;
	            // Ignore joint props/attributes for now
	            this.parseProperties(null);
	            this.parseUserAttributes();
	            skeleton.joints.push(joint);
	        }
	        // Discard attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(skeleton, name);
	        this._blocks[blockID].data = skeleton;
	        if (this._debug)
	            console.log("Parsed a Skeleton: Name = " + skeleton.name + " | Number of Joints = " + joints_parsed);
	    };
	    //Block ID = 102
	    AWDParser.prototype.parseSkeletonPose = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_joints = this._newBlockBytes.readUnsignedShort();
	        this.parseProperties(null); // Ignore properties for now
	        var pose = new SkeletonPose_1.default();
	        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
	            var joint_pose;
	            var has_transform;
	            joint_pose = new JointPose_1.default();
	            has_transform = this._newBlockBytes.readUnsignedByte();
	            if (has_transform == 1) {
	                var mtx_data = this.parseMatrix43RawData();
	                var mtx = new Matrix3D_1.default(mtx_data);
	                joint_pose.orientation.fromMatrix(mtx);
	                joint_pose.translation.copyFrom(mtx.position);
	                pose.jointPoses[joints_parsed] = joint_pose;
	            }
	        }
	        // Skip attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(pose, name);
	        this._blocks[blockID].data = pose;
	        if (this._debug)
	            console.log("Parsed a SkeletonPose: Name = " + pose.name + " | Number of Joints = " + joints_parsed);
	    };
	    //blockID 103
	    AWDParser.prototype.parseSkeletonAnimation = function (blockID /*uint*/) {
	        var frame_dur;
	        var pose_id;
	        var name = this.parseVarStr();
	        var clip = new SkeletonClipNode_1.default();
	        var num_frames = this._newBlockBytes.readUnsignedShort();
	        this.parseProperties(null); // Ignore properties for now
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            pose_id = this._newBlockBytes.readUnsignedInt();
	            frame_dur = this._newBlockBytes.readUnsignedShort();
	            clip.addFrame(this._blocks[pose_id].data, frame_dur);
	        }
	        if (clip.frames.length == 0) {
	            this._blocks[blockID].addError("Could not this SkeletonClipNode, because no Frames where set.");
	            return;
	        }
	        // Ignore attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(clip, name);
	        this._blocks[blockID].data = clip;
	        if (this._debug)
	            console.log("Parsed a SkeletonClipNode: Name = " + clip.name + " | Number of Frames = " + clip.frames.length);
	    };
	    //Block ID = 111 /  Block ID = 112
	    AWDParser.prototype.parseSpritePoseAnimation = function (blockID /*uint*/, poseOnly) {
	        if (poseOnly === void 0) { poseOnly = false; }
	        var subSpriteParsed;
	        var x;
	        var y;
	        var z;
	        var str_len;
	        var str_end;
	        var elements;
	        var idx = 0;
	        var clip = new VertexClipNode_1.default();
	        var indices;
	        var verts;
	        var streamtypes = new Array();
	        var props;
	        var name = this.parseVarStr();
	        var geo_id = this._newBlockBytes.readUnsignedInt();
	        var graphics = this._blocks[geo_id].data;
	        var uvs = this.getUVForVertexAnimation(geo_id);
	        var num_frames = (!poseOnly) ? this._newBlockBytes.readUnsignedShort() : 1;
	        var num_subsprites = this._newBlockBytes.readUnsignedShort();
	        var num_Streams = this._newBlockBytes.readUnsignedShort();
	        for (var streamsParsed = 0; streamsParsed < num_Streams; streamsParsed++)
	            streamtypes.push(this._newBlockBytes.readUnsignedShort());
	        props = this.parseProperties(this.spritePoseAnimationProperties);
	        clip.looping = props.get(1, true);
	        clip.stitchFinalFrame = props.get(2, false);
	        var frame_dur;
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            frame_dur = this._newBlockBytes.readUnsignedShort();
	            graphics = new Graphics_1.default();
	            subSpriteParsed = 0;
	            while (subSpriteParsed < num_subsprites) {
	                streamsParsed = 0;
	                str_len = this._newBlockBytes.readUnsignedInt();
	                str_end = this._newBlockBytes.position + str_len;
	                while (streamsParsed < num_Streams) {
	                    if (streamtypes[streamsParsed] == 1) {
	                        indices = graphics.getGraphicAt(subSpriteParsed).elements.indices;
	                        verts = new Array();
	                        idx = 0;
	                        while (this._newBlockBytes.position < str_end) {
	                            x = this.readNumber(this._accuracyGeo);
	                            y = this.readNumber(this._accuracyGeo);
	                            z = this.readNumber(this._accuracyGeo);
	                            verts[idx++] = x;
	                            verts[idx++] = y;
	                            verts[idx++] = z;
	                        }
	                        elements = new TriangleElements_1.default(new AttributesBuffer_1.default());
	                        elements.setIndices(indices);
	                        elements.setPositions(verts);
	                        elements.setUVs(uvs[subSpriteParsed]);
	                        elements.setNormals(null);
	                        elements.setTangents(null);
	                        elements.autoDeriveNormals = false;
	                        elements.autoDeriveTangents = false;
	                        subSpriteParsed++;
	                        graphics.addGraphic(elements);
	                    }
	                    else
	                        this._newBlockBytes.position = str_end;
	                    streamsParsed++;
	                }
	            }
	            clip.addFrame(graphics, frame_dur);
	        }
	        this.parseUserAttributes();
	        this._pFinalizeAsset(clip, name);
	        this._blocks[blockID].data = clip;
	        if (this._debug)
	            console.log("Parsed a VertexClipNode: Name = " + clip.name + " | Target-Graphics-Name = " + graphics.name + " | Number of Frames = " + clip.frames.length);
	    };
	    //BlockID 113
	    AWDParser.prototype.parseVertexAnimationSet = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_frames = this._newBlockBytes.readUnsignedShort();
	        var props = this.parseProperties(AWDParser.vertexAnimationSetProperties);
	        var skeletonFrames = new Array();
	        var vertexFrames = new Array();
	        var clipNode;
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            clipNode = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            if (clipNode instanceof VertexClipNode_1.default)
	                vertexFrames.push(clipNode);
	            else if (clipNode instanceof SkeletonClipNode_1.default)
	                skeletonFrames.push(clipNode);
	        }
	        if ((vertexFrames.length == 0) && (skeletonFrames.length == 0)) {
	            this._blocks[blockID].addError("Could not create this AnimationSet, because it contains no animations");
	            return;
	        }
	        this.parseUserAttributes();
	        if (vertexFrames.length > 0) {
	            var newVertexAnimationSet = new VertexAnimationSet_1.default();
	            for (var i = 0; i < vertexFrames.length; i++)
	                newVertexAnimationSet.addAnimation(vertexFrames[i]);
	            this._pFinalizeAsset(newVertexAnimationSet, name);
	            this._blocks[blockID].data = newVertexAnimationSet;
	            if (this._debug)
	                console.log("Parsed a VertexAnimationSet: Name = " + name + " | Animations = " + newVertexAnimationSet.animations.length + " | Animation-Names = " + newVertexAnimationSet.animationNames);
	        }
	        else if (skeletonFrames.length > 0) {
	            var newSkeletonAnimationSet = new SkeletonAnimationSet_1.default(props.get(1, 4)); //props.get(1,4));
	            for (var i = 0; i < skeletonFrames.length; i++)
	                newSkeletonAnimationSet.addAnimation(skeletonFrames[i]);
	            this._pFinalizeAsset(newSkeletonAnimationSet, name);
	            this._blocks[blockID].data = newSkeletonAnimationSet;
	            if (this._debug)
	                console.log("Parsed a SkeletonAnimationSet: Name = " + name + " | Animations = " + newSkeletonAnimationSet.animations.length + " | Animation-Names = " + newSkeletonAnimationSet.animationNames);
	        }
	    };
	    //BlockID 122
	    AWDParser.prototype.parseAnimatorSet = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedShort();
	        var props = this.parseProperties(AWDParser.animatorSetProperties);
	        var targetAnimationSet = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var targetSpritees = new Array();
	        var targetSpriteLength = this._newBlockBytes.readUnsignedShort();
	        for (var i = 0; i < targetSpriteLength; i++)
	            targetSpritees.push(this._blocks[this._newBlockBytes.readUnsignedInt()].data);
	        var activeState = this._newBlockBytes.readUnsignedShort();
	        var autoplay = (this._newBlockBytes.readUnsignedByte() == 1);
	        this.parseUserAttributes();
	        this.parseUserAttributes();
	        var thisAnimator;
	        if (type == 1)
	            thisAnimator = new SkeletonAnimator_1.default(targetAnimationSet, this._blocks[props.get(1, 0)].data);
	        else if (type == 2)
	            thisAnimator = new VertexAnimator_1.default(targetAnimationSet);
	        this._pFinalizeAsset(thisAnimator, name);
	        this._blocks[blockID].data = thisAnimator;
	        for (i = 0; i < targetSpritees.length; i++) {
	            if (type == 1)
	                targetSpritees[i].animator = thisAnimator;
	            else if (type == 2)
	                targetSpritees[i].animator = thisAnimator;
	        }
	        if (this._debug)
	            console.log("Parsed a Animator: Name = " + name);
	    };
	    // this functions reads and creates a EffectMethod
	    AWDParser.prototype.parseSharedMethodList = function (blockID) {
	        var methodType = this._newBlockBytes.readUnsignedShort();
	        var effectMethodReturn;
	        var props = this.parseProperties(this.sharedMethodListProperties);
	        switch (methodType) {
	            // Effect Methods
	            case 401:
	                effectMethodReturn = new EffectColorMatrixMethod_1.default(props.get(101, new Array(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)));
	                break;
	            case 402:
	                effectMethodReturn = new EffectColorTransformMethod_1.default();
	                var offCol = props.get(601, 0x00000000);
	                effectMethodReturn.colorTransform = new ColorTransform_1.default(props.get(102, 1), props.get(103, 1), props.get(104, 1), props.get(101, 1), ((offCol >> 16) & 0xFF), ((offCol >> 8) & 0xFF), (offCol & 0xFF), ((offCol >> 24) & 0xFF));
	                break;
	            case 403:
	                effectMethodReturn = new EffectEnvMapMethod_1.default(new SingleCubeTexture_1.default(this._blocks[props.get(1, 0)].data), props.get(101, 1));
	                var targetID = props.get(2, 0);
	                if (targetID > 0) {
	                }
	                break;
	            case 404:
	                effectMethodReturn = new EffectLightMapMethod_1.default(this._blocks[props.get(1, 0)].data, this.blendModeDic[props.get(401, 10)]); //usesecondaryUV not set
	                break;
	            //				case 405: //ProjectiveTextureMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [TextureProjector.assetType]);
	            //					if (!returnedArray[0])
	            //						_blocks[blockID].addError("Could not find the TextureProjector (ID = " + targetID + " ) for this ProjectiveTextureMethod");
	            //					effectMethodReturn = new ProjectiveTextureMethod(returnedArray[1], blendModeDic[props.get(401, 10)]);
	            //					break;
	            case 406:
	                effectMethodReturn = new EffectRimLightMethod_1.default(props.get(601, 0xffffff), props.get(101, 0.4), props.get(101, 2)); //blendMode
	                break;
	            case 407:
	                effectMethodReturn = new EffectAlphaMaskMethod_1.default(this._blocks[props.get(1, 0)].data, props.get(701, false));
	                break;
	            //				case 408: //RefractionEnvMapMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [TextureBase.assetType], "CubeTexture");
	            //					if (!returnedArray[0])
	            //						_blocks[blockID].addError("Could not find the EnvMap (ID = " + targetID + " ) for this RefractionEnvMapMethod");
	            //					effectMethodReturn = new RefractionEnvMapMethod(returnedArray[1], props.get(101, 0.1), props.get(102, 0.01), props.get(103, 0.01), props.get(104, 0.01));
	            //					RefractionEnvMapMethod(effectMethodReturn).alpha = props.get(104, 1);
	            //					break;
	            //				case 409: //OutlineMethod
	            //					effectMethodReturn = new OutlineMethod(props.get(601, 0x00000000), props.get(101, 1), props.get(701, true), props.get(702, false));
	            //					break;
	            case 410:
	                effectMethodReturn = new EffectFresnelEnvMapMethod_1.default(this._blocks[props.get(1, 0)].data, props.get(101, 1));
	                break;
	            case 411:
	                effectMethodReturn = new EffectFogMethod_1.default(props.get(101, 0), props.get(102, 1000), props.get(601, 0x808080));
	                break;
	        }
	        this.parseUserAttributes();
	        return effectMethodReturn;
	    };
	    AWDParser.prototype.parseUserAttributes = function () {
	        var list_len = this._newBlockBytes.readUnsignedInt();
	        if (list_len > 0) {
	            var list_end = this._newBlockBytes.position + list_len;
	            var attributes = {};
	            for (var attibuteCnt = 0; this._newBlockBytes.position < list_end; attibuteCnt++) {
	                var ns_id;
	                var attr_key;
	                var attr_type;
	                var attr_len;
	                var attr_val;
	                // TODO: Properly tend to namespaces in attributes
	                ns_id = this._newBlockBytes.readUnsignedByte();
	                attr_key = this.parseVarStr();
	                attr_type = this._newBlockBytes.readUnsignedByte();
	                attr_len = this._newBlockBytes.readUnsignedInt();
	                if ((this._newBlockBytes.position + attr_len) > list_end) {
	                    console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
	                    this._newBlockBytes.position = list_end;
	                    return attributes;
	                }
	                switch (attr_type) {
	                    case AWDParser.AWDSTRING:
	                        attr_val = this._newBlockBytes.readUTFBytes(attr_len);
	                        break;
	                    case AWDParser.INT8:
	                        attr_val = this._newBlockBytes.readByte();
	                        break;
	                    case AWDParser.INT16:
	                        attr_val = this._newBlockBytes.readShort();
	                        break;
	                    case AWDParser.INT32:
	                        attr_val = this._newBlockBytes.readInt();
	                        break;
	                    case AWDParser.BOOL:
	                    case AWDParser.UINT8:
	                        attr_val = this._newBlockBytes.readUnsignedByte();
	                        break;
	                    case AWDParser.UINT16:
	                        attr_val = this._newBlockBytes.readUnsignedShort();
	                        break;
	                    case AWDParser.UINT32:
	                    case AWDParser.BADDR:
	                        attr_val = this._newBlockBytes.readUnsignedInt();
	                        break;
	                    case AWDParser.FLOAT32:
	                        attr_val = this._newBlockBytes.readFloat();
	                        break;
	                    case AWDParser.FLOAT64:
	                        attr_val = this._newBlockBytes.readDouble();
	                        break;
	                    default:
	                        attr_val = 'unimplemented attribute type ' + attr_type;
	                        this._newBlockBytes.position += attr_len;
	                        break;
	                }
	                attributes[attr_key] = attr_val;
	                if (this._debug)
	                    console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
	            }
	        }
	        return attributes;
	    };
	    AWDParser.prototype.parseProperties = function (expected) {
	        var list_len = this._newBlockBytes.readUnsignedInt();
	        var props = new AWDProperties();
	        var list_end = this._newBlockBytes.position + list_len;
	        if (expected) {
	            var len;
	            var key;
	            var type;
	            for (var propertyCnt = 0; this._newBlockBytes.position < list_end; propertyCnt++) {
	                key = this._newBlockBytes.readUnsignedShort();
	                len = this._newBlockBytes.readUnsignedInt();
	                if ((this._newBlockBytes.position + len) > list_end) {
	                    console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
	                    this._newBlockBytes.position = list_end;
	                    return props;
	                }
	                if (expected[key]) {
	                    type = expected[key];
	                    props.set(key, this.parseAttrValue(type, len));
	                }
	                else {
	                    this._newBlockBytes.position += len;
	                }
	            }
	        }
	        else {
	            this._newBlockBytes.position = list_end;
	        }
	        return props;
	    };
	    AWDParser.prototype.parseAttrValue = function (type, len) {
	        var elem_len;
	        var read_func;
	        var accuracy;
	        switch (type) {
	            case AWDParser.BOOL:
	            case AWDParser.INT8:
	                elem_len = 1;
	                read_func = this._newBlockBytes.readByte;
	                break;
	            case AWDParser.INT16:
	                elem_len = 2;
	                read_func = this._newBlockBytes.readShort;
	                break;
	            case AWDParser.INT32:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readInt;
	                break;
	            case AWDParser.UINT8:
	                elem_len = 1;
	                read_func = this._newBlockBytes.readUnsignedByte;
	                break;
	            case AWDParser.UINT16:
	                elem_len = 2;
	                read_func = this._newBlockBytes.readUnsignedShort;
	                break;
	            case AWDParser.UINT32:
	            case AWDParser.COLOR:
	            case AWDParser.BADDR:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readUnsignedInt;
	                break;
	            case AWDParser.FLOAT32:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readFloat;
	                break;
	            case AWDParser.FLOAT64:
	                elem_len = 8;
	                read_func = this._newBlockBytes.readDouble;
	                break;
	            case AWDParser.AWDSTRING:
	                return this._newBlockBytes.readUTFBytes(len);
	            case AWDParser.VECTOR2x1:
	            case AWDParser.VECTOR3x1:
	            case AWDParser.VECTOR4x1:
	            case AWDParser.MTX3x2:
	            case AWDParser.MTX3x3:
	            case AWDParser.MTX4x3:
	            case AWDParser.MTX4x4:
	                elem_len = 8;
	                read_func = this._newBlockBytes.readDouble;
	                break;
	            case AWDParser.GEO_NUMBER:
	                accuracy = this._accuracyGeo;
	            case AWDParser.MATRIX_NUMBER:
	                accuracy = this._accuracyMatrix;
	            case AWDParser.PROPERTY_NUMBER:
	                accuracy = this._accuracyProps;
	            default:
	                if (accuracy) {
	                    elem_len = 8;
	                    read_func = this._newBlockBytes.readDouble;
	                }
	                else {
	                    elem_len = 4;
	                    read_func = this._newBlockBytes.readFloat;
	                }
	        }
	        if (elem_len < len) {
	            var list = [];
	            var num_elems = len / elem_len;
	            for (var num_read = 0; num_read < num_elems; num_read++)
	                list[num_read] = read_func.call(this._newBlockBytes);
	            return list;
	        }
	        else {
	            return read_func.call(this._newBlockBytes);
	        }
	    };
	    AWDParser.prototype.parseHeader = function () {
	        this._byteData.position = 3; // Skip magic string and parse version
	        this._version[0] = this._byteData.readUnsignedByte();
	        this._version[1] = this._byteData.readUnsignedByte();
	        var flags = this._byteData.readUnsignedShort(); // Parse bit flags
	        this._streaming = BitFlags.test(flags, BitFlags.FLAG1);
	        // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG2);
	            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG3);
	            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG4);
	        }
	        this._compression = this._byteData.readUnsignedByte(); // compression
	        if (this._debug) {
	            console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
	            console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
	        }
	        // Check file integrity
	        var body_len = this._byteData.readUnsignedInt();
	        if (!this._streaming && body_len != this._byteData.getBytesAvailable())
	            this._pDieWithError('AWD2 body length does not match header integrity field');
	    };
	    // Helper - functions
	    AWDParser.prototype.getUVForVertexAnimation = function (spriteID /*uint*/) {
	        if (this._blocks[spriteID].data instanceof Sprite_1.default)
	            spriteID = this._blocks[spriteID].geoID;
	        if (this._blocks[spriteID].uvsForVertexAnimation)
	            return this._blocks[spriteID].uvsForVertexAnimation;
	        var graphics = this._blocks[spriteID].data;
	        var elements;
	        var uvsForVertexAnimation = this._blocks[spriteID].uvsForVertexAnimation = new Array();
	        var len = graphics.count;
	        for (var geoCnt = 0; geoCnt < len; geoCnt++) {
	            elements = graphics.getGraphicAt(geoCnt).elements;
	            uvsForVertexAnimation[geoCnt] = elements.uvs.get(elements.numVertices);
	        }
	        return this._blocks[spriteID].uvsForVertexAnimation;
	    };
	    AWDParser.prototype.parseVarStr = function () {
	        return this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort());
	    };
	    AWDParser.prototype.readNumber = function (precision) {
	        if (precision === void 0) { precision = false; }
	        if (precision)
	            return this._newBlockBytes.readDouble();
	        return this._newBlockBytes.readFloat();
	    };
	    AWDParser.prototype.parseMatrix3D = function () {
	        return new Matrix3D_1.default(this.parseMatrix43RawData());
	    };
	    AWDParser.prototype.parseMatrix32RawData = function () {
	        var mtx_raw = new Array(6);
	        for (var i = 0; i < 6; i++)
	            mtx_raw[i] = this._newBlockBytes.readFloat();
	        return mtx_raw;
	    };
	    AWDParser.prototype.parseMatrix43RawData = function () {
	        var mtx_raw = new Float32Array(16);
	        mtx_raw[0] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[1] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[2] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[3] = 0.0;
	        mtx_raw[4] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[5] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[6] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[7] = 0.0;
	        mtx_raw[8] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[9] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[10] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[11] = 0.0;
	        mtx_raw[12] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[13] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[14] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[15] = 1.0;
	        //TODO: fix max exporter to remove NaN values in joint 0 inverse bind pose
	        if (isNaN(mtx_raw[0])) {
	            mtx_raw[0] = 1;
	            mtx_raw[1] = 0;
	            mtx_raw[2] = 0;
	            mtx_raw[4] = 0;
	            mtx_raw[5] = 1;
	            mtx_raw[6] = 0;
	            mtx_raw[8] = 0;
	            mtx_raw[9] = 0;
	            mtx_raw[10] = 1;
	            mtx_raw[12] = 0;
	            mtx_raw[13] = 0;
	            mtx_raw[14] = 0;
	        }
	        return mtx_raw;
	    };
	    AWDParser.COMPRESSIONMODE_LZMA = "lzma";
	    AWDParser.UNCOMPRESSED = 0;
	    AWDParser.DEFLATE = 1;
	    AWDParser.LZMA = 2;
	    AWDParser.INT8 = 1;
	    AWDParser.INT16 = 2;
	    AWDParser.INT32 = 3;
	    AWDParser.UINT8 = 4;
	    AWDParser.UINT16 = 5;
	    AWDParser.UINT32 = 6;
	    AWDParser.FLOAT32 = 7;
	    AWDParser.FLOAT64 = 8;
	    AWDParser.BOOL = 21;
	    AWDParser.COLOR = 22;
	    AWDParser.BADDR = 23;
	    AWDParser.AWDSTRING = 31;
	    AWDParser.AWDBYTEARRAY = 32;
	    AWDParser.VECTOR2x1 = 41;
	    AWDParser.VECTOR3x1 = 42;
	    AWDParser.VECTOR4x1 = 43;
	    AWDParser.MTX3x2 = 44;
	    AWDParser.MTX3x3 = 45;
	    AWDParser.MTX4x3 = 46;
	    AWDParser.MTX4x4 = 47;
	    AWDParser.GEO_NUMBER = 48;
	    AWDParser.MATRIX_NUMBER = 49;
	    AWDParser.PROPERTY_NUMBER = 50;
	    AWDParser.textFormatProperties = {
	        1: AWDParser.UINT16,
	        2: AWDParser.FLOAT32,
	        3: AWDParser.UINT8,
	        4: AWDParser.UINT8,
	        5: AWDParser.UINT8,
	        6: AWDParser.UINT8,
	        7: AWDParser.FLOAT32,
	        8: AWDParser.FLOAT32,
	        9: AWDParser.FLOAT32,
	        10: AWDParser.FLOAT32 }; //line spacing
	    AWDParser.textFieldProperties = {
	        1: AWDParser.BOOL,
	        3: AWDParser.BOOL,
	        4: AWDParser.BOOL,
	        5: AWDParser.BOOL,
	        7: AWDParser.UINT8,
	        8: AWDParser.UINT8,
	        9: AWDParser.UINT8 };
	    AWDParser.textFieldTypes = ["static", "dynamic", "input", "input"];
	    AWDParser.movieClipProperties = {
	        1: AWDParser.FLOAT32,
	        2: AWDParser.UINT16,
	        3: AWDParser.UINT8 }; // scripting-language right now its always as2
	    AWDParser.graphicsProperties = {
	        1: AWDParser.GEO_NUMBER,
	        2: AWDParser.GEO_NUMBER };
	    AWDParser.elementsProperties = {
	        1: AWDParser.GEO_NUMBER,
	        2: AWDParser.GEO_NUMBER };
	    AWDParser.primitiveProperties = {
	        101: AWDParser.GEO_NUMBER,
	        102: AWDParser.GEO_NUMBER,
	        103: AWDParser.GEO_NUMBER,
	        110: AWDParser.GEO_NUMBER,
	        111: AWDParser.GEO_NUMBER,
	        301: AWDParser.UINT16,
	        302: AWDParser.UINT16,
	        303: AWDParser.UINT16,
	        701: AWDParser.BOOL,
	        702: AWDParser.BOOL,
	        703: AWDParser.BOOL,
	        704: AWDParser.BOOL };
	    AWDParser.primitiveTypes = ["Unsupported Type-ID", "PrimitivePlanePrefab", "PrimitiveCubePrefab", "PrimitiveSpherePrefab", "PrimitiveCylinderPrefab", "PrimitivesConePrefab", "PrimitivesCapsulePrefab", "PrimitivesTorusPrefab"];
	    AWDParser.containerProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    AWDParser.spriteInstanceProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8,
	        5: AWDParser.BOOL };
	    AWDParser.lightProperties = {
	        1: AWDParser.PROPERTY_NUMBER,
	        2: AWDParser.PROPERTY_NUMBER,
	        3: AWDParser.COLOR,
	        4: AWDParser.PROPERTY_NUMBER,
	        5: AWDParser.PROPERTY_NUMBER,
	        6: AWDParser.BOOL,
	        7: AWDParser.COLOR,
	        8: AWDParser.PROPERTY_NUMBER,
	        9: AWDParser.UINT8,
	        10: AWDParser.UINT8,
	        11: AWDParser.PROPERTY_NUMBER,
	        12: AWDParser.UINT16,
	        21: AWDParser.MATRIX_NUMBER,
	        22: AWDParser.MATRIX_NUMBER,
	        23: AWDParser.MATRIX_NUMBER };
	    AWDParser.cameraProperties = {
	        101: AWDParser.PROPERTY_NUMBER,
	        102: AWDParser.PROPERTY_NUMBER,
	        103: AWDParser.PROPERTY_NUMBER,
	        104: AWDParser.PROPERTY_NUMBER };
	    AWDParser.cameraPivotProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
	    AWDParser.materialProperties = {
	        1: AWDParser.INT32,
	        2: AWDParser.BADDR,
	        10: AWDParser.PROPERTY_NUMBER,
	        11: AWDParser.BOOL,
	        12: AWDParser.PROPERTY_NUMBER,
	        13: AWDParser.BOOL };
	    AWDParser.material_v1Properties = { 1: AWDParser.UINT32,
	        2: AWDParser.BADDR,
	        3: AWDParser.BADDR,
	        4: AWDParser.UINT8,
	        5: AWDParser.BOOL,
	        6: AWDParser.BOOL,
	        7: AWDParser.BOOL,
	        8: AWDParser.BOOL,
	        9: AWDParser.UINT8,
	        10: AWDParser.PROPERTY_NUMBER,
	        11: AWDParser.BOOL,
	        12: AWDParser.PROPERTY_NUMBER,
	        13: AWDParser.BOOL,
	        15: AWDParser.PROPERTY_NUMBER,
	        16: AWDParser.UINT32,
	        17: AWDParser.BADDR,
	        18: AWDParser.PROPERTY_NUMBER,
	        19: AWDParser.PROPERTY_NUMBER,
	        20: AWDParser.UINT32,
	        21: AWDParser.BADDR,
	        22: AWDParser.BADDR };
	    AWDParser.method_v1Properties = {
	        1: AWDParser.BADDR,
	        2: AWDParser.BADDR,
	        3: AWDParser.BADDR,
	        101: AWDParser.PROPERTY_NUMBER,
	        102: AWDParser.PROPERTY_NUMBER,
	        103: AWDParser.PROPERTY_NUMBER,
	        201: AWDParser.UINT32,
	        202: AWDParser.UINT32,
	        301: AWDParser.UINT16,
	        302: AWDParser.UINT16,
	        401: AWDParser.UINT8,
	        402: AWDParser.UINT8,
	        601: AWDParser.COLOR,
	        602: AWDParser.COLOR,
	        701: AWDParser.BOOL,
	        702: AWDParser.BOOL,
	        801: AWDParser.MTX4x4 };
	    AWDParser.commandProperties = {
	        1: AWDParser.BADDR };
	    AWDParser.targetProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    AWDParser.metaDataProperties = {
	        1: AWDParser.UINT32,
	        2: AWDParser.AWDSTRING,
	        3: AWDParser.AWDSTRING,
	        4: AWDParser.AWDSTRING,
	        5: AWDParser.AWDSTRING };
	    AWDParser.vertexAnimationSetProperties = {
	        1: AWDParser.UINT16 };
	    AWDParser.animatorSetProperties = { 1: AWDParser.BADDR };
	    return AWDParser;
	}(ParserBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AWDParser;
	var AWDProperties = (function () {
	    function AWDProperties() {
	    }
	    AWDProperties.prototype.set = function (key, value) {
	        this[key] = value;
	    };
	    AWDProperties.prototype.get = function (key, fallback) {
	        return (this[key] || fallback);
	    };
	    return AWDProperties;
	}());
	/**
	 *
	 */
	var BitFlags = (function () {
	    function BitFlags() {
	    }
	    BitFlags.test = function (flags, testFlag) {
	        return (flags & testFlag) == testFlag;
	    };
	    BitFlags.FLAG1 = 1;
	    BitFlags.FLAG2 = 2;
	    BitFlags.FLAG3 = 4;
	    BitFlags.FLAG4 = 8;
	    BitFlags.FLAG5 = 16;
	    BitFlags.FLAG6 = 32;
	    BitFlags.FLAG7 = 64;
	    BitFlags.FLAG8 = 128;
	    BitFlags.FLAG9 = 256;
	    BitFlags.FLAG10 = 512;
	    BitFlags.FLAG11 = 1024;
	    BitFlags.FLAG12 = 2048;
	    BitFlags.FLAG13 = 4096;
	    BitFlags.FLAG14 = 8192;
	    BitFlags.FLAG15 = 16384;
	    BitFlags.FLAG16 = 32768;
	    return BitFlags;
	}());


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float2Attributes = (function (_super) {
	    __extends(Float2Attributes, _super);
	    function Float2Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 2, attributesBufferLength);
	    }
	    Object.defineProperty(Float2Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float2Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float2Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float2Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float2Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float2Attributes(attributesBuffer));
	    };
	    Float2Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float2Attributes.assetType = "[attributes Float2Attributes]";
	    return Float2Attributes;
	}(AttributesView_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Float2Attributes;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetEvent_1 = __webpack_require__(1);
	var EventDispatcher_1 = __webpack_require__(12);
	var ParserEvent_1 = __webpack_require__(14);
	var TimerEvent_1 = __webpack_require__(188);
	var ParserUtils_1 = __webpack_require__(189);
	var ResourceDependency_1 = __webpack_require__(15);
	var ImageUtils_1 = __webpack_require__(92);
	var Timer_1 = __webpack_require__(190);
	var getTimer_1 = __webpack_require__(39);
	/**
	 * <code>ParserBase</code> provides an abstract base class for objects that convert blocks of data to data structures
	 * supported by away.
	 *
	 * If used by <code>Loader</code> to automatically determine the parser type, two public static methods should
	 * be implemented, with the following signatures:
	 *
	 * <code>public static supportsType(extension : string) : boolean</code>
	 * Indicates whether or not a given file extension is supported by the parser.
	 *
	 * <code>public static supportsData(data : *) : boolean</code>
	 * Tests whether a data block can be parsed by the parser.
	 *
	 * Furthermore, for any concrete subtype, the method <code>initHandle</code> should be overridden to immediately
	 * create the object that will contain the parsed data. This allows <code>ResourceManager</code> to return an object
	 * handle regardless of whether the object was loaded or not.
	 *
	 * @see Loader
	 */
	var ParserBase = (function (_super) {
	    __extends(ParserBase, _super);
	    /**
	     * Creates a new ParserBase object
	     * @param format The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>, and should be provided by the concrete subtype.
	     *
	     * @see away.loading.parsers.ParserDataFormat
	     */
	    function ParserBase(format) {
	        var _this = this;
	        _super.call(this);
	        this._materialMode = 0;
	        this._dataFormat = format;
	        this._dependencies = new Array();
	        this._pOnIntervalDelegate = function (event) { return _this._pOnInterval(event); };
	    }
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    // TODO: add error checking for the following ( could cause a problem if this function is not implemented )
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    // Needs to be implemented in all Parsers (
	    //<code>public static supportsType(extension : string) : boolean</code>
	    //* Indicates whether or not a given file extension is supported by the parser.
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    ParserBase.supportsType = function (extension) {
	        throw new AbstractMethodError_1.default();
	    };
	    Object.defineProperty(ParserBase.prototype, "content", {
	        /* Protected */
	        get: function () {
	            return this._pContent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Validates a bitmapData loaded before assigning to a default BitmapMaterial
	     */
	    ParserBase.prototype.isBitmapImage2DValid = function (bitmapImage2D) {
	        var isValid = ImageUtils_1.default.isImage2DValid(bitmapImage2D);
	        if (!isValid) {
	            console.log(">> Bitmap loaded is not having power of 2 dimensions or is higher than 2048");
	        }
	        return isValid;
	    };
	    Object.defineProperty(ParserBase.prototype, "parsingFailure", {
	        get: function () {
	            return this._parsingFailure;
	        },
	        set: function (b) {
	            this._parsingFailure = b;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "parsingPaused", {
	        get: function () {
	            return this._parsingPaused;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "parsingComplete", {
	        get: function () {
	            return this._parsingComplete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "materialMode", {
	        get: function () {
	            return this._materialMode;
	        },
	        set: function (newMaterialMode) {
	            this._materialMode = newMaterialMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "data", {
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "dataFormat", {
	        /**
	         * The data format of the file data to be parsed. Options are <code>URLLoaderDataFormat.BINARY</code>, <code>URLLoaderDataFormat.ARRAY_BUFFER</code>, <code>URLLoaderDataFormat.BLOB</code>, <code>URLLoaderDataFormat.VARIABLES</code> or <code>URLLoaderDataFormat.TEXT</code>.
	         */
	        get: function () {
	            return this._dataFormat;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Parse data (possibly containing bytearry, plain text or BitmapAsset) asynchronously, meaning that
	     * the parser will periodically stop parsing so that the AVM may proceed to the
	     * next frame.
	     *
	     * @param data The untyped data object in which the loaded data resides.
	     * @param frameLimit number of milliseconds of parsing allowed per frame. The
	     * actual time spent on a frame can exceed this number since time-checks can
	     * only be performed between logical sections of the parsing procedure.
	     */
	    ParserBase.prototype.parseAsync = function (data, frameLimit) {
	        if (frameLimit === void 0) { frameLimit = 30; }
	        this._data = data;
	        this._pStartParsing(frameLimit);
	    };
	    Object.defineProperty(ParserBase.prototype, "dependencies", {
	        /**
	         * A list of dependencies that need to be loaded and resolved for the object being parsed.
	         */
	        get: function () {
	            return this._dependencies;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Resolve a dependency when it's loaded. For example, a dependency containing an ImageResource would be assigned
	     * to a Mesh instance as a BitmapMaterial, a scene graph object would be added to its intended parent. The
	     * dependency should be a member of the dependencies property.
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependency = function (resourceDependency) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Resolve a dependency loading failure. Used by parser to eventually provide a default map
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Resolve a dependency name
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependencyName = function (resourceDependency, asset) {
	        return asset.name;
	    };
	    ParserBase.prototype._iResumeParsing = function () {
	        this._parsingPaused = false;
	        if (this._timer)
	            this._timer.start();
	        //get started!
	        if (!this._isParsing)
	            this._pOnInterval();
	    };
	    ParserBase.prototype._pFinalizeAsset = function (asset, name) {
	        if (name === void 0) { name = null; }
	        var type_event;
	        var type_name;
	        if (name != null)
	            asset.name = name;
	        // If the asset has no name, give it
	        // a per-type default name.
	        if (!asset.name)
	            asset.name = asset.assetType;
	        this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.ASSET_COMPLETE, asset));
	    };
	    /**
	     * Parse the next block of data.
	     * @return Whether or not more data needs to be parsed. Can be <code>ParserBase.ParserBase.PARSING_DONE</code> or
	     * <code>ParserBase.ParserBase.MORE_TO_PARSE</code>.
	     */
	    ParserBase.prototype._pProceedParsing = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    ParserBase.prototype._pDieWithError = function (message) {
	        if (message === void 0) { message = 'Unknown parsing error'; }
	        if (this._timer) {
	            this._timer.removeEventListener(TimerEvent_1.default.TIMER, this._pOnIntervalDelegate);
	            this._timer.stop();
	            this._timer = null;
	        }
	        this.dispatchEvent(new ParserEvent_1.default(ParserEvent_1.default.PARSE_ERROR, message));
	    };
	    ParserBase.prototype._pAddDependency = function (id, req, retrieveAsRawData, data, suppressErrorEvents, sub_id) {
	        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
	        if (data === void 0) { data = null; }
	        if (suppressErrorEvents === void 0) { suppressErrorEvents = false; }
	        if (sub_id === void 0) { sub_id = 0; }
	        var dependency = new ResourceDependency_1.default(id, req, data, null, this, retrieveAsRawData, suppressErrorEvents, sub_id);
	        this._dependencies.push(dependency);
	        return dependency;
	    };
	    ParserBase.prototype._pPauseAndRetrieveDependencies = function () {
	        this._pPauseParsing();
	        this.dispatchEvent(new ParserEvent_1.default(ParserEvent_1.default.READY_FOR_DEPENDENCIES));
	    };
	    ParserBase.prototype._pPauseParsing = function () {
	        if (this._timer)
	            this._timer.stop();
	        this._parsingPaused = true;
	    };
	    /**
	     * Tests whether or not there is still time left for parsing within the maximum allowed time frame per session.
	     * @return True if there is still time left, false if the maximum allotted time was exceeded and parsing should be interrupted.
	     */
	    ParserBase.prototype._pHasTime = function () {
	        return ((getTimer_1.default() - this._lastFrameTime) < this._frameLimit);
	    };
	    /**
	     * Called when the parsing pause interval has passed and parsing can proceed.
	     */
	    ParserBase.prototype._pOnInterval = function (event) {
	        if (event === void 0) { event = null; }
	        this._lastFrameTime = getTimer_1.default();
	        this._isParsing = true;
	        if (this._pProceedParsing() && !this._parsingFailure)
	            this._pFinishParsing();
	        this._isParsing = false;
	    };
	    /**
	     * Initializes the parsing of data.
	     * @param frameLimit The maximum duration of a parsing session.
	     */
	    ParserBase.prototype._pStartParsing = function (frameLimit) {
	        this._frameLimit = frameLimit;
	        this._timer = new Timer_1.default(this._frameLimit, 0);
	        this._timer.addEventListener(TimerEvent_1.default.TIMER, this._pOnIntervalDelegate);
	        this._timer.start();
	        //get started!
	        this._pOnInterval();
	    };
	    /**
	     * Finish parsing the data.
	     */
	    ParserBase.prototype._pFinishParsing = function () {
	        if (this._timer) {
	            this._timer.removeEventListener(TimerEvent_1.default.TIMER, this._pOnIntervalDelegate);
	            this._timer.stop();
	        }
	        this._timer = null;
	        this._parsingComplete = true;
	        this._isParsing = false;
	        this.dispatchEvent(new ParserEvent_1.default(ParserEvent_1.default.PARSE_COMPLETE));
	    };
	    /**
	     *
	     * @returns {string}
	     * @private
	     */
	    ParserBase.prototype._pGetTextData = function () {
	        return ParserUtils_1.default.toString(this._data);
	    };
	    /**
	     *
	     * @returns {ByteArray}
	     * @private
	     */
	    ParserBase.prototype._pGetByteData = function () {
	        return ParserUtils_1.default.toByteArray(this._data);
	    };
	    /**
	     *
	     * @returns {any}
	     * @private
	     */
	    ParserBase.prototype._pGetData = function () {
	        return this._data;
	    };
	    /**
	     * Returned by <code>proceedParsing</code> to indicate no more parsing is needed.
	     */
	    ParserBase.PARSING_DONE = true;
	    /* Protected */
	    /**
	     * Returned by <code>proceedParsing</code> to indicate more parsing is needed, allowing asynchronous parsing.
	     */
	    ParserBase.MORE_TO_PARSE = false;
	    return ParserBase;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ParserBase;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var TimerEvent = (function (_super) {
	    __extends(TimerEvent, _super);
	    function TimerEvent(type) {
	        _super.call(this, type);
	    }
	    /**
	     *
	     */
	    TimerEvent.TIMER = "timer";
	    /**
	     *
	     */
	    TimerEvent.TIMER_COMPLETE = "timerComplete";
	    return TimerEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TimerEvent;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(89);
	var ByteArray_1 = __webpack_require__(107);
	var ParserUtils = (function () {
	    function ParserUtils() {
	    }
	    ParserUtils.arrayBufferToBase64 = function (data, mimeType) {
	        var byteStr = '';
	        var bytes = new Uint8Array(data);
	        var len = bytes.byteLength;
	        for (var i = 0; i < len; i++)
	            byteStr += String.fromCharCode(bytes[i]);
	        var base64Image = window.btoa(byteStr);
	        return 'data:' + mimeType + ';base64,' + base64Image;
	    };
	    ParserUtils.arrayBufferToAudio = function (data, fileType) {
	        var str = ParserUtils.arrayBufferToBase64(data, 'audio/' + fileType);
	        var audio = new Audio();
	        audio.src = str;
	        return audio;
	    };
	    /**
	     * Converts an ArrayBuffer to a base64 string
	     *
	     * @param image data as a ByteArray
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.arrayBufferToImage = function (data) {
	        var str = ParserUtils.arrayBufferToBase64(data, 'image/png');
	        var img = new Image();
	        img.src = str;
	        return img;
	    };
	    /**
	     * Converts an ByteArray to an Image - returns an HTMLImageElement
	     *
	     * @param image data as a ByteArray
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.byteArrayToImage = function (data) {
	        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'image/png');
	        var img = new Image();
	        img.src = str;
	        return img;
	    };
	    ParserUtils.byteArrayToAudio = function (data, filetype) {
	        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'audio/' + filetype);
	        var audio = new Audio();
	        audio.src = str;
	        return audio;
	    };
	    /**
	     * Converts an Blob to an Image - returns an HTMLImageElement
	     *
	     * @param image data as a Blob
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.blobToImage = function (data) {
	        var URLObj = window['URL'] || window['webkitURL'];
	        var src = URLObj.createObjectURL(data);
	        var img = new Image();
	        img.src = src;
	        return img;
	    };
	    /**
	     * Converts an Blob to audio - returns an HTMLAudioElement
	     *
	     * @param audio data as a Blob
	     *
	     * @return HTMLAudioElement
	     *
	     */
	    ParserUtils.blobToAudio = function (data) {
	        var URLObj = window['URL'] || window['webkitURL'];
	        var src = URLObj.createObjectURL(data);
	        var img = new Audio();
	        img.src = src;
	        return img;
	    };
	    /**
	     *
	     */
	    ParserUtils.imageToBitmapImage2D = function (img, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        var bitmapData = new BitmapImage2D_1.default(img.width, img.height, true, null, powerOfTwo);
	        bitmapData.draw(img);
	        return bitmapData;
	    };
	    /**
	     * Returns a object as ByteArray, if possible.
	     *
	     * @param data The object to return as ByteArray
	     *
	     * @return The ByteArray or null
	     *
	     */
	    ParserUtils.toByteArray = function (data) {
	        var b = new ByteArray_1.default();
	        b.setArrayBuffer(data);
	        return b;
	    };
	    /**
	     * Returns a object as String, if possible.
	     *
	     * @param data The object to return as String
	     * @param length The length of the returned String
	     *
	     * @return The String or null
	     *
	     */
	    ParserUtils.toString = function (data, length) {
	        if (length === void 0) { length = 0; }
	        if (typeof data === 'string') {
	            var s = data;
	            if (s['substr'] != null)
	                return s.substr(0, s.length);
	        }
	        if (data instanceof ByteArray_1.default) {
	            var ba = data;
	            ba.position = 0;
	            return ba.readUTFBytes(Math.min(ba.getBytesAvailable(), length));
	        }
	        return null;
	        /*
	         var ba:ByteArray;

	         length ||= uint.MAX_VALUE;

	         if (data is String)
	         return String(data).substr(0, length);

	         ba = toByteArray(data);
	         if (ba) {
	         ba.position = 0;
	         return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
	         }

	         return null;

	         */
	    };
	    return ParserUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ParserUtils;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	var EventDispatcher_1 = __webpack_require__(12);
	var TimerEvent_1 = __webpack_require__(188);
	var Timer = (function (_super) {
	    __extends(Timer, _super);
	    function Timer(delay, repeatCount) {
	        if (repeatCount === void 0) { repeatCount = 0; }
	        _super.call(this);
	        this._repeatCount = 0;
	        this._currentCount = 0;
	        this._running = false;
	        this._delay = delay;
	        this._repeatCount = repeatCount;
	        if (isNaN(delay) || delay < 0)
	            throw new ErrorBase_1.default("Delay is negative or not a number");
	    }
	    Object.defineProperty(Timer.prototype, "currentCount", {
	        get: function () {
	            return this._currentCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Timer.prototype, "delay", {
	        get: function () {
	            return this._delay;
	        },
	        set: function (value) {
	            this._delay = value;
	            if (this._running) {
	                this.stop();
	                this.start();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Timer.prototype, "repeatCount", {
	        get: function () {
	            return this._repeatCount;
	        },
	        set: function (value) {
	            this._repeatCount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timer.prototype.reset = function () {
	        if (this._running)
	            this.stop();
	        this._currentCount = 0;
	    };
	    Object.defineProperty(Timer.prototype, "running", {
	        get: function () {
	            return this._running;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timer.prototype.start = function () {
	        var _this = this;
	        this._running = true;
	        clearInterval(this._iid);
	        this._iid = setInterval(function () { return _this.tick(); }, this._delay);
	    };
	    Timer.prototype.stop = function () {
	        this._running = false;
	        clearInterval(this._iid);
	    };
	    Timer.prototype.tick = function () {
	        this._currentCount++;
	        if ((this._repeatCount > 0) && this._currentCount >= this._repeatCount) {
	            this.stop();
	            this.dispatchEvent(new TimerEvent_1.default(TimerEvent_1.default.TIMER));
	            this.dispatchEvent(new TimerEvent_1.default(TimerEvent_1.default.TIMER_COMPLETE));
	        }
	        else {
	            this.dispatchEvent(new TimerEvent_1.default(TimerEvent_1.default.TIMER));
	        }
	    };
	    return Timer;
	}(EventDispatcher_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Timer;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Vector3D_1 = __webpack_require__(30);
	var ProjectionBase_1 = __webpack_require__(34);
	var OrthographicOffCenterProjection = (function (_super) {
	    __extends(OrthographicOffCenterProjection, _super);
	    function OrthographicOffCenterProjection(minX, maxX, minY, maxY) {
	        _super.call(this);
	        this._minX = minX;
	        this._maxX = maxX;
	        this._minY = minY;
	        this._maxY = maxY;
	    }
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minX", {
	        get: function () {
	            return this._minX;
	        },
	        set: function (value) {
	            this._minX = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxX", {
	        get: function () {
	            return this._maxX;
	        },
	        set: function (value) {
	            this._maxX = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minY", {
	        get: function () {
	            return this._minY;
	        },
	        set: function (value) {
	            this._minY = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxY", {
	        get: function () {
	            return this._maxY;
	        },
	        set: function (value) {
	            this._maxY = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    OrthographicOffCenterProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.default(nX, -nY, sZ, 1.0);
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    OrthographicOffCenterProjection.prototype.clone = function () {
	        var clone = new OrthographicOffCenterProjection(this._minX, this._maxX, this._minY, this._maxY);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        return clone;
	    };
	    //@override
	    OrthographicOffCenterProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        var w = 1 / (this._maxX - this._minX);
	        var h = 1 / (this._maxY - this._minY);
	        var d = 1 / (this._pFar - this._pNear);
	        raw[0] = 2 * w;
	        raw[5] = 2 * h;
	        raw[10] = d;
	        raw[12] = -(this._maxX + this._minX) * w;
	        raw[13] = -(this._maxY + this._minY) * h;
	        raw[14] = -this._pNear * d;
	        raw[15] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._minX;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._maxX;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._minY;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._maxY;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrixInvalid = false;
	    };
	    return OrthographicOffCenterProjection;
	}(ProjectionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OrthographicOffCenterProjection;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float3Attributes_1 = __webpack_require__(81);
	var Float2Attributes_1 = __webpack_require__(186);
	var ElementsBase_1 = __webpack_require__(163);
	var ElementsUtils_1 = __webpack_require__(79);
	/**
	 * @class away.base.TriangleElements
	 */
	var TriangleElements = (function (_super) {
	    __extends(TriangleElements, _super);
	    function TriangleElements() {
	        _super.apply(this, arguments);
	        this._numVertices = 0;
	        this._faceNormalsDirty = true;
	        this._faceTangentsDirty = true;
	        this._autoDeriveNormals = true;
	        this._autoDeriveTangents = true;
	        //used for hittesting geometry
	        this.cells = new Array();
	        this.lastCollisionIndex = -1;
	    }
	    Object.defineProperty(TriangleElements.prototype, "assetType", {
	        get: function () {
	            return TriangleElements.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "useCondensedIndices", {
	        /**
	         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
	         * by condensing the number of joint index values required per sprite. Only applicable to
	         * skeleton animations that utilise more than one sprite object. Defaults to false.
	         */
	        get: function () {
	            return this._useCondensedIndices;
	        },
	        set: function (value) {
	            if (this._useCondensedIndices == value)
	                return;
	            this._useCondensedIndices = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointsPerVertex", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointsPerVertex;
	        },
	        set: function (value) {
	            if (this._jointsPerVertex == value)
	                return;
	            this._jointsPerVertex = value;
	            if (this._jointIndices)
	                this._jointIndices.dimensions = this._jointsPerVertex;
	            if (this._jointWeights)
	                this._jointWeights.dimensions = this._jointsPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "autoDeriveNormals", {
	        /**
	         * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
	         * explicitly.
	         */
	        get: function () {
	            return this._autoDeriveNormals;
	        },
	        set: function (value) {
	            if (this._autoDeriveNormals == value)
	                return;
	            this._autoDeriveNormals = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "autoDeriveTangents", {
	        /**
	         * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
	         * explicitly.
	         */
	        get: function () {
	            return this._autoDeriveTangents;
	        },
	        set: function (value) {
	            if (this._autoDeriveTangents == value)
	                return;
	            this._autoDeriveTangents = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "positions", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._positions)
	                this.setPositions(new Float3Attributes_1.default(this._concatenatedBuffer));
	            return this._positions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "normals", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._normals || this._verticesDirty[this._normals.id])
	                this.setNormals(this._normals);
	            return this._normals;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "tangents", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._tangents || this._verticesDirty[this._tangents.id])
	                this.setTangents(this._tangents);
	            return this._tangents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "faceNormals", {
	        /**
	         * The raw data of the face normals, in the same order as the faces are listed in the index list.
	         */
	        get: function () {
	            if (this._faceNormalsDirty)
	                this.updateFaceNormals();
	            return this._faceNormals;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "faceTangents", {
	        /**
	         * The raw data of the face tangets, in the same order as the faces are listed in the index list.
	         */
	        get: function () {
	            if (this._faceTangentsDirty)
	                this.updateFaceTangents();
	            return this._faceTangents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "uvs", {
	        /**
	         *
	         */
	        get: function () {
	            return this._uvs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointIndices", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointWeights", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointWeights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "condensedIndexLookUp", {
	        get: function () {
	            return this._condensedIndexLookUp;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TriangleElements.prototype.getBoxBounds = function (target) {
	        if (target === void 0) { target = null; }
	        return ElementsUtils_1.default.getTriangleGraphicsBoxBounds(this.positions, target, this._numVertices);
	    };
	    TriangleElements.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        return ElementsUtils_1.default.getTriangleGraphicsSphereBounds(this.positions, center, target, this._numVertices);
	    };
	    TriangleElements.prototype.hitTestPoint = function (x, y, z) {
	        return true;
	    };
	    TriangleElements.prototype.setPositions = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._positions)
	            return;
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._positions);
	            this._positions = values;
	        }
	        else if (values) {
	            if (!this._positions)
	                this._positions = new Float3Attributes_1.default(this._concatenatedBuffer);
	            this._positions.set(values, offset);
	        }
	        else {
	            this.clearVertices(this._positions);
	            this._positions = new Float3Attributes_1.default(this._concatenatedBuffer); //positions cannot be null
	        }
	        this._numVertices = this._positions.count;
	        if (this._autoDeriveNormals)
	            this.invalidateVertices(this._normals);
	        if (this._autoDeriveTangents)
	            this.invalidateVertices(this._tangents);
	        this.invalidateVertices(this._positions);
	        this._verticesDirty[this._positions.id] = false;
	    };
	    TriangleElements.prototype.setNormals = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (!this._autoDeriveNormals) {
	            if (values == this._normals)
	                return;
	            if (values instanceof Float3Attributes_1.default) {
	                this.clearVertices(this._normals);
	                this._normals = values;
	            }
	            else if (values) {
	                if (!this._normals)
	                    this._normals = new Float3Attributes_1.default(this._concatenatedBuffer);
	                this._normals.set(values, offset);
	            }
	            else if (this._normals) {
	                this.clearVertices(this._normals);
	                this._normals = null;
	                return;
	            }
	        }
	        else {
	            this._normals = ElementsUtils_1.default.generateNormals(this.indices, this.faceNormals, this._normals, this._concatenatedBuffer);
	        }
	        this.invalidateVertices(this._normals);
	        this._verticesDirty[this._normals.id] = false;
	    };
	    TriangleElements.prototype.setTangents = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (!this._autoDeriveTangents) {
	            if (values == this._tangents)
	                return;
	            if (values instanceof Float3Attributes_1.default) {
	                this.clearVertices(this._tangents);
	                this._tangents = values;
	            }
	            else if (values) {
	                if (!this._tangents)
	                    this._tangents = new Float3Attributes_1.default(this._concatenatedBuffer);
	                this._tangents.set(values, offset);
	            }
	            else if (this._tangents) {
	                this.clearVertices(this._tangents);
	                this._tangents = null;
	                return;
	            }
	        }
	        else {
	            this._tangents = ElementsUtils_1.default.generateTangents(this.indices, this.faceTangents, this.faceNormals, this._tangents, this._concatenatedBuffer);
	        }
	        this.invalidateVertices(this._tangents);
	        this._verticesDirty[this._tangents.id] = false;
	    };
	    TriangleElements.prototype.setUVs = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._uvs)
	            return;
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._uvs);
	            this._uvs = values;
	        }
	        else if (values) {
	            if (!this._uvs)
	                this._uvs = new Float2Attributes_1.default(this._concatenatedBuffer);
	            this._uvs.set(values, offset);
	        }
	        else if (this._uvs) {
	            this.clearVertices(this._uvs);
	            this._uvs = null;
	            return;
	        }
	        this.invalidateVertices(this._uvs);
	        this._verticesDirty[this._uvs.id] = false;
	    };
	    TriangleElements.prototype.setJointIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._jointIndices)
	            return;
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._jointIndices);
	            this._jointIndices = values;
	        }
	        else if (values) {
	            if (!this._jointIndices)
	                this._jointIndices = new AttributesView_1.default(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
	            if (this._useCondensedIndices) {
	                var i = 0;
	                var oldIndex;
	                var newIndex = 0;
	                var dic = new Object();
	                this._condensedIndexLookUp = new Array();
	                while (i < values.length) {
	                    oldIndex = values[i];
	                    // if we encounter a new index, assign it a new condensed index
	                    if (dic[oldIndex] == undefined) {
	                        dic[oldIndex] = newIndex;
	                        this._condensedIndexLookUp[newIndex++] = oldIndex;
	                    }
	                    //reset value to dictionary lookup
	                    values[i++] = dic[oldIndex];
	                }
	            }
	            this._jointIndices.set(values, offset);
	        }
	        else if (this._jointIndices) {
	            this.clearVertices(this._jointIndices);
	            this._jointIndices = null;
	            return;
	        }
	        this.invalidateVertices(this._jointIndices);
	        this._verticesDirty[this._jointIndices.id] = false;
	    };
	    TriangleElements.prototype.setJointWeights = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._jointWeights)
	            return;
	        if (values instanceof AttributesView_1.default) {
	            this.clearVertices(this._jointWeights);
	            this._jointWeights = values;
	        }
	        else if (values) {
	            if (!this._jointWeights)
	                this._jointWeights = new AttributesView_1.default(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
	            this._jointWeights.set(values, offset);
	        }
	        else if (this._jointWeights) {
	            this.clearVertices(this._jointWeights);
	            this._jointWeights = null;
	            return;
	        }
	        this.invalidateVertices(this._jointWeights);
	        this._verticesDirty[this._jointWeights.id] = false;
	    };
	    /**
	     *
	     */
	    TriangleElements.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._positions) {
	            this._positions.dispose();
	            this._positions = null;
	        }
	        if (this._normals) {
	            this._normals.dispose();
	            this._normals = null;
	        }
	        if (this._tangents) {
	            this._tangents.dispose();
	            this._tangents = null;
	        }
	        if (this._uvs) {
	            this._uvs.dispose();
	            this._uvs = null;
	        }
	        if (this._jointIndices) {
	            this._jointIndices.dispose();
	            this._jointIndices = null;
	        }
	        if (this._jointWeights) {
	            this._jointWeights.dispose();
	            this._jointWeights = null;
	        }
	        if (this._faceNormals) {
	            this._faceNormals.dispose();
	            this._faceNormals = null;
	        }
	        if (this._faceTangents) {
	            this._faceTangents.dispose();
	            this._faceTangents = null;
	        }
	    };
	    TriangleElements.prototype.setIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.setIndices.call(this, values, offset);
	        this._faceNormalsDirty = true;
	        this._faceTangentsDirty = true;
	        if (this._autoDeriveNormals)
	            this.invalidateVertices(this._normals);
	        if (this._autoDeriveTangents)
	            this.invalidateVertices(this._tangents);
	    };
	    TriangleElements.prototype.copyTo = function (elements) {
	        _super.prototype.copyTo.call(this, elements);
	        //temp disable auto derives
	        elements.autoDeriveNormals = false;
	        elements.autoDeriveTangents = false;
	        elements.setPositions(this.positions.clone());
	        if (this.normals)
	            elements.setNormals(this.normals.clone());
	        if (this.tangents)
	            elements.setTangents(this.tangents.clone());
	        if (this.uvs)
	            elements.setUVs(this.uvs.clone());
	        elements.jointsPerVertex = this._jointsPerVertex;
	        if (this.jointIndices)
	            elements.setJointIndices(this.jointIndices.clone());
	        if (this.jointWeights)
	            elements.setJointWeights(this.jointWeights.clone());
	        //return auto derives to cloned values
	        elements.autoDeriveNormals = this._autoDeriveNormals;
	        elements.autoDeriveTangents = this._autoDeriveTangents;
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    TriangleElements.prototype.clone = function () {
	        var clone = new TriangleElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
	        this.copyTo(clone);
	        return clone;
	    };
	    TriangleElements.prototype.scaleUV = function (scaleU, scaleV) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        if (this.uvs)
	            ElementsUtils_1.default.scaleUVs(scaleU, scaleV, this.uvs, this._numVertices);
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    TriangleElements.prototype.scale = function (scale) {
	        ElementsUtils_1.default.scale(scale, this.positions, this._numVertices);
	    };
	    TriangleElements.prototype.applyTransformation = function (transform) {
	        ElementsUtils_1.default.applyTransformation(transform, this.positions, this.normals, this.tangents, this._numVertices);
	    };
	    /**
	     * Updates the tangents for each face.
	     */
	    TriangleElements.prototype.updateFaceTangents = function () {
	        this._faceTangents = ElementsUtils_1.default.generateFaceTangents(this.indices, this.positions, this.uvs || this.positions, this._faceTangents, this.numElements);
	        this._faceTangentsDirty = false;
	    };
	    /**
	     * Updates the normals for each face.
	     */
	    TriangleElements.prototype.updateFaceNormals = function () {
	        this._faceNormals = ElementsUtils_1.default.generateFaceNormals(this.indices, this.positions, this._faceNormals, this.numElements);
	        this._faceNormalsDirty = false;
	    };
	    TriangleElements.prototype._iTestCollision = function (pickingCollider, material, pickingCollision) {
	        return pickingCollider.testTriangleCollision(this, material, pickingCollision);
	    };
	    TriangleElements.assetType = "[asset TriangleElements]";
	    return TriangleElements;
	}(ElementsBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TriangleElements;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Matrix3D_1 = __webpack_require__(28);
	var Vector3D_1 = __webpack_require__(30);
	var LightBase_1 = __webpack_require__(194);
	var HierarchicalProperties_1 = __webpack_require__(49);
	var BoundsType_1 = __webpack_require__(50);
	var DirectionalShadowMapper_1 = __webpack_require__(196);
	var DirectionalLight = (function (_super) {
	    __extends(DirectionalLight, _super);
	    function DirectionalLight(xDir, yDir, zDir) {
	        if (xDir === void 0) { xDir = 0; }
	        if (yDir === void 0) { yDir = -1; }
	        if (zDir === void 0) { zDir = 1; }
	        _super.call(this);
	        this._pAabbPoints = new Array(24);
	        this._pIsEntity = true;
	        this.direction = new Vector3D_1.default(xDir, yDir, zDir);
	        this._sceneDirection = new Vector3D_1.default();
	        //default bounds type
	        this._boundsType = BoundsType_1.default.NULL;
	    }
	    Object.defineProperty(DirectionalLight.prototype, "assetType", {
	        get: function () {
	            return DirectionalLight.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.default.SCENE_TRANSFORM)
	                this.pUpdateSceneTransform();
	            return this._sceneDirection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalLight.prototype, "direction", {
	        get: function () {
	            return this._direction;
	        },
	        set: function (value) {
	            this._direction = value;
	            if (!this._tmpLookAt)
	                this._tmpLookAt = new Vector3D_1.default();
	            this._tmpLookAt.x = this.x + this._direction.x;
	            this._tmpLookAt.y = this.y + this._direction.y;
	            this._tmpLookAt.z = this.z + this._direction.z;
	            this.lookAt(this._tmpLookAt);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    DirectionalLight.prototype.pUpdateSceneTransform = function () {
	        _super.prototype.pUpdateSceneTransform.call(this);
	        this.sceneTransform.copyColumnTo(2, this._sceneDirection);
	        this._sceneDirection.normalize();
	    };
	    //@override
	    DirectionalLight.prototype.pCreateShadowMapper = function () {
	        return new DirectionalShadowMapper_1.default();
	    };
	    //override
	    DirectionalLight.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        var m = new Matrix3D_1.default();
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this.inverseSceneTransform);
	        if (!this._projAABBPoints)
	            this._projAABBPoints = [];
	        m.transformVectors(this._pAabbPoints, this._projAABBPoints);
	        var xMin = Infinity, xMax = -Infinity;
	        var yMin = Infinity, yMax = -Infinity;
	        var zMin = Infinity, zMax = -Infinity;
	        var d;
	        for (var i = 0; i < 24;) {
	            d = this._projAABBPoints[i++];
	            if (d < xMin)
	                xMin = d;
	            if (d > xMax)
	                xMax = d;
	            d = this._projAABBPoints[i++];
	            if (d < yMin)
	                yMin = d;
	            if (d > yMax)
	                yMax = d;
	            d = this._projAABBPoints[i++];
	            if (d < zMin)
	                zMin = d;
	            if (d > zMax)
	                zMax = d;
	        }
	        var invXRange = 1 / (xMax - xMin);
	        var invYRange = 1 / (yMax - yMin);
	        var invZRange = 1 / (zMax - zMin);
	        raw[0] = 2 * invXRange;
	        raw[5] = 2 * invYRange;
	        raw[10] = invZRange;
	        raw[12] = -(xMax + xMin) * invXRange;
	        raw[13] = -(yMax + yMin) * invYRange;
	        raw[14] = -zMin * invZRange;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        raw[15] = 1;
	        if (!target)
	            target = new Matrix3D_1.default();
	        target.copyRawDataFrom(raw);
	        target.prepend(m);
	        return target;
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    DirectionalLight.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        //update points
	        var minX = this._pBoxBounds.x;
	        var minY = this._pBoxBounds.y - this._pBoxBounds.height;
	        var minZ = this._pBoxBounds.z;
	        var maxX = this._pBoxBounds.x + this._pBoxBounds.width;
	        var maxY = this._pBoxBounds.y;
	        var maxZ = this._pBoxBounds.z + this._pBoxBounds.depth;
	        this._pAabbPoints[0] = minX;
	        this._pAabbPoints[1] = minY;
	        this._pAabbPoints[2] = minZ;
	        this._pAabbPoints[3] = maxX;
	        this._pAabbPoints[4] = minY;
	        this._pAabbPoints[5] = minZ;
	        this._pAabbPoints[6] = minX;
	        this._pAabbPoints[7] = maxY;
	        this._pAabbPoints[8] = minZ;
	        this._pAabbPoints[9] = maxX;
	        this._pAabbPoints[10] = maxY;
	        this._pAabbPoints[11] = minZ;
	        this._pAabbPoints[12] = minX;
	        this._pAabbPoints[13] = minY;
	        this._pAabbPoints[14] = maxZ;
	        this._pAabbPoints[15] = maxX;
	        this._pAabbPoints[16] = minY;
	        this._pAabbPoints[17] = maxZ;
	        this._pAabbPoints[18] = minX;
	        this._pAabbPoints[19] = maxY;
	        this._pAabbPoints[20] = maxZ;
	        this._pAabbPoints[21] = maxX;
	        this._pAabbPoints[22] = maxY;
	        this._pAabbPoints[23] = maxZ;
	    };
	    DirectionalLight.assetType = "[light DirectionalLight]";
	    return DirectionalLight;
	}(LightBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectionalLight;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var DisplayObjectContainer_1 = __webpack_require__(43);
	var LightEvent_1 = __webpack_require__(195);
	var LightBase = (function (_super) {
	    __extends(LightBase, _super);
	    function LightBase() {
	        _super.call(this);
	        this._color = 0xffffff;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	        this._ambientColor = 0xffffff;
	        this._ambient = 0;
	        this._iAmbientR = 0;
	        this._iAmbientG = 0;
	        this._iAmbientB = 0;
	        this._specular = 1;
	        this._iSpecularR = 1;
	        this._iSpecularG = 1;
	        this._iSpecularB = 1;
	        this._diffuse = 1;
	        this._iDiffuseR = 1;
	        this._iDiffuseG = 1;
	        this._iDiffuseB = 1;
	        this._shadowsEnabled = false;
	    }
	    Object.defineProperty(LightBase.prototype, "shadowsEnabled", {
	        get: function () {
	            return this._shadowsEnabled;
	        },
	        set: function (value) {
	            if (this._shadowsEnabled == value)
	                return;
	            this._shadowsEnabled = value;
	            if (value) {
	                if (this._shadowMapper == null)
	                    this._shadowMapper = this.pCreateShadowMapper();
	                this._shadowMapper.light = this;
	            }
	            else {
	                this._shadowMapper.dispose();
	                this._shadowMapper = null;
	            }
	            //*/
	            this.dispatchEvent(new LightEvent_1.default(LightEvent_1.default.CASTS_SHADOW_CHANGE));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LightBase.prototype.pCreateShadowMapper = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    Object.defineProperty(LightBase.prototype, "specular", {
	        get: function () {
	            return this._specular;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            this._specular = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "diffuse", {
	        get: function () {
	            return this._diffuse;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            this._diffuse = value;
	            this.updateDiffuse();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "color", {
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._color = value;
	            this._colorR = ((this._color >> 16) & 0xff) / 0xff;
	            this._colorG = ((this._color >> 8) & 0xff) / 0xff;
	            this._colorB = (this._color & 0xff) / 0xff;
	            this.updateDiffuse();
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "ambient", {
	        get: function () {
	            return this._ambient;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            this._ambient = value;
	            this.updateAmbient();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "ambientColor", {
	        get: function () {
	            return this._ambientColor;
	        },
	        set: function (value) {
	            this._ambientColor = value;
	            this.updateAmbient();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LightBase.prototype.updateAmbient = function () {
	        this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
	        this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
	        this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
	    };
	    LightBase.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        throw new AbstractMethodError_1.default();
	    };
	    LightBase.prototype.updateSpecular = function () {
	        this._iSpecularR = this._colorR * this._specular;
	        this._iSpecularG = this._colorG * this._specular;
	        this._iSpecularB = this._colorB * this._specular;
	    };
	    LightBase.prototype.updateDiffuse = function () {
	        this._iDiffuseR = this._colorR * this._diffuse;
	        this._iDiffuseG = this._colorG * this._diffuse;
	        this._iDiffuseB = this._colorB * this._diffuse;
	    };
	    Object.defineProperty(LightBase.prototype, "shadowMapper", {
	        get: function () {
	            return this._shadowMapper;
	        },
	        set: function (value) {
	            this._shadowMapper = value;
	            this._shadowMapper.light = this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LightBase;
	}(DisplayObjectContainer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LightBase;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var LightEvent = (function (_super) {
	    __extends(LightEvent, _super);
	    function LightEvent(type) {
	        _super.call(this, type);
	    }
	    //@override
	    LightEvent.prototype.clone = function () {
	        return new LightEvent(this.type);
	    };
	    LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
	    return LightEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LightEvent;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(90);
	var Matrix3D_1 = __webpack_require__(28);
	var Matrix3DUtils_1 = __webpack_require__(27);
	var FreeMatrixProjection_1 = __webpack_require__(197);
	var Camera_1 = __webpack_require__(64);
	var ShadowMapperBase_1 = __webpack_require__(198);
	var Single2DTexture_1 = __webpack_require__(169);
	var DirectionalShadowMapper = (function (_super) {
	    __extends(DirectionalShadowMapper, _super);
	    function DirectionalShadowMapper() {
	        _super.call(this);
	        this._pLightOffset = 10000;
	        this._pSnap = 64;
	        this._pCullPlanes = [];
	        this._pOverallDepthProjection = new FreeMatrixProjection_1.default();
	        this._pOverallDepthCamera = new Camera_1.default(this._pOverallDepthProjection);
	        this._pLocalFrustum = [];
	        this._pMatrix = new Matrix3D_1.default();
	    }
	    Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
	        get: function () {
	            return this._pSnap;
	        },
	        set: function (value) {
	            this._pSnap = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
	        get: function () {
	            return this._pLightOffset;
	        },
	        set: function (value) {
	            this._pLightOffset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
	        //@arcane
	        get: function () {
	            return this._pOverallDepthCamera.viewProjection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
	        //@arcane
	        get: function () {
	            return this._pMaxZ - this._pMinZ;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DirectionalShadowMapper.prototype.iSetDepthMap = function (depthMap) {
	        if (this._depthMap == depthMap)
	            return;
	        _super.prototype.iSetDepthMap.call(this, depthMap);
	        if (this._depthMap) {
	            this._explicitDepthMap = true;
	            this._pDepthMapSize = depthMap.image2D.rect.width;
	        }
	        else {
	            this._explicitDepthMap = false;
	        }
	    };
	    DirectionalShadowMapper.prototype.pCreateDepthTexture = function () {
	        return new Single2DTexture_1.default(new Image2D_1.default(this._pDepthMapSize, this._pDepthMapSize));
	    };
	    //@override
	    DirectionalShadowMapper.prototype.pDrawDepthMap = function (scene, target, renderer) {
	        renderer.cullPlanes = this._pCullPlanes;
	        renderer._iRender(this._pOverallDepthCamera, scene, target.image2D);
	    };
	    //@protected
	    DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (camera) {
	        var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
	        var viewFrustumPlanes = camera.frustumPlanes;
	        this._pCullPlanes.length = 4;
	        this._pCullPlanes[0] = lightFrustumPlanes[0];
	        this._pCullPlanes[1] = lightFrustumPlanes[1];
	        this._pCullPlanes[2] = lightFrustumPlanes[2];
	        this._pCullPlanes[3] = lightFrustumPlanes[3];
	        var light = this._pLight;
	        var dir = light.sceneDirection;
	        var dirX = dir.x;
	        var dirY = dir.y;
	        var dirZ = dir.z;
	        var j = 4;
	        for (var i = 0; i < 6; ++i) {
	            var plane = viewFrustumPlanes[i];
	            if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
	                this._pCullPlanes[j++] = plane;
	        }
	    };
	    //@override
	    DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        this.pUpdateProjectionFromFrustumCorners(camera, camera.projection.frustumCorners, this._pMatrix);
	        this._pOverallDepthProjection.matrix = this._pMatrix;
	        this.pUpdateCullPlanes(camera);
	    };
	    DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (camera, corners, matrix) {
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        var dir;
	        var x, y, z;
	        var minX, minY;
	        var maxX, maxY;
	        var i;
	        var light = this._pLight;
	        dir = light.sceneDirection;
	        this._pOverallDepthCamera.transform.matrix3D = this._pLight.sceneTransform;
	        x = Math.floor((camera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
	        y = Math.floor((camera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
	        z = Math.floor((camera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
	        this._pOverallDepthCamera.x = x;
	        this._pOverallDepthCamera.y = y;
	        this._pOverallDepthCamera.z = z;
	        this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
	        this._pMatrix.prepend(camera.sceneTransform);
	        this._pMatrix.transformVectors(corners, this._pLocalFrustum);
	        minX = maxX = this._pLocalFrustum[0];
	        minY = maxY = this._pLocalFrustum[1];
	        this._pMaxZ = this._pLocalFrustum[2];
	        i = 3;
	        while (i < 24) {
	            x = this._pLocalFrustum[i];
	            y = this._pLocalFrustum[i + 1];
	            z = this._pLocalFrustum[i + 2];
	            if (x < minX)
	                minX = x;
	            if (x > maxX)
	                maxX = x;
	            if (y < minY)
	                minY = y;
	            if (y > maxY)
	                maxY = y;
	            if (z > this._pMaxZ)
	                this._pMaxZ = z;
	            i += 3;
	        }
	        this._pMinZ = 1;
	        var w = maxX - minX;
	        var h = maxY - minY;
	        var d = 1 / (this._pMaxZ - this._pMinZ);
	        if (minX < 0)
	            minX -= this._pSnap; // because int() rounds up for < 0
	        if (minY < 0)
	            minY -= this._pSnap;
	        minX = Math.floor(minX / this._pSnap) * this._pSnap;
	        minY = Math.floor(minY / this._pSnap) * this._pSnap;
	        var snap2 = 2 * this._pSnap;
	        w = Math.floor(w / snap2 + 2) * snap2;
	        h = Math.floor(h / snap2 + 2) * snap2;
	        maxX = minX + w;
	        maxY = minY + h;
	        w = 1 / w;
	        h = 1 / h;
	        raw[0] = 2 * w;
	        raw[5] = 2 * h;
	        raw[10] = d;
	        raw[12] = -(maxX + minX) * w;
	        raw[13] = -(maxY + minY) * h;
	        raw[14] = -this._pMinZ * d;
	        raw[15] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        matrix.copyRawDataFrom(raw);
	    };
	    return DirectionalShadowMapper;
	}(ShadowMapperBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectionalShadowMapper;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PerspectiveProjection_1 = __webpack_require__(66);
	var ProjectionBase_1 = __webpack_require__(34);
	var FreeMatrixProjection = (function (_super) {
	    __extends(FreeMatrixProjection, _super);
	    function FreeMatrixProjection() {
	        _super.call(this);
	        this._pMatrix.copyFrom(new PerspectiveProjection_1.default().matrix);
	    }
	    Object.defineProperty(FreeMatrixProjection.prototype, "near", {
	        //@override
	        set: function (value) {
	            this._pNear = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FreeMatrixProjection.prototype, "far", {
	        //@override
	        set: function (value) {
	            this._pFar = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FreeMatrixProjection.prototype, "iAspectRatio", {
	        //@override
	        set: function (value) {
	            this._pAspectRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    FreeMatrixProjection.prototype.clone = function () {
	        var clone = new FreeMatrixProjection();
	        clone._pMatrix.copyFrom(this._pMatrix);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone.pInvalidateMatrix();
	        return clone;
	    };
	    //@override
	    FreeMatrixProjection.prototype.pUpdateMatrix = function () {
	        this._pMatrixInvalid = false;
	    };
	    return FreeMatrixProjection;
	}(ProjectionBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FreeMatrixProjection;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var AssetBase_1 = __webpack_require__(24);
	var ShadowMapperBase = (function (_super) {
	    __extends(ShadowMapperBase, _super);
	    function ShadowMapperBase() {
	        _super.apply(this, arguments);
	        this._pDepthMapSize = 2048;
	        this._autoUpdateShadows = true;
	    }
	    Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
	        get: function () {
	            return this._autoUpdateShadows;
	        },
	        set: function (value) {
	            this._autoUpdateShadows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapperBase.prototype.updateShadows = function () {
	        this._iShadowsInvalid = true;
	    };
	    ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
	        if (this._depthMap && !this._explicitDepthMap)
	            this._depthMap.dispose();
	        this._depthMap = depthMap;
	    };
	    Object.defineProperty(ShadowMapperBase.prototype, "light", {
	        get: function () {
	            return this._pLight;
	        },
	        set: function (value) {
	            this._pLight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
	        get: function () {
	            if (!this._depthMap)
	                this._depthMap = this.pCreateDepthTexture();
	            return this._depthMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
	        get: function () {
	            return this._pDepthMapSize;
	        },
	        set: function (value) {
	            if (value == this._pDepthMapSize)
	                return;
	            this._pSetDepthMapSize(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapperBase.prototype.dispose = function () {
	        if (this._depthMap && !this._explicitDepthMap)
	            this._depthMap.dispose();
	        this._depthMap = null;
	    };
	    ShadowMapperBase.prototype.pCreateDepthTexture = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    ShadowMapperBase.prototype.iRenderDepthMap = function (camera, scene, renderer) {
	        this._iShadowsInvalid = false;
	        this.pUpdateDepthProjection(camera);
	        if (!this._depthMap)
	            this._depthMap = this.pCreateDepthTexture();
	        this.pDrawDepthMap(scene, this._depthMap, renderer);
	    };
	    ShadowMapperBase.prototype.pUpdateDepthProjection = function (camera) {
	        throw new AbstractMethodError_1.default();
	    };
	    ShadowMapperBase.prototype.pDrawDepthMap = function (scene, target, renderer) {
	        throw new AbstractMethodError_1.default();
	    };
	    ShadowMapperBase.prototype._pSetDepthMapSize = function (value) {
	        this._pDepthMapSize = value;
	        if (this._explicitDepthMap) {
	            throw Error("Cannot set depth map size for the current renderer.");
	        }
	        else if (this._depthMap) {
	            this._depthMap.dispose();
	            this._depthMap = null;
	        }
	    };
	    return ShadowMapperBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowMapperBase;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(28);
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Vector3D_1 = __webpack_require__(30);
	var LightBase_1 = __webpack_require__(194);
	var BoundsType_1 = __webpack_require__(50);
	var CubeMapShadowMapper_1 = __webpack_require__(200);
	var PointLight = (function (_super) {
	    __extends(PointLight, _super);
	    function PointLight() {
	        _super.call(this);
	        this._pRadius = 90000;
	        this._pFallOff = 100000;
	        this._pIsEntity = true;
	        this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	        //default bounds type
	        this._boundsType = BoundsType_1.default.SPHERE;
	    }
	    Object.defineProperty(PointLight.prototype, "assetType", {
	        get: function () {
	            return PointLight.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype.pCreateShadowMapper = function () {
	        return new CubeMapShadowMapper_1.default();
	    };
	    Object.defineProperty(PointLight.prototype, "radius", {
	        get: function () {
	            return this._pRadius;
	        },
	        set: function (value) {
	            this._pRadius = value;
	            if (this._pRadius < 0) {
	                this._pRadius = 0;
	            }
	            else if (this._pRadius > this._pFallOff) {
	                this._pFallOff = this._pRadius;
	                this._pInvalidateBounds();
	            }
	            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype.iFallOffFactor = function () {
	        return this._pFallOffFactor;
	    };
	    Object.defineProperty(PointLight.prototype, "fallOff", {
	        get: function () {
	            return this._pFallOff;
	        },
	        set: function (value) {
	            this._pFallOff = value;
	            if (this._pFallOff < 0)
	                this._pFallOff = 0;
	            if (this._pFallOff < this._pRadius)
	                this._pRadius = this._pFallOff;
	            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	            this._pInvalidateBounds();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        this._pSphereBounds.radius = this._pFallOff;
	    };
	    PointLight.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        var raw = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        var m = new Matrix3D_1.default();
	        // todo: do not use lookAt on Light
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this._pParent.inverseSceneTransform);
	        this.lookAt(m.position);
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this.inverseSceneTransform);
	        var box = entity.getBox();
	        var v1 = m.deltaTransformVector(new Vector3D_1.default(box.left, box.bottom, box.front));
	        var v2 = m.deltaTransformVector(new Vector3D_1.default(box.right, box.top, box.back));
	        var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
	        var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
	        var d = Math.sqrt(d1 > d2 ? d1 : d2);
	        var zMin;
	        var zMax;
	        var z = m.rawData[14];
	        zMin = z - d;
	        zMax = z + d;
	        raw[5] = raw[0] = zMin / d;
	        raw[10] = zMax / (zMax - zMin);
	        raw[11] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
	        raw[14] = -zMin * raw[10];
	        if (!target)
	            target = new Matrix3D_1.default();
	        target.copyRawDataFrom(raw);
	        target.prepend(m);
	        return target;
	    };
	    PointLight.assetType = "[light PointLight]";
	    return PointLight;
	}(LightBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PointLight;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageCube_1 = __webpack_require__(160);
	var Camera_1 = __webpack_require__(64);
	var ShadowMapperBase_1 = __webpack_require__(198);
	var SingleCubeTexture_1 = __webpack_require__(166);
	var CubeMapShadowMapper = (function (_super) {
	    __extends(CubeMapShadowMapper, _super);
	    function CubeMapShadowMapper() {
	        _super.call(this);
	        this._pDepthMapSize = 512;
	        this._needsRender = new Array();
	        this.initCameras();
	    }
	    CubeMapShadowMapper.prototype.initCameras = function () {
	        this._depthCameras = new Array();
	        this._projections = new Array();
	        // posX, negX, posY, negY, posZ, negZ
	        this.addCamera(0, 90, 0);
	        this.addCamera(0, -90, 0);
	        this.addCamera(-90, 0, 0);
	        this.addCamera(90, 0, 0);
	        this.addCamera(0, 0, 0);
	        this.addCamera(0, 180, 0);
	    };
	    CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
	        var cam = new Camera_1.default();
	        cam.rotationX = rotationX;
	        cam.rotationY = rotationY;
	        cam.rotationZ = rotationZ;
	        cam.projection.near = .01;
	        var projection = cam.projection;
	        projection.fieldOfView = 90;
	        this._projections.push(projection);
	        cam.projection._iAspectRatio = 1;
	        this._depthCameras.push(cam);
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
	        return new SingleCubeTexture_1.default(new ImageCube_1.default(this._pDepthMapSize));
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        var light = (this._pLight);
	        var maxDistance = light._pFallOff;
	        var pos = this._pLight.scenePosition;
	        // todo: faces outside frustum which are pointing away from camera need not be rendered!
	        for (var i = 0; i < 6; ++i) {
	            this._projections[i].far = maxDistance;
	            this._depthCameras[i].transform.moveTo(pos.x, pos.y, pos.z);
	            this._needsRender[i] = true;
	        }
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pDrawDepthMap = function (scene, target, renderer) {
	        for (var i = 0; i < 6; ++i)
	            if (this._needsRender[i])
	                renderer._iRender(this._depthCameras[i], scene, target.imageCube, null, i);
	    };
	    return CubeMapShadowMapper;
	}(ShadowMapperBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CubeMapShadowMapper;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Rectangle_1 = __webpack_require__(35);
	var DisplayObject_1 = __webpack_require__(45);
	var BoundsType_1 = __webpack_require__(50);
	var RenderableEvent_1 = __webpack_require__(76);
	var SurfaceEvent_1 = __webpack_require__(152);
	var DefaultMaterialManager_1 = __webpack_require__(156);
	var StyleEvent_1 = __webpack_require__(77);
	/**
	 * The Billboard class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Billboard()</code> constructor.
	 *
	 * <p>The <code>Billboard()</code> constructor allows you to create a Billboard
	 * object that contains a reference to a Image2D object. After you create a
	 * Billboard object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Billboard object can share its Image2D reference among several Billboard
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Billboard objects that reference the same Image2D object,
	 * multiple display objects can use the same complex Image2D object without
	 * incurring the memory overhead of a Image2D object for each display
	 * object instance.</p>
	 *
	 * <p>A Image2D object can be drawn to the screen by a Billboard object in one
	 * of two ways: by using the default hardware renderer with a single hardware surface,
	 * or by using the slower software renderer when 3D acceleration is not available.</p>
	 *
	 * <p>If you would prefer to perform a batch rendering command, rather than using a
	 * single surface for each Billboard object, you can also draw to the screen using the
	 * <code>drawTiles()</code> or <code>drawTriangles()</code> methods which are
	 * available to <code>flash.display.Tilesheet</code> and <code>flash.display.Graphics
	 * objects.</code></p>
	 *
	 * <p><b>Note:</b> The Billboard class is not a subclass of the InteractiveObject
	 * class, so it cannot dispatch mouse events. However, you can use the
	 * <code>addEventListener()</code> method of the display object container that
	 * contains the Billboard object.</p>
	 */
	var Billboard = (function (_super) {
	    __extends(Billboard, _super);
	    function Billboard(material, pixelSnapping, smoothing) {
	        var _this = this;
	        if (pixelSnapping === void 0) { pixelSnapping = "auto"; }
	        if (smoothing === void 0) { smoothing = false; }
	        _super.call(this);
	        this._pIsEntity = true;
	        this.onInvalidateTextureDelegate = function (event) { return _this.onInvalidateTexture(event); };
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this.material = material;
	        this._updateDimensions();
	        //default bounds type
	        this._boundsType = BoundsType_1.default.AXIS_ALIGNED_BOX;
	    }
	    Object.defineProperty(Billboard.prototype, "animator", {
	        /**
	         * Defines the animator of the sprite. Act on the sprite's geometry. Defaults to null
	         */
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Billboard.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardHeight", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardWidth", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "material", {
	        /**
	         *
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            if (this._material) {
	                this._material.iRemoveOwner(this);
	                this._material.removeEventListener(SurfaceEvent_1.default.INVALIDATE_TEXTURE, this.onInvalidateTextureDelegate);
	            }
	            this._material = value;
	            if (this._material) {
	                this._material.iAddOwner(this);
	                this._material.addEventListener(SurfaceEvent_1.default.INVALIDATE_TEXTURE, this.onInvalidateTextureDelegate);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @protected
	     */
	    Billboard.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.width = this._billboardRect.width;
	        this._pBoxBounds.height = this._billboardRect.height;
	    };
	    Billboard.prototype.clone = function () {
	        var clone = new Billboard(this.material);
	        return clone;
	    };
	    Object.defineProperty(Billboard.prototype, "style", {
	        /**
	         * The style used to render the current Billboard. If set to null, the default style of the material will be used instead.
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.default.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._onInvalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Billboard.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return pickingCollider.testBillboardCollision(this, this.material, pickingCollision);
	    };
	    /**
	     * @private
	     */
	    Billboard.prototype.onInvalidateTexture = function (event) {
	        this._updateDimensions();
	    };
	    Billboard.prototype._acceptTraverser = function (traverser) {
	        traverser.applyRenderable(this);
	    };
	    Billboard.prototype._updateDimensions = function () {
	        var texture = this.material.getTextureAt(0);
	        var image = texture ? ((this._style ? this._style.getImageAt(texture) : null) || (this.material.style ? this.material.style.getImageAt(texture) : null) || texture.getImageAt(0)) : null;
	        if (image) {
	            var sampler = ((this._style ? this._style.getSamplerAt(texture) : null) || (this.material.style ? this.material.style.getSamplerAt(texture) : null) || texture.getSamplerAt(0) || DefaultMaterialManager_1.default.getDefaultSampler());
	            if (sampler.imageRect) {
	                this._billboardWidth = sampler.imageRect.width * image.width;
	                this._billboardHeight = sampler.imageRect.height * image.height;
	            }
	            else {
	                this._billboardWidth = image.rect.width;
	                this._billboardHeight = image.rect.height;
	            }
	            this._billboardRect = sampler.frameRect || new Rectangle_1.default(0, 0, this._billboardWidth, this._billboardHeight);
	        }
	        else {
	            this._billboardWidth = 1;
	            this._billboardHeight = 1;
	            this._billboardRect = new Rectangle_1.default(0, 0, 1, 1);
	        }
	        this._pInvalidateBounds();
	        this.dispatchEvent(new RenderableEvent_1.default(RenderableEvent_1.default.INVALIDATE_ELEMENTS, this));
	    };
	    Billboard.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.default(RenderableEvent_1.default.INVALIDATE_RENDER_OWNER, this));
	    };
	    Billboard.prototype._onInvalidateProperties = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidateSurface();
	        this._updateDimensions();
	    };
	    Billboard.assetType = "[asset Billboard]";
	    return Billboard;
	}(DisplayObject_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Billboard;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var DirectionalLight_1 = __webpack_require__(193);
	var LightProbe_1 = __webpack_require__(203);
	var PointLight_1 = __webpack_require__(199);
	var LightEvent_1 = __webpack_require__(195);
	var LightPickerBase_1 = __webpack_require__(205);
	/**
	 * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
	 * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
	 * occur.
	 */
	var StaticLightPicker = (function (_super) {
	    __extends(StaticLightPicker, _super);
	    /**
	     * Creates a new StaticLightPicker object.
	     * @param lights The lights to be used for shading.
	     */
	    function StaticLightPicker(lights) {
	        var _this = this;
	        _super.call(this);
	        this._onCastShadowChangeDelegate = function (event) { return _this.onCastShadowChange(event); };
	        this.lights = lights;
	    }
	    Object.defineProperty(StaticLightPicker.prototype, "lights", {
	        /**
	         * The lights used for shading.
	         */
	        get: function () {
	            return this._lights;
	        },
	        set: function (value) {
	            var numPointLights = 0;
	            var numDirectionalLights = 0;
	            var numCastingPointLights = 0;
	            var numCastingDirectionalLights = 0;
	            var numLightProbes = 0;
	            var light;
	            if (this._lights)
	                this.clearListeners();
	            this._lights = value;
	            this._pAllPickedLights = value;
	            this._pPointLights = new Array();
	            this._pCastingPointLights = new Array();
	            this._pDirectionalLights = new Array();
	            this._pCastingDirectionalLights = new Array();
	            this._pLightProbes = new Array();
	            var len = value.length;
	            for (var i = 0; i < len; ++i) {
	                light = value[i];
	                light.addEventListener(LightEvent_1.default.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
	                if (light instanceof PointLight_1.default) {
	                    if (light.shadowsEnabled)
	                        this._pCastingPointLights[numCastingPointLights++] = light;
	                    else
	                        this._pPointLights[numPointLights++] = light;
	                }
	                else if (light instanceof DirectionalLight_1.default) {
	                    if (light.shadowsEnabled)
	                        this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
	                    else
	                        this._pDirectionalLights[numDirectionalLights++] = light;
	                }
	                else if (light instanceof LightProbe_1.default) {
	                    this._pLightProbes[numLightProbes++] = light;
	                }
	            }
	            if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights)
	                return;
	            this._pNumDirectionalLights = numDirectionalLights;
	            this._pNumCastingDirectionalLights = numCastingDirectionalLights;
	            this._pNumPointLights = numPointLights;
	            this._pNumCastingPointLights = numCastingPointLights;
	            this._pNumLightProbes = numLightProbes;
	            // MUST HAVE MULTIPLE OF 4 ELEMENTS!
	            this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);
	            // notify material lights have changed
	            this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.INVALIDATE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Remove configuration change listeners on the lights.
	     */
	    StaticLightPicker.prototype.clearListeners = function () {
	        var len = this._lights.length;
	        for (var i = 0; i < len; ++i)
	            this._lights[i].removeEventListener(LightEvent_1.default.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
	    };
	    /**
	     * Notifies the material of a configuration change.
	     */
	    StaticLightPicker.prototype.onCastShadowChange = function (event) {
	        // TODO: Assign to special caster collections, just append it to the lights in SinglePass
	        // But keep seperated in multipass
	        var light = event.target;
	        if (light instanceof PointLight_1.default)
	            this.updatePointCasting(light);
	        else if (light instanceof DirectionalLight_1.default)
	            this.updateDirectionalCasting(light);
	        this.dispatchEvent(new AssetEvent_1.default(AssetEvent_1.default.INVALIDATE, this));
	    };
	    /**
	     * Called when a directional light's shadow casting configuration changes.
	     */
	    StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
	        var dl = light;
	        if (light.shadowsEnabled) {
	            --this._pNumDirectionalLights;
	            ++this._pNumCastingDirectionalLights;
	            this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
	            this._pCastingDirectionalLights.push(light);
	        }
	        else {
	            ++this._pNumDirectionalLights;
	            --this._pNumCastingDirectionalLights;
	            this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
	            this._pDirectionalLights.push(light);
	        }
	    };
	    /**
	     * Called when a point light's shadow casting configuration changes.
	     */
	    StaticLightPicker.prototype.updatePointCasting = function (light) {
	        var pl = light;
	        if (light.shadowsEnabled) {
	            --this._pNumPointLights;
	            ++this._pNumCastingPointLights;
	            this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
	            this._pCastingPointLights.push(light);
	        }
	        else {
	            ++this._pNumPointLights;
	            --this._pNumCastingPointLights;
	            this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
	            this._pPointLights.push(light);
	        }
	    };
	    return StaticLightPicker;
	}(LightPickerBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StaticLightPicker;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerCube_1 = __webpack_require__(204);
	var ErrorBase_1 = __webpack_require__(21);
	var LightBase_1 = __webpack_require__(194);
	var BoundsType_1 = __webpack_require__(50);
	var LightProbe = (function (_super) {
	    __extends(LightProbe, _super);
	    function LightProbe(diffuseMap, specularMap) {
	        if (specularMap === void 0) { specularMap = null; }
	        _super.call(this);
	        this.diffuseSampler = new SamplerCube_1.default();
	        this.specularSampler = new SamplerCube_1.default();
	        this._pIsEntity = true;
	        this.diffuseMap = diffuseMap;
	        this.specularMap = specularMap;
	        //default bounds type
	        this._boundsType = BoundsType_1.default.NULL;
	    }
	    Object.defineProperty(LightProbe.prototype, "assetType", {
	        get: function () {
	            return LightProbe.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        throw new ErrorBase_1.default("Object projection matrices are not supported for LightProbe objects!");
	    };
	    LightProbe.assetType = "[light LightProbe]";
	    return LightProbe;
	}(LightBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LightProbe;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerBase_1 = __webpack_require__(158);
	/**
	 * The Bitmap class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Bitmap()</code> constructor.
	 *
	 * <p>The <code>Bitmap()</code> constructor allows you to create a Bitmap
	 * object that contains a reference to a BitmapData object. After you create a
	 * Bitmap object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Bitmap object can share its BitmapData reference among several Bitmap
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Bitmap objects that reference the same BitmapData object,
	 * multiple texture objects can use the same complex BitmapData object without
	 * incurring the memory overhead of a BitmapData object for each texture
	 * object instance.</p>

	 */
	var SamplerCube = (function (_super) {
	    __extends(SamplerCube, _super);
	    /**
	     *
	     * @param bitmapData
	     * @param smoothing
	     */
	    function SamplerCube(smooth, mipmap) {
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this, smooth, mipmap);
	    }
	    Object.defineProperty(SamplerCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return SamplerCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SamplerCube.assetType = "[asset SamplerCube]";
	    return SamplerCube;
	}(SamplerBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SamplerCube;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
	 * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
	 * extended to provide more application-specific dynamic selection of lights.
	 *
	 * @see StaticLightPicker
	 */
	var LightPickerBase = (function (_super) {
	    __extends(LightPickerBase, _super);
	    /**
	     * Creates a new LightPickerBase object.
	     */
	    function LightPickerBase() {
	        _super.call(this);
	        this._pNumPointLights = 0;
	        this._pNumDirectionalLights = 0;
	        this._pNumCastingPointLights = 0;
	        this._pNumCastingDirectionalLights = 0;
	        this._pNumLightProbes = 0;
	    }
	    /**
	     * Disposes resources used by the light picker.
	     */
	    LightPickerBase.prototype.dispose = function () {
	    };
	    Object.defineProperty(LightPickerBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return LightPickerBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
	        /**
	         * The maximum amount of directional lights that will be provided.
	         */
	        get: function () {
	            return this._pNumDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
	        /**
	         * The maximum amount of point lights that will be provided.
	         */
	        get: function () {
	            return this._pNumPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
	        /**
	         * The maximum amount of directional lights that cast shadows.
	         */
	        get: function () {
	            return this._pNumCastingDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
	        /**
	         * The amount of point lights that cast shadows.
	         */
	        get: function () {
	            return this._pNumCastingPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
	        /**
	         * The maximum amount of light probes that will be provided.
	         */
	        get: function () {
	            return this._pNumLightProbes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "pointLights", {
	        /**
	         * The collected point lights to be used for shading.
	         */
	        get: function () {
	            return this._pPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
	        /**
	         * The collected directional lights to be used for shading.
	         */
	        get: function () {
	            return this._pDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
	        /**
	         * The collected point lights that cast shadows to be used for shading.
	         */
	        get: function () {
	            return this._pCastingPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
	        /**
	         * The collected directional lights that cast shadows to be used for shading.
	         */
	        get: function () {
	            return this._pCastingDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
	        /**
	         * The collected light probes to be used for shading.
	         */
	        get: function () {
	            return this._pLightProbes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
	        /**
	         * The weights for each light probe, defining their influence on the object.
	         */
	        get: function () {
	            return this._pLightProbeWeights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
	        /**
	         * A collection of all the collected lights.
	         */
	        get: function () {
	            return this._pAllPickedLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
	     */
	    LightPickerBase.prototype.collectLights = function (entity) {
	        this.updateProbeWeights(entity);
	    };
	    /**
	     * Updates the weights for the light probes, based on the renderable's position relative to them.
	     * @param renderable The renderble for which to calculate the light probes' influence.
	     */
	    LightPickerBase.prototype.updateProbeWeights = function (entity) {
	        // todo: this will cause the same calculations to occur per TriangleGraphic. See if this can be improved.
	        var objectPos = entity.scenePosition;
	        var lightPos;
	        var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
	        var dx, dy, dz;
	        var w, total = 0;
	        var i;
	        // calculates weights for probes
	        for (i = 0; i < this._pNumLightProbes; ++i) {
	            lightPos = this._pLightProbes[i].scenePosition;
	            dx = rx - lightPos.x;
	            dy = ry - lightPos.y;
	            dz = rz - lightPos.z;
	            // weight is inversely proportional to square of distance
	            w = dx * dx + dy * dy + dz * dz;
	            // just... huge if at the same spot
	            w = w > .00001 ? 1 / w : 50000000;
	            this._pLightProbeWeights[i] = w;
	            total += w;
	        }
	        // normalize
	        total = 1 / total;
	        for (i = 0; i < this._pNumLightProbes; ++i)
	            this._pLightProbeWeights[i] *= total;
	    };
	    LightPickerBase.assetType = "[asset LightPicker]";
	    return LightPickerBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LightPickerBase;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var AbstractMethodError_1 = __webpack_require__(20);
	/**
	 * PrefabBase is an abstract base class for prefabs, which are prebuilt display objects that allow easy cloning and updating
	 */
	var PrefabBase = (function (_super) {
	    __extends(PrefabBase, _super);
	    //		public _pBatchObjects:Array<BatchObject> = new Array<BatchObject>();
	    /**
	     * Creates a new PrefabBase object.
	     */
	    function PrefabBase() {
	        _super.call(this);
	        this._pObjects = new Array();
	    }
	    /**
	     * Returns a display object generated from this prefab
	     */
	    PrefabBase.prototype.getNewObject = function () {
	        var object = this._pCreateObject();
	        this._pObjects.push(object);
	        return object;
	    };
	    //		public getNewBatchObject():BatchObject
	    //		{
	    //			var object:BatchObject = this._pCreateBatchObject();
	    //
	    //			this._pBatchObjects.push(object);
	    //
	    //			return object;
	    //		}
	    PrefabBase.prototype._pCreateObject = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    PrefabBase.prototype._iValidate = function () {
	        // To be overridden when necessary
	    };
	    return PrefabBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrefabBase;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A Capsule primitive sprite.
	 */
	var PrimitiveCapsulePrefab = (function (_super) {
	    __extends(PrimitiveCapsulePrefab, _super);
	    /**
	     * Creates a new Capsule object.
	     * @param radius The radius of the capsule.
	     * @param height The height of the capsule.
	     * @param segmentsW Defines the number of horizontal segments that make up the capsule. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven value.
	     * @param yUp Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveCapsulePrefab(material, elementsType, radius, height, segmentsW, segmentsH, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 15; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._radius = radius;
	        this._height = height;
	        this._segmentsW = segmentsW;
	        this._segmentsH = (segmentsH % 2 == 0) ? segmentsH + 1 : segmentsH;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "radius", {
	        /**
	         * The radius of the capsule.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "height", {
	        /**
	         * The height of the capsule.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the capsule. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = (value % 2 == 0) ? value + 1 : value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "yUp", {
	        /**
	         * Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCapsulePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var i;
	        var j;
	        var triIndex = 0;
	        var index = 0;
	        var startIndex;
	        var comp1, comp2, t1, t2;
	        var numIndices = 0;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            this._numVertices = (this._segmentsH + 1) * (this._segmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of closure
	            numIndices = (this._segmentsH - 1) * this._segmentsW * 6; // each level has segmentH quads, each of 2 triangles
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	                positions = triangleGraphics.positions.get(this._numVertices);
	                normals = triangleGraphics.normals.get(this._numVertices);
	                tangents = triangleGraphics.tangents.get(this._numVertices);
	            }
	            else {
	                indices = new Uint16Array(numIndices);
	                positions = new Float32Array(this._numVertices * 3);
	                normals = new Float32Array(this._numVertices * 3);
	                tangents = new Float32Array(this._numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            for (j = 0; j <= this._segmentsH; ++j) {
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                startIndex = index;
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var offset = j > this._segmentsH / 2 ? this._height / 2 : -this._height / 2;
	                    var y = ringradius * Math.sin(verangle);
	                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
	                    var tanLen = Math.sqrt(y * y + x * x);
	                    if (this._yUp) {
	                        t1 = 0;
	                        t2 = tanLen > .007 ? x / tanLen : 0;
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        t1 = tanLen > .007 ? x / tanLen : 0;
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsW) {
	                        positions[index] = positions[startIndex];
	                        positions[index + 1] = positions[startIndex + 1];
	                        positions[index + 2] = positions[startIndex + 2];
	                        normals[index] = (normals[startIndex] + (x * normLen)) * .5;
	                        normals[index + 1] = (normals[startIndex + 1] + (comp1 * normLen)) * .5;
	                        normals[index + 2] = (normals[startIndex + 2] + (comp2 * normLen)) * .5;
	                        tangents[index] = (tangents[startIndex] + (tanLen > .007 ? -y / tanLen : 1)) * .5;
	                        tangents[index + 1] = (tangents[startIndex + 1] + t1) * .5;
	                        tangents[index + 2] = (tangents[startIndex + 2] + t2) * .5;
	                    }
	                    else {
	                        // vertex
	                        positions[index] = x;
	                        positions[index + 1] = (this._yUp) ? comp1 - offset : comp1;
	                        positions[index + 2] = (this._yUp) ? comp2 : comp2 + offset;
	                        // normal
	                        normals[index] = x * normLen;
	                        normals[index + 1] = comp1 * normLen;
	                        normals[index + 2] = comp2 * normLen;
	                        // tangent
	                        tangents[index] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[index + 1] = t1;
	                        tangents[index + 2] = t2;
	                    }
	                    if (i > 0 && j > 0) {
	                        var a = (this._segmentsW + 1) * j + i;
	                        var b = (this._segmentsW + 1) * j + i - 1;
	                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
	                        var d = (this._segmentsW + 1) * (j - 1) + i;
	                        if (j == this._segmentsH) {
	                            positions[index] = positions[startIndex];
	                            positions[index + 1] = positions[startIndex + 1];
	                            positions[index + 2] = positions[startIndex + 2];
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = d;
	                        }
	                        else if (j == 1) {
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = b;
	                            indices[triIndex++] = c;
	                        }
	                        else {
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = b;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = d;
	                        }
	                    }
	                    index += 3;
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCapsulePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var uvs;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                uvs = triangleGraphics.uvs.get(this._numVertices);
	            }
	            else {
	                uvs = new Float32Array(this._numVertices * 2);
	            }
	            // current uv component index
	            var index = 0;
	            // surface
	            for (j = 0; j <= this._segmentsH; ++j) {
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    // revolution vertex
	                    uvs[index++] = (i / this._segmentsW) * this._scaleU;
	                    uvs[index++] = (j / this._segmentsH) * this._scaleV;
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitiveCapsulePrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveCapsulePrefab;


/***/ },
/* 208 */
/***/ function(module, exports) {

	"use strict";
	var ElementsType = (function () {
	    function ElementsType() {
	    }
	    /**
	     *
	     */
	    ElementsType.TRIANGLE = "triangle";
	    /**
	     *
	     */
	    ElementsType.LINE = "line";
	    return ElementsType;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ElementsType;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(80);
	var AbstractMethodError_1 = __webpack_require__(20);
	var ElementsType_1 = __webpack_require__(208);
	var TriangleElements_1 = __webpack_require__(192);
	var LineElements_1 = __webpack_require__(161);
	var Sprite_1 = __webpack_require__(73);
	var PrefabBase_1 = __webpack_require__(206);
	/**
	 * PrimitivePrefabBase is an abstract base class for polytope prefabs, which are simple pre-built geometric shapes
	 */
	var PrimitivePrefabBase = (function (_super) {
	    __extends(PrimitivePrefabBase, _super);
	    /**
	     * Creates a new PrimitivePrefabBase object.
	     *
	     * @param material The material with which to render the object
	     */
	    function PrimitivePrefabBase(material, elementsType) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        _super.call(this);
	        this._primitiveDirty = true;
	        this._uvDirty = true;
	        this._scaleU = 1;
	        this._scaleV = 1;
	        this._material = material;
	        this._elementsType = elementsType;
	        if (this._elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleElements = new TriangleElements_1.default(new AttributesBuffer_1.default());
	            triangleElements.autoDeriveNormals = false;
	            triangleElements.autoDeriveTangents = false;
	            this._elements = triangleElements;
	        }
	        else if (this._elementsType == ElementsType_1.default.LINE) {
	            this._elements = new LineElements_1.default(new AttributesBuffer_1.default());
	        }
	    }
	    Object.defineProperty(PrimitivePrefabBase.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return PrimitivePrefabBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "elementsType", {
	        /**
	         *
	         */
	        get: function () {
	            return this._elementsType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "material", {
	        /**
	         * The material with which to render the primitive.
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            this._material = value;
	            var len = this._pObjects.length;
	            for (var i = 0; i < len; i++)
	                this._pObjects[i].material = this._material;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleU", {
	        get: function () {
	            return this._scaleU;
	        },
	        set: function (value) {
	            if (this._scaleU = value)
	                return;
	            this._scaleU = value;
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleV", {
	        get: function () {
	            return this._scaleV;
	        },
	        set: function (value) {
	            if (this._scaleV = value)
	                return;
	            this._scaleV = value;
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
	     * be triggered by the invalidateGraphics method (and in turn by updateGraphics).
	     */
	    PrimitivePrefabBase.prototype._pBuildGraphics = function (target, elementsType) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
	     * should be triggered by the invalidateUVs method (and in turn by updateUVs).
	     */
	    PrimitivePrefabBase.prototype._pBuildUVs = function (target, elementsType) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Invalidates the primitive, causing it to be updated when requested.
	     */
	    PrimitivePrefabBase.prototype._pInvalidatePrimitive = function () {
	        this._primitiveDirty = true;
	    };
	    /**
	     * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
	     */
	    PrimitivePrefabBase.prototype._pInvalidateUVs = function () {
	        this._uvDirty = true;
	    };
	    /**
	     * Updates the geometry when invalid.
	     */
	    PrimitivePrefabBase.prototype.updateGraphics = function () {
	        this._pBuildGraphics(this._elements, this._elementsType);
	        this._primitiveDirty = false;
	    };
	    /**
	     * Updates the uv coordinates when invalid.
	     */
	    PrimitivePrefabBase.prototype.updateUVs = function () {
	        this._pBuildUVs(this._elements, this._elementsType);
	        this._uvDirty = false;
	    };
	    PrimitivePrefabBase.prototype._iValidate = function () {
	        if (this._primitiveDirty)
	            this.updateGraphics();
	        if (this._uvDirty)
	            this.updateUVs();
	    };
	    PrimitivePrefabBase.prototype._pCreateObject = function () {
	        var sprite = new Sprite_1.default(this._material);
	        sprite.graphics.addGraphic(this._elements);
	        sprite._iSourcePrefab = this;
	        return sprite;
	    };
	    PrimitivePrefabBase.assetType = "[asset PrimitivePrefab]";
	    return PrimitivePrefabBase;
	}(PrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitivePrefabBase;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PrimitiveCylinderPrefab_1 = __webpack_require__(211);
	/**
	 * A UV Cone primitive sprite.
	 */
	var PrimitiveConePrefab = (function (_super) {
	    __extends(PrimitiveConePrefab, _super);
	    /**
	     * Creates a new Cone object.
	     * @param radius The radius of the bottom end of the cone
	     * @param height The height of the cone
	     * @param segmentsW Defines the number of horizontal segments that make up the cone. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the cone. Defaults to 1.
	     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveConePrefab(material, elementsType, radius, height, segmentsW, segmentsH, closed, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (closed === void 0) { closed = true; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType, 0, radius, height, segmentsW, segmentsH, false, closed, true, yUp);
	    }
	    Object.defineProperty(PrimitiveConePrefab.prototype, "radius", {
	        /**
	         * The radius of the bottom end of the cone.
	         */
	        get: function () {
	            return this._pBottomRadius;
	        },
	        set: function (value) {
	            this._pBottomRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PrimitiveConePrefab;
	}(PrimitiveCylinderPrefab_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveConePrefab;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A Cylinder primitive sprite.
	 */
	var PrimitiveCylinderPrefab = (function (_super) {
	    __extends(PrimitiveCylinderPrefab, _super);
	    /**
	     * Creates a new Cylinder object.
	     * @param topRadius The radius of the top end of the cylinder.
	     * @param bottomRadius The radius of the bottom end of the cylinder
	     * @param height The radius of the bottom end of the cylinder
	     * @param segmentsW Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the cylinder. Defaults to 1.
	     * @param topClosed Defines whether the top end of the cylinder is closed (true) or open.
	     * @param bottomClosed Defines whether the bottom end of the cylinder is closed (true) or open.
	     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveCylinderPrefab(material, elementsType, topRadius, bottomRadius, height, segmentsW, segmentsH, topClosed, bottomClosed, surfaceClosed, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (topRadius === void 0) { topRadius = 50; }
	        if (bottomRadius === void 0) { bottomRadius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (topClosed === void 0) { topClosed = true; }
	        if (bottomClosed === void 0) { bottomClosed = true; }
	        if (surfaceClosed === void 0) { surfaceClosed = true; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._topRadius = topRadius;
	        this._pBottomRadius = bottomRadius;
	        this._height = height;
	        this._pSegmentsW = segmentsW;
	        this._pSegmentsH = segmentsH;
	        this._topClosed = topClosed;
	        this._bottomClosed = bottomClosed;
	        this._surfaceClosed = surfaceClosed;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topRadius", {
	        /**
	         * The radius of the top end of the cylinder.
	         */
	        get: function () {
	            return this._topRadius;
	        },
	        set: function (value) {
	            this._topRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomRadius", {
	        /**
	         * The radius of the bottom end of the cylinder.
	         */
	        get: function () {
	            return this._pBottomRadius;
	        },
	        set: function (value) {
	            this._pBottomRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "height", {
	        /**
	         * The radius of the top end of the cylinder.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
	         */
	        get: function () {
	            return this._pSegmentsW;
	        },
	        set: function (value) {
	            this.setSegmentsW(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PrimitiveCylinderPrefab.prototype.setSegmentsW = function (value) {
	        this._pSegmentsW = value;
	        this._pInvalidatePrimitive();
	        this._pInvalidateUVs();
	    };
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the cylinder. Defaults to 1.
	         */
	        get: function () {
	            return this._pSegmentsH;
	        },
	        set: function (value) {
	            this.setSegmentsH(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PrimitiveCylinderPrefab.prototype.setSegmentsH = function (value) {
	        this._pSegmentsH = value;
	        this._pInvalidatePrimitive();
	        this._pInvalidateUVs();
	    };
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topClosed", {
	        /**
	         * Defines whether the top end of the cylinder is closed (true) or open.
	         */
	        get: function () {
	            return this._topClosed;
	        },
	        set: function (value) {
	            this._topClosed = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomClosed", {
	        /**
	         * Defines whether the bottom end of the cylinder is closed (true) or open.
	         */
	        get: function () {
	            return this._bottomClosed;
	        },
	        set: function (value) {
	            this._bottomClosed = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "yUp", {
	        /**
	         * Defines whether the cylinder poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCylinderPrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var i;
	        var j;
	        var x;
	        var y;
	        var z;
	        var vidx;
	        var fidx;
	        var radius;
	        var revolutionAngle;
	        var dr;
	        var latNormElev;
	        var latNormBase;
	        var numIndices = 0;
	        var comp1;
	        var comp2;
	        var startIndex = 0;
	        var nextVertexIndex = 0;
	        var centerVertexIndex = 0;
	        var t1;
	        var t2;
	        // reset utility variables
	        this._numVertices = 0;
	        // evaluate revolution steps
	        var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            if (this._surfaceClosed) {
	                this._numVertices += (this._pSegmentsH + 1) * (this._pSegmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of UV unwrapping
	                numIndices += this._pSegmentsH * this._pSegmentsW * 6; // each level has segmentW quads, each of 2 triangles
	            }
	            if (this._topClosed) {
	                this._numVertices += 2 * (this._pSegmentsW + 1); // segmentsW + 1 because of unwrapping
	                numIndices += this._pSegmentsW * 3; // one triangle for each segment
	            }
	            if (this._bottomClosed) {
	                this._numVertices += 2 * (this._pSegmentsW + 1);
	                numIndices += this._pSegmentsW * 3;
	            }
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	                positions = triangleGraphics.positions.get(this._numVertices);
	                normals = triangleGraphics.normals.get(this._numVertices);
	                tangents = triangleGraphics.tangents.get(this._numVertices);
	            }
	            else {
	                indices = new Uint16Array(numIndices);
	                positions = new Float32Array(this._numVertices * 3);
	                normals = new Float32Array(this._numVertices * 3);
	                tangents = new Float32Array(this._numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            vidx = 0;
	            fidx = 0;
	            // top
	            if (this._topClosed && this._topRadius > 0) {
	                z = -0.5 * this._height;
	                // central vertex
	                if (this._yUp) {
	                    t1 = 1;
	                    t2 = 0;
	                    comp1 = -z;
	                    comp2 = 0;
	                }
	                else {
	                    t1 = 0;
	                    t2 = -1;
	                    comp1 = 0;
	                    comp2 = z;
	                }
	                positions[vidx] = 0;
	                positions[vidx + 1] = comp1;
	                positions[vidx + 2] = comp2;
	                normals[vidx] = 0;
	                normals[vidx + 1] = t1;
	                normals[vidx + 2] = t2;
	                tangents[vidx] = 1;
	                tangents[vidx + 1] = 0;
	                tangents[vidx + 2] = 0;
	                vidx += 3;
	                nextVertexIndex += 1;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = this._topRadius * Math.cos(revolutionAngle);
	                    y = this._topRadius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._pSegmentsW) {
	                        positions[vidx] = positions[startIndex + 3];
	                        positions[vidx + 1] = positions[startIndex + 4];
	                        positions[vidx + 2] = positions[startIndex + 5];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    if (i > 0) {
	                        // add triangle
	                        indices[fidx++] = nextVertexIndex - 1;
	                        indices[fidx++] = centerVertexIndex;
	                        indices[fidx++] = nextVertexIndex;
	                    }
	                    nextVertexIndex += 1;
	                }
	            }
	            // bottom
	            if (this._bottomClosed && this._pBottomRadius > 0) {
	                z = 0.5 * this._height;
	                startIndex = nextVertexIndex * 3;
	                centerVertexIndex = nextVertexIndex;
	                // central vertex
	                if (this._yUp) {
	                    t1 = -1;
	                    t2 = 0;
	                    comp1 = -z;
	                    comp2 = 0;
	                }
	                else {
	                    t1 = 0;
	                    t2 = 1;
	                    comp1 = 0;
	                    comp2 = z;
	                }
	                if (i > 0) {
	                    positions[vidx] = 0;
	                    positions[vidx + 1] = comp1;
	                    positions[vidx + 2] = comp2;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                }
	                nextVertexIndex += 1;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = this._pBottomRadius * Math.cos(revolutionAngle);
	                    y = this._pBottomRadius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._pSegmentsW) {
	                        positions[vidx] = positions[startIndex + 3];
	                        positions[vidx + 1] = positions[startIndex + 4];
	                        positions[vidx + 2] = positions[startIndex + 5];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    if (i > 0) {
	                        // add triangle
	                        indices[fidx++] = nextVertexIndex - 1;
	                        indices[fidx++] = nextVertexIndex;
	                        indices[fidx++] = centerVertexIndex;
	                    }
	                    nextVertexIndex += 1;
	                }
	            }
	            // The normals on the lateral surface all have the same incline, i.e.
	            // the "elevation" component (Y or Z depending on yUp) is constant.
	            // Same principle goes for the "base" of these vectors, which will be
	            // calculated such that a vector [base,elev] will be a unit vector.
	            dr = (this._pBottomRadius - this._topRadius);
	            latNormElev = dr / this._height;
	            latNormBase = (latNormElev == 0) ? 1 : this._height / dr;
	            // lateral surface
	            if (this._surfaceClosed) {
	                var a;
	                var b;
	                var c;
	                var d;
	                var na0, na1, naComp1, naComp2;
	                for (j = 0; j <= this._pSegmentsH; ++j) {
	                    radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
	                    z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
	                    startIndex = nextVertexIndex * 3;
	                    for (i = 0; i <= this._pSegmentsW; ++i) {
	                        // revolution vertex
	                        revolutionAngle = i * revolutionAngleDelta;
	                        x = radius * Math.cos(revolutionAngle);
	                        y = radius * Math.sin(revolutionAngle);
	                        na0 = latNormBase * Math.cos(revolutionAngle);
	                        na1 = latNormBase * Math.sin(revolutionAngle);
	                        if (this._yUp) {
	                            t1 = 0;
	                            t2 = -na0;
	                            comp1 = -z;
	                            comp2 = y;
	                            naComp1 = latNormElev;
	                            naComp2 = na1;
	                        }
	                        else {
	                            t1 = -na0;
	                            t2 = 0;
	                            comp1 = y;
	                            comp2 = z;
	                            naComp1 = na1;
	                            naComp2 = latNormElev;
	                        }
	                        if (i == this._pSegmentsW) {
	                            positions[vidx] = positions[startIndex];
	                            positions[vidx + 1] = positions[startIndex + 1];
	                            positions[vidx + 2] = positions[startIndex + 2];
	                            normals[vidx] = na0;
	                            normals[vidx + 1] = latNormElev;
	                            normals[vidx + 2] = na1;
	                            tangents[vidx] = na1;
	                            tangents[vidx + 1] = t1;
	                            tangents[vidx + 2] = t2;
	                        }
	                        else {
	                            positions[vidx] = x;
	                            positions[vidx + 1] = comp1;
	                            positions[vidx + 2] = comp2;
	                            normals[vidx] = na0;
	                            normals[vidx + 1] = naComp1;
	                            normals[vidx + 2] = naComp2;
	                            tangents[vidx] = -na1;
	                            tangents[vidx + 1] = t1;
	                            tangents[vidx + 2] = t2;
	                        }
	                        vidx += 3;
	                        // close triangle
	                        if (i > 0 && j > 0) {
	                            a = nextVertexIndex; // current
	                            b = nextVertexIndex - 1; // previous
	                            c = b - this._pSegmentsW - 1; // previous of last level
	                            d = a - this._pSegmentsW - 1; // current of last level
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                        nextVertexIndex++;
	                    }
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._pSegmentsH * this._pSegmentsW * 2 + this._pSegmentsW;
	            positions = new Float32Array(numSegments * 6);
	            var thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            var _radius = 50;
	            for (j = 0; j <= this._pSegmentsH; ++j) {
	                radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
	                z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = radius * Math.cos(revolutionAngle);
	                    y = radius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i > 0) {
	                        //horizonal lines
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                        thickness[fidx++] = 1;
	                        //vertical lines
	                        if (j > 0) {
	                            var addx = (j == 1) ? 3 - (6 * (this._pSegmentsW - i) + 12 * i) : 3 - this._pSegmentsW * 12;
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx++] = x;
	                            positions[vidx++] = comp1;
	                            positions[vidx++] = comp2;
	                            thickness[fidx++] = 1;
	                        }
	                    }
	                    //horizonal lines
	                    if (i < this._pSegmentsW) {
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                    }
	                }
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCylinderPrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i;
	        var j;
	        var x;
	        var y;
	        var revolutionAngle;
	        var uvs;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                uvs = triangleGraphics.uvs.get(this._numVertices);
	            }
	            else {
	                uvs = new Float32Array(this._numVertices * 2);
	            }
	            // evaluate revolution steps
	            var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
	            // current uv component index
	            var index = 0;
	            // top
	            if (this._topClosed) {
	                uvs[index++] = 0.5 * this._scaleU; // central vertex
	                uvs[index++] = 0.5 * this._scaleV;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
	                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
	                    uvs[index++] = x * this._scaleU; // revolution vertex
	                    uvs[index++] = y * this._scaleV;
	                }
	            }
	            // bottom
	            if (this._bottomClosed) {
	                uvs[index++] = 0.5 * this._scaleU; // central vertex
	                uvs[index++] = 0.5 * this._scaleV;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = 0.5 + 0.5 * Math.cos(revolutionAngle);
	                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
	                    uvs[index++] = x * this._scaleU; // revolution vertex
	                    uvs[index++] = y * this._scaleV;
	                }
	            }
	            // lateral surface
	            if (this._surfaceClosed) {
	                for (j = 0; j <= this._pSegmentsH; ++j) {
	                    for (i = 0; i <= this._pSegmentsW; ++i) {
	                        // revolution vertex
	                        uvs[index++] = (i / this._pSegmentsW) * this._scaleU;
	                        uvs[index++] = (j / this._pSegmentsH) * this._scaleV;
	                    }
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitiveCylinderPrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveCylinderPrefab;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A Cube primitive prefab.
	 */
	var PrimitiveCubePrefab = (function (_super) {
	    __extends(PrimitiveCubePrefab, _super);
	    /**
	     * Creates a new Cube object.
	     * @param width The size of the cube along its X-axis.
	     * @param height The size of the cube along its Y-axis.
	     * @param depth The size of the cube along its Z-axis.
	     * @param segmentsW The number of segments that make up the cube along the X-axis.
	     * @param segmentsH The number of segments that make up the cube along the Y-axis.
	     * @param segmentsD The number of segments that make up the cube along the Z-axis.
	     * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
	     */
	    function PrimitiveCubePrefab(material, elementsType, width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (width === void 0) { width = 100; }
	        if (height === void 0) { height = 100; }
	        if (depth === void 0) { depth = 100; }
	        if (segmentsW === void 0) { segmentsW = 1; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (segmentsD === void 0) { segmentsD = 1; }
	        if (tile6 === void 0) { tile6 = true; }
	        _super.call(this, material, elementsType);
	        this._width = width;
	        this._height = height;
	        this._depth = depth;
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._segmentsD = segmentsD;
	        this._tile6 = tile6;
	    }
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "width", {
	        /**
	         * The size of the cube along its X-axis.
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            this._width = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "height", {
	        /**
	         * The size of the cube along its Y-axis.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "depth", {
	        /**
	         * The size of the cube along its Z-axis.
	         */
	        get: function () {
	            return this._depth;
	        },
	        set: function (value) {
	            this._depth = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "tile6", {
	        /**
	         * The type of uv mapping to use. When false, the entire image is mapped on each face.
	         * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
	         * Reading the tiles from left to right, top to bottom they represent the faces of the
	         * cube in the following order: bottom, top, back, left, front, right. This creates
	         * several shared edges (between the top, front, left and right faces) which simplifies
	         * texture painting.
	         */
	        get: function () {
	            return this._tile6;
	        },
	        set: function (value) {
	            this._tile6 = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsW", {
	        /**
	         * The number of segments that make up the cube along the X-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsH", {
	        /**
	         * The number of segments that make up the cube along the Y-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsD", {
	        /**
	         * The number of segments that make up the cube along the Z-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsD;
	        },
	        set: function (value) {
	            this._segmentsD = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCubePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var tl, tr, bl, br;
	        var i, j, inc = 0;
	        var vidx, fidx; // indices
	        var hw, hh, hd; // halves
	        var dw, dh, dd; // deltas
	        var outer_pos;
	        // half cube dimensions
	        hw = this._width / 2;
	        hh = this._height / 2;
	        hd = this._depth / 2;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            var numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
	            var numIndices = ((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	                positions = triangleGraphics.positions.get(numVertices);
	                normals = triangleGraphics.normals.get(numVertices);
	                tangents = triangleGraphics.tangents.get(numVertices);
	            }
	            else {
	                indices = new Uint16Array(numIndices);
	                positions = new Float32Array(numVertices * 3);
	                normals = new Float32Array(numVertices * 3);
	                tangents = new Float32Array(numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            vidx = 0;
	            fidx = 0;
	            // Segment dimensions
	            dw = this._width / this._segmentsW;
	            dh = this._height / this._segmentsH;
	            dd = this._depth / this._segmentsD;
	            for (i = 0; i <= this._segmentsW; i++) {
	                outer_pos = -hw + i * dw;
	                for (j = 0; j <= this._segmentsH; j++) {
	                    // front
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = -hd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = -1;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    // back
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = hd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 1;
	                    tangents[vidx] = -1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    if (i && j) {
	                        tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
	                        tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	            inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);
	            for (i = 0; i <= this._segmentsW; i++) {
	                outer_pos = -hw + i * dw;
	                for (j = 0; j <= this._segmentsD; j++) {
	                    // top
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = hh;
	                    positions[vidx + 2] = -hd + j * dd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 1;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    // bottom
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh;
	                    positions[vidx + 2] = -hd + j * dd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = -1;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    if (i && j) {
	                        tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
	                        tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	            inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);
	            for (i = 0; i <= this._segmentsD; i++) {
	                outer_pos = hd - i * dd;
	                for (j = 0; j <= this._segmentsH; j++) {
	                    // left
	                    positions[vidx] = -hw;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = outer_pos;
	                    normals[vidx] = -1;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 0;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = -1;
	                    vidx += 3;
	                    // right
	                    positions[vidx] = hw;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = outer_pos;
	                    normals[vidx] = 1;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 0;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 1;
	                    vidx += 3;
	                    if (i && j) {
	                        tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
	                        tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._segmentsH * 4 + this._segmentsW * 4 + this._segmentsD * 4;
	            var thickness;
	            positions = new Float32Array(numSegments * 6);
	            thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            //front/back face
	            for (i = 0; i < this._segmentsH; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsW; ++i) {
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = -hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            //left/right face
	            for (i = 0; i < this._segmentsH; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsD; ++i) {
	                positions[vidx++] = hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                thickness[fidx++] = 1;
	            }
	            //top/bottom face
	            for (i = 0; i < this._segmentsD; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                positions[vidx++] = hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsW; ++i) {
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCubePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j, index;
	        var uvs;
	        var u_tile_dim, v_tile_dim;
	        var u_tile_step, v_tile_step;
	        var tl0u, tl0v;
	        var tl1u, tl1v;
	        var du, dv;
	        var numVertices;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
	            var triangleGraphics = target;
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.uvs != null) {
	                uvs = triangleGraphics.uvs.get(numVertices);
	            }
	            else {
	                uvs = new Float32Array(numVertices * 2);
	            }
	            if (this._tile6) {
	                u_tile_dim = u_tile_step = 1 / 3;
	                v_tile_dim = v_tile_step = 1 / 2;
	            }
	            else {
	                u_tile_dim = v_tile_dim = 1;
	                u_tile_step = v_tile_step = 0;
	            }
	            // Create planes two and two, the same way that they were
	            // constructed in the buildGraphics() function. First calculate
	            // the top-left UV coordinate for both planes, and then loop
	            // over the points, calculating the UVs from these numbers.
	            // When tile6 is true, the layout is as follows:
	            //       .-----.-----.-----. (1,1)
	            //       | Bot |  T  | Bak |
	            //       |-----+-----+-----|
	            //       |  L  |  F  |  R  |
	            // (0,0)'-----'-----'-----'
	            index = 0;
	            // FRONT / BACK
	            tl0u = 1 * u_tile_step;
	            tl0v = 1 * v_tile_step;
	            tl1u = 2 * u_tile_step;
	            tl1v = 0 * v_tile_step;
	            du = u_tile_dim / this._segmentsW;
	            dv = v_tile_dim / this._segmentsH;
	            for (i = 0; i <= this._segmentsW; i++) {
	                for (j = 0; j <= this._segmentsH; j++) {
	                    uvs[index++] = (tl0u + i * du) * this._scaleU;
	                    uvs[index++] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    uvs[index++] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
	                    uvs[index++] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
	                }
	            }
	            // TOP / BOTTOM
	            tl0u = 1 * u_tile_step;
	            tl0v = 0 * v_tile_step;
	            tl1u = 0 * u_tile_step;
	            tl1v = 0 * v_tile_step;
	            du = u_tile_dim / this._segmentsW;
	            dv = v_tile_dim / this._segmentsD;
	            for (i = 0; i <= this._segmentsW; i++) {
	                for (j = 0; j <= this._segmentsD; j++) {
	                    uvs[index++] = (tl0u + i * du) * this._scaleU;
	                    uvs[index++] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    uvs[index++] = (tl1u + i * du) * this._scaleU;
	                    uvs[index++] = (tl1v + j * dv) * this._scaleV;
	                }
	            }
	            // LEFT / RIGHT
	            tl0u = 0 * u_tile_step;
	            tl0v = 1 * v_tile_step;
	            tl1u = 2 * u_tile_step;
	            tl1v = 1 * v_tile_step;
	            du = u_tile_dim / this._segmentsD;
	            dv = v_tile_dim / this._segmentsH;
	            for (i = 0; i <= this._segmentsD; i++) {
	                for (j = 0; j <= this._segmentsH; j++) {
	                    uvs[index++] = (tl0u + i * du) * this._scaleU;
	                    uvs[index++] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    uvs[index++] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
	                    uvs[index++] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
	                }
	            }
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitiveCubePrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveCubePrefab;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A Plane primitive sprite.
	 */
	var PrimitivePlanePrefab = (function (_super) {
	    __extends(PrimitivePlanePrefab, _super);
	    /**
	     * Creates a new Plane object.
	     * @param width The width of the plane.
	     * @param height The height of the plane.
	     * @param segmentsW The number of segments that make up the plane along the X-axis.
	     * @param segmentsH The number of segments that make up the plane along the Y or Z-axis.
	     * @param yUp Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false).
	     * @param doubleSided Defines whether the plane will be visible from both sides, with correct vertex normals.
	     */
	    function PrimitivePlanePrefab(material, elementsType, width, height, segmentsW, segmentsH, yUp, doubleSided) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (width === void 0) { width = 100; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 1; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (yUp === void 0) { yUp = true; }
	        if (doubleSided === void 0) { doubleSided = false; }
	        _super.call(this, material, elementsType);
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._yUp = yUp;
	        this._width = width;
	        this._height = height;
	        this._doubleSided = doubleSided;
	    }
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsW", {
	        /**
	         * The number of segments that make up the plane along the X-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsH", {
	        /**
	         * The number of segments that make up the plane along the Y or Z-axis, depending on whether yUp is true or
	         * false, respectively. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "yUp", {
	        /**
	         *  Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false). Defaults to true.
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "doubleSided", {
	        /**
	         * Defines whether the plane will be visible from both sides, with correct vertex normals (as opposed to bothSides on Material). Defaults to false.
	         */
	        get: function () {
	            return this._doubleSided;
	        },
	        set: function (value) {
	            this._doubleSided = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "width", {
	        /**
	         * The width of the plane.
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            this._width = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "height", {
	        /**
	         * The height of the plane.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitivePlanePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var x, y;
	        var numIndices;
	        var base;
	        var tw = this._segmentsW + 1;
	        var vidx, fidx; // indices
	        var xi;
	        var yi;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            var numVertices = (this._segmentsH + 1) * tw;
	            var positions;
	            var normals;
	            var tangents;
	            if (this._doubleSided)
	                numVertices *= 2;
	            numIndices = this._segmentsH * this._segmentsW * 6;
	            if (this._doubleSided)
	                numIndices *= 2;
	            if (triangleGraphics.indices != null && numIndices == triangleGraphics.indices.length) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            }
	            else {
	                indices = new Uint16Array(numIndices);
	                this._pInvalidateUVs();
	            }
	            if (numVertices == triangleGraphics.numVertices) {
	                positions = triangleGraphics.positions.get(numVertices);
	                normals = triangleGraphics.normals.get(numVertices);
	                tangents = triangleGraphics.tangents.get(numVertices);
	            }
	            else {
	                positions = new Float32Array(numVertices * 3);
	                normals = new Float32Array(numVertices * 3);
	                tangents = new Float32Array(numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            fidx = 0;
	            vidx = 0;
	            for (yi = 0; yi <= this._segmentsH; ++yi) {
	                for (xi = 0; xi <= this._segmentsW; ++xi) {
	                    x = (xi / this._segmentsW - .5) * this._width;
	                    y = (yi / this._segmentsH - .5) * this._height;
	                    positions[vidx] = x;
	                    if (this._yUp) {
	                        positions[vidx + 1] = 0;
	                        positions[vidx + 2] = y;
	                    }
	                    else {
	                        positions[vidx + 1] = y;
	                        positions[vidx + 2] = 0;
	                    }
	                    normals[vidx] = 0;
	                    if (this._yUp) {
	                        normals[vidx + 1] = 1;
	                        normals[vidx + 2] = 0;
	                    }
	                    else {
	                        normals[vidx + 1] = 0;
	                        normals[vidx + 2] = -1;
	                    }
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += 3;
	                    // add vertex with same position, but with inverted normal & tangent
	                    if (this._doubleSided) {
	                        for (var i = vidx; i < vidx + 3; ++i) {
	                            positions[i] = positions[i - 3];
	                            normals[i] = -normals[i - 3];
	                            tangents[i] = -tangents[i - 3];
	                        }
	                        vidx += 3;
	                    }
	                    if (xi != this._segmentsW && yi != this._segmentsH) {
	                        base = xi + yi * tw;
	                        var mult = this._doubleSided ? 2 : 1;
	                        indices[fidx++] = base * mult;
	                        indices[fidx++] = (base + tw) * mult;
	                        indices[fidx++] = (base + tw + 1) * mult;
	                        indices[fidx++] = base * mult;
	                        indices[fidx++] = (base + tw + 1) * mult;
	                        indices[fidx++] = (base + 1) * mult;
	                        if (this._doubleSided) {
	                            indices[fidx++] = (base + tw + 1) * mult + 1;
	                            indices[fidx++] = (base + tw) * mult + 1;
	                            indices[fidx++] = base * mult + 1;
	                            indices[fidx++] = (base + 1) * mult + 1;
	                            indices[fidx++] = (base + tw + 1) * mult + 1;
	                            indices[fidx++] = base * mult + 1;
	                        }
	                    }
	                }
	            }
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	            var lineGraphics = target;
	            var numSegments = (this._segmentsH + 1) + tw;
	            var positions;
	            var thickness;
	            var hw = this._width / 2;
	            var hh = this._height / 2;
	            positions = new Float32Array(numSegments * 6);
	            thickness = new Float32Array(numSegments);
	            fidx = 0;
	            vidx = 0;
	            for (yi = 0; yi <= this._segmentsH; ++yi) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = yi * this._height - hh;
	                positions[vidx++] = hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = yi * this._height - hh;
	                thickness[fidx++] = 1;
	            }
	            for (xi = 0; xi <= this._segmentsW; ++xi) {
	                positions[vidx++] = xi * this._width - hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = -hh;
	                positions[vidx++] = xi * this._width - hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = hh;
	                thickness[fidx++] = 1;
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitivePlanePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var uvs;
	        var numVertices;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            if (this._doubleSided)
	                numVertices *= 2;
	            var triangleGraphics = target;
	            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
	                uvs = triangleGraphics.uvs.get(numVertices);
	            }
	            else {
	                uvs = new Float32Array(numVertices * 2);
	                this._pInvalidatePrimitive();
	            }
	            var index = 0;
	            for (var yi = 0; yi <= this._segmentsH; ++yi) {
	                for (var xi = 0; xi <= this._segmentsW; ++xi) {
	                    uvs[index] = (xi / this._segmentsW) * this._scaleU;
	                    uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
	                    index += 2;
	                    if (this._doubleSided) {
	                        uvs[index] = (xi / this._segmentsW) * this._scaleU;
	                        uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
	                        index += 2;
	                    }
	                }
	            }
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitivePlanePrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitivePlanePrefab;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A UV Sphere primitive sprite.
	 */
	var PrimitiveSpherePrefab = (function (_super) {
	    __extends(PrimitiveSpherePrefab, _super);
	    /**
	     * Creates a new Sphere object.
	     *
	     * @param radius The radius of the sphere.
	     * @param segmentsW Defines the number of horizontal segments that make up the sphere.
	     * @param segmentsH Defines the number of vertical segments that make up the sphere.
	     * @param yUp Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveSpherePrefab(material, elementsType, radius, segmentsW, segmentsH, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 12; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._radius = radius;
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "radius", {
	        /**
	         * The radius of the sphere.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the sphere. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the sphere. Defaults to 12.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "yUp", {
	        /**
	         * Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveSpherePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var i;
	        var j;
	        var vidx, fidx; // indices
	        var comp1;
	        var comp2;
	        var numVertices;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	                positions = triangleGraphics.positions.get(numVertices);
	                normals = triangleGraphics.normals.get(numVertices);
	                tangents = triangleGraphics.tangents.get(numVertices);
	            }
	            else {
	                indices = new Uint16Array((this._segmentsH - 1) * this._segmentsW * 6);
	                positions = new Float32Array(numVertices * 3);
	                normals = new Float32Array(numVertices * 3);
	                tangents = new Float32Array(numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            vidx = 0;
	            fidx = 0;
	            var startIndex;
	            var t1;
	            var t2;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                startIndex = vidx;
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var y = ringradius * Math.sin(verangle);
	                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
	                    var tanLen = Math.sqrt(y * y + x * x);
	                    if (this._yUp) {
	                        t1 = 0;
	                        t2 = tanLen > .007 ? x / tanLen : 0;
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        t1 = tanLen > .007 ? x / tanLen : 0;
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsW) {
	                        positions[vidx] = positions[startIndex];
	                        positions[vidx + 1] = positions[startIndex + 1];
	                        positions[vidx + 2] = positions[startIndex + 2];
	                        normals[vidx] = normals[startIndex] + (x * normLen) * .5;
	                        normals[vidx + 1] = normals[startIndex + 1] + (comp1 * normLen) * .5;
	                        normals[vidx + 2] = normals[startIndex + 2] + (comp2 * normLen) * .5;
	                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[vidx + 1] = t1;
	                        tangents[vidx + 2] = t2;
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                        normals[vidx] = x * normLen;
	                        normals[vidx + 1] = comp1 * normLen;
	                        normals[vidx + 2] = comp2 * normLen;
	                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[vidx + 1] = t1;
	                        tangents[vidx + 2] = t2;
	                    }
	                    if (i > 0 && j > 0) {
	                        var a = (this._segmentsW + 1) * j + i;
	                        var b = (this._segmentsW + 1) * j + i - 1;
	                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
	                        var d = (this._segmentsW + 1) * (j - 1) + i;
	                        if (j == this._segmentsH) {
	                            positions[vidx] = positions[startIndex];
	                            positions[vidx + 1] = positions[startIndex + 1];
	                            positions[vidx + 2] = positions[startIndex + 2];
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                        else if (j == 1) {
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                        }
	                        else {
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                    }
	                    vidx += 3;
	                }
	            }
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._segmentsH * this._segmentsW * 2 + this._segmentsW;
	            var positions = new Float32Array(numSegments * 6);
	            var thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var y = ringradius * Math.sin(verangle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i > 0) {
	                        //horizonal lines
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                        thickness[fidx++] = 1;
	                        //vertical lines
	                        if (j > 0) {
	                            var addx = (j == 1) ? 3 - (6 * (this._segmentsW - i) + 12 * i) : 3 - this._segmentsW * 12;
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx++] = x;
	                            positions[vidx++] = comp1;
	                            positions[vidx++] = comp2;
	                            thickness[fidx++] = 1;
	                        }
	                    }
	                    //horizonal lines
	                    if (i < this._segmentsW) {
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                    }
	                }
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveSpherePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	        var uvs;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            var triangleGraphics = target;
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.uvs != null) {
	                uvs = triangleGraphics.uvs.get(numVertices);
	            }
	            else {
	                uvs = new Float32Array(numVertices * 2);
	            }
	            var index = 0;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    uvs[index++] = (i / this._segmentsW) * this._scaleU;
	                    uvs[index++] = (j / this._segmentsH) * this._scaleV;
	                }
	            }
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitiveSpherePrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveSpherePrefab;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(208);
	var PrimitivePrefabBase_1 = __webpack_require__(209);
	/**
	 * A UV Cylinder primitive sprite.
	 */
	var PrimitiveTorusPrefab = (function (_super) {
	    __extends(PrimitiveTorusPrefab, _super);
	    /**
	     * Creates a new <code>Torus</code> object.
	     * @param radius The radius of the torus.
	     * @param tuebRadius The radius of the inner tube of the torus.
	     * @param segmentsR Defines the number of horizontal segments that make up the torus.
	     * @param segmentsT Defines the number of vertical segments that make up the torus.
	     * @param yUp Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveTorusPrefab(material, elementsType, radius, tubeRadius, segmentsR, segmentsT, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (tubeRadius === void 0) { tubeRadius = 50; }
	        if (segmentsR === void 0) { segmentsR = 16; }
	        if (segmentsT === void 0) { segmentsT = 8; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._radius = radius;
	        this._tubeRadius = tubeRadius;
	        this._segmentsR = segmentsR;
	        this._segmentsT = segmentsT;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "radius", {
	        /**
	         * The radius of the torus.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "tubeRadius", {
	        /**
	         * The radius of the inner tube of the torus.
	         */
	        get: function () {
	            return this._tubeRadius;
	        },
	        set: function (value) {
	            this._tubeRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsR", {
	        /**
	         * Defines the number of horizontal segments that make up the torus. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsR;
	        },
	        set: function (value) {
	            this._segmentsR = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsT", {
	        /**
	         * Defines the number of vertical segments that make up the torus. Defaults to 8.
	         */
	        get: function () {
	            return this._segmentsT;
	        },
	        set: function (value) {
	            this._segmentsT = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "yUp", {
	        /**
	         * Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveTorusPrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var i, j;
	        var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
	        var vidx;
	        var fidx;
	        var numIndices = 0;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1); // segmentsT + 1 because of closure, segmentsR + 1 because of closure
	            numIndices = this._segmentsT * this._segmentsR * 6; // each level has segmentR quads, each of 2 triangles
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	                positions = triangleGraphics.positions.get(this._numVertices);
	                normals = triangleGraphics.normals.get(this._numVertices);
	                tangents = triangleGraphics.tangents.get(this._numVertices);
	            }
	            else {
	                indices = new Uint16Array(numIndices);
	                positions = new Float32Array(this._numVertices * 3);
	                normals = new Float32Array(this._numVertices * 3);
	                tangents = new Float32Array(this._numVertices * 3);
	                this._pInvalidateUVs();
	            }
	            vidx = 0;
	            fidx = 0;
	            // evaluate revolution steps
	            var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
	            var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;
	            var comp1, comp2;
	            var t1, t2, n1, n2;
	            var startIndex = 0;
	            var nextVertexIndex = 0;
	            // surface
	            var a, b, c, d, length;
	            for (j = 0; j <= this._segmentsT; ++j) {
	                startIndex = nextVertexIndex * 3;
	                for (i = 0; i <= this._segmentsR; ++i) {
	                    // revolution vertex
	                    revolutionAngleR = i * revolutionAngleDeltaR;
	                    revolutionAngleT = j * revolutionAngleDeltaT;
	                    length = Math.cos(revolutionAngleT);
	                    nx = length * Math.cos(revolutionAngleR);
	                    ny = length * Math.sin(revolutionAngleR);
	                    nz = Math.sin(revolutionAngleT);
	                    x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
	                    y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
	                    z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;
	                    if (this._yUp) {
	                        n1 = -nz;
	                        n2 = ny;
	                        t1 = 0;
	                        t2 = (length ? nx / length : x / this._radius);
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        n1 = ny;
	                        n2 = nz;
	                        t1 = (length ? nx / length : x / this._radius);
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsR) {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = positions[startIndex + 1];
	                        positions[vidx + 2] = positions[startIndex + 2];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = nx;
	                    normals[vidx + 1] = n1;
	                    normals[vidx + 2] = n2;
	                    tangents[vidx] = -(length ? ny / length : y / this._radius);
	                    tangents[vidx + 1] = t1;
	                    tangents[vidx + 2] = t2;
	                    vidx += 3;
	                    // close triangle
	                    if (i > 0 && j > 0) {
	                        a = nextVertexIndex; // current
	                        b = nextVertexIndex - 1; // previous
	                        c = b - this._segmentsR - 1; // previous of last level
	                        d = a - this._segmentsR - 1; // current of last level
	                        indices[fidx++] = a;
	                        indices[fidx++] = b;
	                        indices[fidx++] = c;
	                        indices[fidx++] = a;
	                        indices[fidx++] = c;
	                        indices[fidx++] = d;
	                    }
	                    nextVertexIndex++;
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setIndices(indices);
	            triangleGraphics.setPositions(positions);
	            triangleGraphics.setNormals(normals);
	            triangleGraphics.setTangents(tangents);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveTorusPrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var uvs;
	        if (elementsType == ElementsType_1.default.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                uvs = triangleGraphics.uvs.get(this._numVertices);
	            }
	            else {
	                uvs = new Float32Array(this._numVertices * 2);
	            }
	            // current uv component index
	            var index = 0;
	            // surface
	            for (j = 0; j <= this._segmentsT; ++j) {
	                for (i = 0; i <= this._segmentsR; ++i) {
	                    // revolution vertex
	                    uvs[index++] = (i / this._segmentsR) * this._scaleU;
	                    uvs[index++] = (j / this._segmentsT) * this._scaleV;
	                }
	            }
	            // build real data from raw data
	            triangleGraphics.setUVs(uvs);
	        }
	        else if (elementsType == ElementsType_1.default.LINE) {
	        }
	    };
	    return PrimitiveTorusPrefab;
	}(PrimitivePrefabBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PrimitiveTorusPrefab;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationSetBase_1 = __webpack_require__(217);
	var VertexAnimationMode_1 = __webpack_require__(219);
	/**
	 * The animation data set used by vertex-based animators, containing vertex animation state data.
	 *
	 * @see VertexAnimator
	 */
	var VertexAnimationSet = (function (_super) {
	    __extends(VertexAnimationSet, _super);
	    /**
	     * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
	     */
	    //		public get useNormals():boolean
	    //		{
	    //			return this._uploadNormals;
	    //		}
	    /**
	     * Creates a new <code>VertexAnimationSet</code> object.
	     *
	     * @param numPoses The number of poses made available at once to the GPU animation code.
	     * @param blendMode Optional value for setting the animation mode of the vertex animator object.
	     *
	     * @see away3d.animators.data.VertexAnimationMode
	     */
	    function VertexAnimationSet(numPoses, blendMode) {
	        if (numPoses === void 0) { numPoses = 2; }
	        if (blendMode === void 0) { blendMode = "absolute"; }
	        _super.call(this);
	        this._numPoses = numPoses;
	        this._blendMode = blendMode;
	    }
	    Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
	        /**
	         * Returns the number of poses made available at once to the GPU animation code.
	         */
	        get: function () {
	            return this._numPoses;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
	        /**
	         * Returns the active blend mode of the vertex animator object.
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALVertexCode = function (shader) {
	        if (this._blendMode == VertexAnimationMode_1.default.ABSOLUTE)
	            return this.getAbsoluteAGALCode(shader);
	        else
	            return this.getAdditiveAGALCode(shader);
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.activate = function (shader, stage) {
	        //			var uID:number = pass._iUniqueId;
	        //			this._uploadNormals = <boolean> this._useNormals[uID];
	        //			this._uploadTangents = <boolean> this._useTangents[uID];
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.deactivate = function (shader, stage) {
	        //			var uID:number = pass._iUniqueId;
	        //			var index:number /*uint*/ = this._streamIndices[uID];
	        //			var context:IContextGL = <IContextGL> stage.context;
	        //			context.setVertexBufferAt(index, null);
	        //			if (this._uploadNormals)
	        //				context.setVertexBufferAt(index + 1, null);
	        //			if (this._uploadTangents)
	        //				context.setVertexBufferAt(index + 2, null);
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALFragmentCode = function (shader, shadedTarget) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALUVCode = function (shader) {
	        return "mov " + shader.uvTarget + "," + shader.uvSource + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.doneAGALCode = function (shader) {
	    };
	    /**
	     * Generates the vertex AGAL code for absolute blending.
	     */
	    VertexAnimationSet.prototype.getAbsoluteAGALCode = function (shader) {
	        var code = "";
	        var temp1 = this._pFindTempReg(shader.animationTargetRegisters);
	        var temp2 = this._pFindTempReg(shader.animationTargetRegisters, temp1);
	        var regs = new Array("x", "y", "z", "w");
	        var len = shader.animatableAttributes.length;
	        var constantReg = "vc" + shader.numUsedVertexConstants;
	        if (len > 2)
	            len = 2;
	        var streamIndex = shader.numUsedStreams;
	        for (var i = 0; i < len; ++i) {
	            code += "mul " + temp1 + ", " + shader.animatableAttributes[i] + ", " + constantReg + "." + regs[0] + "\n";
	            for (var j = 1; j < this._numPoses; ++j) {
	                code += "mul " + temp2 + ", va" + streamIndex + ", " + constantReg + "." + regs[j] + "\n";
	                if (j < this._numPoses - 1)
	                    code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";
	                ++streamIndex;
	            }
	            code += "add " + shader.animationTargetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
	        }
	        // add code for bitangents if tangents are used
	        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
	            code += "dp3 " + temp1 + ".x, " + shader.animatableAttributes[2] + ", " + shader.animationTargetRegisters[1] + "\n" +
	                "mul " + temp1 + ", " + shader.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
	                "sub " + shader.animationTargetRegisters[2] + ", " + shader.animationTargetRegisters[2] + ", " + temp1 + "\n";
	        }
	        return code;
	    };
	    /**
	     * Generates the vertex AGAL code for additive blending.
	     */
	    VertexAnimationSet.prototype.getAdditiveAGALCode = function (shader) {
	        var code = "";
	        var len = shader.animatableAttributes.length;
	        var regs = ["x", "y", "z", "w"];
	        var temp1 = this._pFindTempReg(shader.animationTargetRegisters);
	        var k;
	        var streamIndex = shader.numUsedStreams;
	        if (len > 2)
	            len = 2;
	        code += "mov  " + shader.animationTargetRegisters[0] + ", " + shader.animatableAttributes[0] + "\n";
	        if (shader.normalDependencies > 0)
	            code += "mov " + shader.animationTargetRegisters[1] + ", " + shader.animatableAttributes[1] + "\n";
	        for (var i = 0; i < len; ++i) {
	            for (var j = 0; j < this._numPoses; ++j) {
	                code += "mul " + temp1 + ", va" + (streamIndex + k) + ", vc" + shader.numUsedVertexConstants + "." + regs[j] + "\n" +
	                    "add " + shader.animationTargetRegisters[i] + ", " + shader.animationTargetRegisters[i] + ", " + temp1 + "\n";
	                k++;
	            }
	        }
	        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
	            code += "dp3 " + temp1 + ".x, " + shader.animatableAttributes[2] + ", " + shader.animationTargetRegisters[1] + "\n" +
	                "mul " + temp1 + ", " + shader.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
	                "sub " + shader.animationTargetRegisters[2] + ", " + shader.animatableAttributes[2] + ", " + temp1 + "\n";
	        }
	        return code;
	    };
	    return VertexAnimationSet;
	}(AnimationSetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexAnimationSet;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var AbstractMethodError_1 = __webpack_require__(20);
	var AnimationSetError_1 = __webpack_require__(218);
	/**
	 * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
	 *
	 * @see away.animators.AnimatorBase
	 */
	var AnimationSetBase = (function (_super) {
	    __extends(AnimationSetBase, _super);
	    function AnimationSetBase() {
	        _super.call(this);
	        this._animations = new Array();
	        this._animationNames = new Array();
	        this._animationDictionary = new Object();
	    }
	    /**
	     * Retrieves a temporary GPU register that's still free.
	     *
	     * @param exclude An array of non-free temporary registers.
	     * @param excludeAnother An additional register that's not free.
	     * @return A temporary register that can be used.
	     */
	    AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
	        if (excludeAnother === void 0) { excludeAnother = null; }
	        var i = 0;
	        var reg;
	        while (true) {
	            reg = "vt" + i;
	            if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
	                return reg;
	            ++i;
	        }
	    };
	    Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
	        /**
	         * Indicates whether the properties of the animation data contained within the set combined with
	         * the vertex registers already in use on shading materials allows the animation data to utilise
	         * GPU calls.
	         */
	        get: function () {
	            return this._usesCPU;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Called by the material to reset the GPU indicator before testing whether register space in the shader
	     * is available for running GPU-based animation code.
	     *
	     * @private
	     */
	    AnimationSetBase.prototype.resetGPUCompatibility = function () {
	        this._usesCPU = false;
	    };
	    AnimationSetBase.prototype.cancelGPUCompatibility = function () {
	        this._usesCPU = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALVertexCode = function (shader) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.activate = function (shader, stage) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.deactivate = function (shader, stage) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALFragmentCode = function (shader, shadedTarget) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALUVCode = function (shader) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.doneAGALCode = function (shader) {
	        throw new AbstractMethodError_1.default();
	    };
	    Object.defineProperty(AnimationSetBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimationSetBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationSetBase.prototype, "animations", {
	        /**
	         * Returns a vector of animation state objects that make up the contents of the animation data set.
	         */
	        get: function () {
	            return this._animations;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
	        /**
	         * Returns a vector of animation state objects that make up the contents of the animation data set.
	         */
	        get: function () {
	            return this._animationNames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Check to determine whether a state is registered in the animation set under the given name.
	     *
	     * @param stateName The name of the animation state object to be checked.
	     */
	    AnimationSetBase.prototype.hasAnimation = function (name) {
	        return this._animationDictionary[name] != null;
	    };
	    /**
	     * Retrieves the animation state object registered in the animation data set under the given name.
	     *
	     * @param stateName The name of the animation state object to be retrieved.
	     */
	    AnimationSetBase.prototype.getAnimation = function (name) {
	        return this._animationDictionary[name];
	    };
	    /**
	     * Adds an animation state object to the aniamtion data set under the given name.
	     *
	     * @param stateName The name under which the animation state object will be stored.
	     * @param animationState The animation state object to be staored in the set.
	     */
	    AnimationSetBase.prototype.addAnimation = function (node) {
	        if (this._animationDictionary[node.name])
	            throw new AnimationSetError_1.default("root node name '" + node.name + "' already exists in the set");
	        this._animationDictionary[node.name] = node;
	        this._animations.push(node);
	        this._animationNames.push(node.name);
	    };
	    /**
	     * Cleans up any resources used by the current object.
	     */
	    AnimationSetBase.prototype.dispose = function () {
	    };
	    AnimationSetBase.assetType = "[asset AnimationSet]";
	    return AnimationSetBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationSetBase;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(21);
	var AnimationSetError = (function (_super) {
	    __extends(AnimationSetError, _super);
	    function AnimationSetError(message) {
	        _super.call(this, message);
	    }
	    return AnimationSetError;
	}(ErrorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationSetError;


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Options for setting the animation mode of a vertex animator object.
	 *
	 * @see away.animators.VertexAnimator
	 */
	var VertexAnimationMode = (function () {
	    function VertexAnimationMode() {
	    }
	    /**
	     * Animation mode that adds all outputs from active vertex animation state to form the current vertex animation pose.
	     */
	    VertexAnimationMode.ADDITIVE = "additive";
	    /**
	     * Animation mode that picks the output from a single vertex animation state to form the current vertex animation pose.
	     */
	    VertexAnimationMode.ABSOLUTE = "absolute";
	    return VertexAnimationMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexAnimationMode;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TriangleElements_1 = __webpack_require__(192);
	var ContextGLProgramType_1 = __webpack_require__(123);
	var AnimatorBase_1 = __webpack_require__(221);
	var VertexAnimationMode_1 = __webpack_require__(219);
	/**
	 * Provides an interface for assigning vertex-based animation data sets to sprite-based entity objects
	 * and controlling the various available states of animation through an interative playhead that can be
	 * automatically updated or manually triggered.
	 */
	var VertexAnimator = (function (_super) {
	    __extends(VertexAnimator, _super);
	    /**
	     * Creates a new <code>VertexAnimator</code> object.
	     *
	     * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
	     */
	    function VertexAnimator(vertexAnimationSet) {
	        _super.call(this, vertexAnimationSet);
	        this._poses = new Array();
	        this._weights = new Float32Array([1, 0, 0, 0]);
	        this._vertexAnimationSet = vertexAnimationSet;
	        this._numPoses = vertexAnimationSet.numPoses;
	        this._blendMode = vertexAnimationSet.blendMode;
	    }
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype.clone = function () {
	        return new VertexAnimator(this._vertexAnimationSet);
	    };
	    /**
	     * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
	     * @param sequenceName The name of the clip to be played.
	     */
	    VertexAnimator.prototype.play = function (name, transition, offset) {
	        if (transition === void 0) { transition = null; }
	        if (offset === void 0) { offset = NaN; }
	        if (this._pActiveAnimationName == name)
	            return;
	        this._pActiveAnimationName = name;
	        //TODO: implement transitions in vertex animator
	        if (!this._pAnimationSet.hasAnimation(name))
	            throw new Error("Animation root node " + name + " not found!");
	        this._pActiveNode = this._pAnimationSet.getAnimation(name);
	        this._pActiveState = this.getAnimationState(this._pActiveNode);
	        if (this.updatePosition) {
	            //update straight away to reset position deltas
	            this._pActiveState.update(this._pAbsoluteTime);
	            this._pActiveState.positionDelta;
	        }
	        this._activeVertexState = this._pActiveState;
	        this.start();
	        //apply a time offset if specified
	        if (!isNaN(offset))
	            this.reset(name, offset);
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
	        _super.prototype._pUpdateDeltaTime.call(this, dt);
	        var geometryFlag = false;
	        if (this._poses[0] != this._activeVertexState.currentGraphics) {
	            this._poses[0] = this._activeVertexState.currentGraphics;
	            geometryFlag = true;
	        }
	        if (this._poses[1] != this._activeVertexState.nextGraphics) {
	            this._poses[1] = this._activeVertexState.nextGraphics;
	            geometryFlag = true;
	        }
	        this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);
	        if (geometryFlag) {
	            //invalidate sprites
	            var sprite;
	            var len = this._pOwners.length;
	            for (var i = 0; i < len; i++) {
	                sprite = this._pOwners[i];
	                sprite.graphics.invalidateElements();
	            }
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype.setRenderState = function (shader, renderable, stage, camera, vertexConstantOffset /*int*/, vertexStreamOffset /*int*/) {
	        // todo: add code for when running on cpu
	        // this type of animation can only be SubSprite
	        var graphic = renderable.graphic;
	        var elements = graphic.elements;
	        // if no poses defined, set temp data
	        if (!this._poses.length) {
	            this.setNullPose(shader, elements, stage, vertexConstantOffset, vertexStreamOffset);
	            return;
	        }
	        var i;
	        var len = this._numPoses;
	        stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, vertexConstantOffset, this._weights, 1);
	        if (this._blendMode == VertexAnimationMode_1.default.ABSOLUTE)
	            i = 1;
	        else
	            i = 0;
	        var elementsGL;
	        for (; i < len; ++i) {
	            elements = this._poses[i].getGraphicAt(graphic._iIndex).elements || graphic.elements;
	            elementsGL = shader._elementsPool.getAbstraction(elements);
	            elementsGL._indexMappings = shader._elementsPool.getAbstraction(graphic.elements).getIndexMappings();
	            if (elements.isAsset(TriangleElements_1.default)) {
	                elementsGL.activateVertexBufferVO(vertexStreamOffset++, elements.positions);
	                if (shader.normalDependencies > 0)
	                    elementsGL.activateVertexBufferVO(vertexStreamOffset++, elements.normals);
	            }
	        }
	    };
	    VertexAnimator.prototype.setNullPose = function (shader, elements, stage, vertexConstantOffset /*int*/, vertexStreamOffset /*int*/) {
	        stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, vertexConstantOffset, this._weights, 1);
	        var elementsGL = shader._elementsPool.getAbstraction(elements);
	        if (this._blendMode == VertexAnimationMode_1.default.ABSOLUTE) {
	            var len = this._numPoses;
	            for (var i = 1; i < len; ++i) {
	                if (elements.isAsset(TriangleElements_1.default)) {
	                    elementsGL.activateVertexBufferVO(vertexStreamOffset++, elements.positions);
	                    if (shader.normalDependencies > 0)
	                        elementsGL.activateVertexBufferVO(vertexStreamOffset++, elements.normals);
	                }
	            }
	        }
	        // todo: set temp data for additive?
	    };
	    /**
	     * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
	     * Needs to be called if gpu code is potentially required.
	     */
	    VertexAnimator.prototype.testGPUCompatibility = function (shader) {
	    };
	    VertexAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
	        if (this._blendMode == VertexAnimationMode_1.default.ABSOLUTE && this._poses.length)
	            return this._poses[0].getGraphicAt(renderable.graphic._iIndex).elements || sourceElements;
	        //nothing to do here
	        return sourceElements;
	    };
	    return VertexAnimator;
	}(AnimatorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexAnimator;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var AbstractMethodError_1 = __webpack_require__(20);
	var RequestAnimationFrame_1 = __webpack_require__(38);
	var getTimer_1 = __webpack_require__(39);
	var AnimatorEvent_1 = __webpack_require__(222);
	/**
	 * Dispatched when playback of an animation inside the animator object starts.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="start", type="away3d.events.AnimatorEvent")]
	/**
	 * Dispatched when playback of an animation inside the animator object stops.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="stop", type="away3d.events.AnimatorEvent")]
	/**
	 * Dispatched when playback of an animation reaches the end of an animation.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
	/**
	 * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
	 *
	 * @see away.animators.AnimationSetBase
	 */
	var AnimatorBase = (function (_super) {
	    __extends(AnimatorBase, _super);
	    /**
	     * Creates a new <code>AnimatorBase</code> object.
	     *
	     * @param animationSet The animation data set to be used by the animator object.
	     */
	    function AnimatorBase(animationSet) {
	        _super.call(this);
	        this._autoUpdate = true;
	        this._time = 0;
	        this._playbackSpeed = 1;
	        this._pOwners = new Array();
	        this._pAbsoluteTime = 0;
	        this._animationStates = new Object();
	        /**
	         * Enables translation of the animated sprite from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
	         *
	         * @see away.animators.IAnimationState#positionDelta
	         */
	        this.updatePosition = true;
	        this._pAnimationSet = animationSet;
	        this._broadcaster = new RequestAnimationFrame_1.default(this.onEnterFrame, this);
	    }
	    AnimatorBase.prototype.getAnimationState = function (node) {
	        var className = node.stateClass;
	        var uID = node.id;
	        if (this._animationStates[uID] == null)
	            this._animationStates[uID] = new className(this, node);
	        return this._animationStates[uID];
	    };
	    AnimatorBase.prototype.getAnimationStateByName = function (name) {
	        return this.getAnimationState(this._pAnimationSet.getAnimation(name));
	    };
	    Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
	        /**
	         * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
	         *
	         * @see #time
	         * @see #playbackSpeed
	         */
	        get: function () {
	            return this._pAbsoluteTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "animationSet", {
	        /**
	         * Returns the animation data set in use by the animator.
	         */
	        get: function () {
	            return this._pAnimationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeState", {
	        /**
	         * Returns the current active animation state.
	         */
	        get: function () {
	            return this._pActiveState;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
	        /**
	         * Returns the current active animation node.
	         */
	        get: function () {
	            return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
	        /**
	         * Returns the current active animation node.
	         */
	        get: function () {
	            return this._pActiveAnimationName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
	        /**
	         * Determines whether the animators internal update mechanisms are active. Used in cases
	         * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
	         * Defaults to true.
	         *
	         * @see #time
	         * @see #update()
	         */
	        get: function () {
	            return this._autoUpdate;
	        },
	        set: function (value) {
	            if (this._autoUpdate == value)
	                return;
	            this._autoUpdate = value;
	            if (this._autoUpdate)
	                this.start();
	            else
	                this.stop();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "time", {
	        /**
	         * Gets and sets the internal time clock of the animator.
	         */
	        get: function () {
	            return this._time;
	        },
	        set: function (value /*int*/) {
	            if (this._time == value)
	                return;
	            this.update(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the animation phase of the current active state's animation clip(s).
	     *
	     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
	     */
	    AnimatorBase.prototype.phase = function (value) {
	        this._pActiveState.phase(value);
	    };
	    Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
	        /**
	         * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
	         */
	        get: function () {
	            return this._playbackSpeed;
	        },
	        set: function (value) {
	            this._playbackSpeed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimatorBase.prototype.setRenderState = function (shader, renderable, stage, camera, vertexConstantOffset /*int*/, vertexStreamOffset /*int*/) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Resumes the automatic playback clock controling the active state of the animator.
	     */
	    AnimatorBase.prototype.start = function () {
	        if (this._isPlaying || !this._autoUpdate)
	            return;
	        this._time = this._pAbsoluteTime = getTimer_1.default();
	        this._isPlaying = true;
	        this._broadcaster.start();
	        if (!this.hasEventListener(AnimatorEvent_1.default.START))
	            return;
	        if (this._startEvent == null)
	            this._startEvent = new AnimatorEvent_1.default(AnimatorEvent_1.default.START, this);
	        this.dispatchEvent(this._startEvent);
	    };
	    /**
	     * Pauses the automatic playback clock of the animator, in case manual updates are required via the
	     * <code>time</code> property or <code>update()</code> method.
	     *
	     * @see #time
	     * @see #update()
	     */
	    AnimatorBase.prototype.stop = function () {
	        if (!this._isPlaying)
	            return;
	        this._isPlaying = false;
	        this._broadcaster.stop();
	        if (!this.hasEventListener(AnimatorEvent_1.default.STOP))
	            return;
	        if (this._stopEvent == null)
	            this._stopEvent = new AnimatorEvent_1.default(AnimatorEvent_1.default.STOP, this);
	        this.dispatchEvent(this._stopEvent);
	    };
	    /**
	     * Provides a way to manually update the active state of the animator when automatic
	     * updates are disabled.
	     *
	     * @see #stop()
	     * @see #autoUpdate
	     */
	    AnimatorBase.prototype.update = function (time /*int*/) {
	        var dt = (time - this._time) * this.playbackSpeed;
	        this._pUpdateDeltaTime(dt);
	        this._time = time;
	    };
	    AnimatorBase.prototype.reset = function (name, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
	    };
	    /**
	     * Used by the sprite object to which the animator is applied, registers the owner for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.addOwner = function (sprite) {
	        this._pOwners.push(sprite);
	    };
	    /**
	     * Used by the sprite object from which the animator is removed, unregisters the owner for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.removeOwner = function (sprite) {
	        this._pOwners.splice(this._pOwners.indexOf(sprite), 1);
	    };
	    /**
	     * Internal abstract method called when the time delta property of the animator's contents requires updating.
	     *
	     * @private
	     */
	    AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
	        this._pAbsoluteTime += dt;
	        this._pActiveState.update(this._pAbsoluteTime);
	        if (this.updatePosition)
	            this.applyPositionDelta();
	    };
	    /**
	     * Enter frame event handler for automatically updating the active state of the animator.
	     */
	    AnimatorBase.prototype.onEnterFrame = function (event) {
	        if (event === void 0) { event = null; }
	        this.update(getTimer_1.default());
	    };
	    AnimatorBase.prototype.applyPositionDelta = function () {
	        var delta = this._pActiveState.positionDelta;
	        var dist = delta.length;
	        var len;
	        if (dist > 0) {
	            len = this._pOwners.length;
	            for (var i = 0; i < len; ++i)
	                this._pOwners[i].transform.translateLocal(delta, dist);
	        }
	    };
	    /**
	     *  for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.dispatchCycleEvent = function () {
	        if (this.hasEventListener(AnimatorEvent_1.default.CYCLE_COMPLETE)) {
	            if (this._cycleEvent == null)
	                this._cycleEvent = new AnimatorEvent_1.default(AnimatorEvent_1.default.CYCLE_COMPLETE, this);
	            this.dispatchEvent(this._cycleEvent);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.dispose = function () {
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.testGPUCompatibility = function (shader) {
	        throw new AbstractMethodError_1.default();
	    };
	    Object.defineProperty(AnimatorBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimatorBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimatorBase.prototype.getRenderableElements = function (renderable, sourceElements) {
	        //nothing to do here
	        return sourceElements;
	    };
	    AnimatorBase.assetType = "[asset Animator]";
	    return AnimatorBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimatorBase;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * Dispatched to notify changes in an animator's state.
	 */
	var AnimatorEvent = (function (_super) {
	    __extends(AnimatorEvent, _super);
	    /**
	     * Create a new <code>AnimatorEvent</code> object.
	     *
	     * @param type The event type.
	     * @param animator The animator object that is the subject of this event.
	     */
	    function AnimatorEvent(type, animator) {
	        _super.call(this, type);
	        this._animator = animator;
	    }
	    Object.defineProperty(AnimatorEvent.prototype, "animator", {
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current event object.
	     */
	    AnimatorEvent.prototype.clone = function () {
	        return new AnimatorEvent(this.type, this._animator);
	    };
	    /**
	     * Defines the value of the type property of a start event object.
	     */
	    AnimatorEvent.START = "animatorStart";
	    /**
	     * Defines the value of the type property of a stop event object.
	     */
	    AnimatorEvent.STOP = "animatorStop";
	    /**
	     * Defines the value of the type property of a cycle complete event object.
	     */
	    AnimatorEvent.CYCLE_COMPLETE = "animatorCycleComplete";
	    return AnimatorEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimatorEvent;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationSetBase_1 = __webpack_require__(217);
	/**
	 * The animation data set used by skeleton-based animators, containing skeleton animation data.
	 *
	 * @see away.animators.SkeletonAnimator
	 */
	var SkeletonAnimationSet = (function (_super) {
	    __extends(SkeletonAnimationSet, _super);
	    /**
	     * Creates a new <code>SkeletonAnimationSet</code> object.
	     *
	     * @param jointsPerVertex Sets the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the maximum allowed value is 4. Defaults to 4.
	     */
	    function SkeletonAnimationSet(jointsPerVertex) {
	        if (jointsPerVertex === void 0) { jointsPerVertex = 4; }
	        _super.call(this);
	        this._jointsPerVertex = jointsPerVertex;
	    }
	    Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
	        /**
	         * Returns the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the
	         * maximum allowed value is 4.
	         */
	        get: function () {
	            return this._jointsPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALVertexCode = function (shader) {
	        var len = shader.animatableAttributes.length;
	        var indexOffset0 = shader.numUsedVertexConstants;
	        var indexOffset1 = indexOffset0 + 1;
	        var indexOffset2 = indexOffset0 + 2;
	        var indexStream = "va" + shader.numUsedStreams;
	        var weightStream = "va" + (shader.numUsedStreams + 1);
	        var indices = [indexStream + ".x", indexStream + ".y", indexStream + ".z", indexStream + ".w"];
	        var weights = [weightStream + ".x", weightStream + ".y", weightStream + ".z", weightStream + ".w"];
	        var temp1 = this._pFindTempReg(shader.animationTargetRegisters);
	        var temp2 = this._pFindTempReg(shader.animationTargetRegisters, temp1);
	        var dot = "dp4";
	        var code = "";
	        for (var i = 0; i < len; ++i) {
	            var src = shader.animatableAttributes[i];
	            for (var j = 0; j < this._jointsPerVertex; ++j) {
	                code += dot + " " + temp1 + ".x, " + src + ", vc[" + indices[j] + "+" + indexOffset0 + "]\n" +
	                    dot + " " + temp1 + ".y, " + src + ", vc[" + indices[j] + "+" + indexOffset1 + "]\n" +
	                    dot + " " + temp1 + ".z, " + src + ", vc[" + indices[j] + "+" + indexOffset2 + "]\n" +
	                    "mov " + temp1 + ".w, " + src + ".w\n" +
	                    "mul " + temp1 + ", " + temp1 + ", " + weights[j] + "\n"; // apply weight
	                // add or mov to target. Need to write to a temp reg first, because an output can be a target
	                if (j == 0)
	                    code += "mov " + temp2 + ", " + temp1 + "\n";
	                else
	                    code += "add " + temp2 + ", " + temp2 + ", " + temp1 + "\n";
	            }
	            // switch to dp3 once positions have been transformed, from now on, it should only be vectors instead of points
	            dot = "dp3";
	            code += "mov " + shader.animationTargetRegisters[i] + ", " + temp2 + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.activate = function (shader, stage) {
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.deactivate = function (shader, stage) {
	        //			var streamOffset:number /*uint*/ = pass.numUsedStreams;
	        //			var context:IContextGL = <IContextGL> stage.context;
	        //			context.setVertexBufferAt(streamOffset, null);
	        //			context.setVertexBufferAt(streamOffset + 1, null);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALFragmentCode = function (shader, shadedTarget) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALUVCode = function (shader) {
	        return "mov " + shader.uvTarget + "," + shader.uvSource + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.doneAGALCode = function (shader) {
	    };
	    return SkeletonAnimationSet;
	}(AnimationSetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonAnimationSet;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsEvent_1 = __webpack_require__(78);
	var ContextGLProgramType_1 = __webpack_require__(123);
	var AnimatorBase_1 = __webpack_require__(221);
	var JointPose_1 = __webpack_require__(225);
	var SkeletonPose_1 = __webpack_require__(227);
	var AnimationStateEvent_1 = __webpack_require__(228);
	/**
	 * Provides an interface for assigning skeleton-based animation data sets to sprite-based entity objects
	 * and controlling the various available states of animation through an interative playhead that can be
	 * automatically updated or manually triggered.
	 */
	var SkeletonAnimator = (function (_super) {
	    __extends(SkeletonAnimator, _super);
	    /**
	     * Creates a new <code>SkeletonAnimator</code> object.
	     *
	     * @param skeletonAnimationSet The animation data set containing the skeleton animations used by the animator.
	     * @param skeleton The skeleton object used for calculating the resulting global matrices for transforming skinned sprite data.
	     * @param forceCPU Optional value that only allows the animator to perform calculation on the CPU. Defaults to false.
	     */
	    function SkeletonAnimator(animationSet, skeleton, forceCPU) {
	        var _this = this;
	        if (forceCPU === void 0) { forceCPU = false; }
	        _super.call(this, animationSet);
	        this._globalPose = new SkeletonPose_1.default();
	        this._morphedElements = new Object();
	        this._morphedElementsDirty = new Object();
	        this._skeleton = skeleton;
	        this._forceCPU = forceCPU;
	        this._jointsPerVertex = animationSet.jointsPerVertex;
	        this._numJoints = this._skeleton.numJoints;
	        this._globalMatrices = new Float32Array(this._numJoints * 12);
	        var j = 0;
	        for (var i = 0; i < this._numJoints; ++i) {
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	        }
	        this._onTransitionCompleteDelegate = function (event) { return _this.onTransitionComplete(event); };
	        this._onIndicesUpdateDelegate = function (event) { return _this.onIndicesUpdate(event); };
	        this._onVerticesUpdateDelegate = function (event) { return _this.onVerticesUpdate(event); };
	    }
	    Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
	        /**
	         * returns the calculated global matrices of the current skeleton pose.
	         *
	         * @see #globalPose
	         */
	        get: function () {
	            if (this._globalPropertiesDirty)
	                this.updateGlobalProperties();
	            return this._globalMatrices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
	        /**
	         * returns the current skeleton pose output from the animator.
	         *
	         * @see away.animators.data.SkeletonPose
	         */
	        get: function () {
	            if (this._globalPropertiesDirty)
	                this.updateGlobalProperties();
	            return this._globalPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
	        /**
	         * Returns the skeleton object in use by the animator - this defines the number and heirarchy of joints used by the
	         * skinned geoemtry to which skeleon animator is applied.
	         */
	        get: function () {
	            return this._skeleton;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
	        /**
	         * Indicates whether the skeleton animator is disabled by default for GPU rendering, something that allows the animator to perform calculation on the GPU.
	         * Defaults to false.
	         */
	        get: function () {
	            return this._forceCPU;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "useCondensedIndices", {
	        /**
	         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
	         * by condensing the number of joint index values required per sprite. Only applicable to
	         * skeleton animations that utilise more than one sprite object. Defaults to false.
	         */
	        get: function () {
	            return this._useCondensedIndices;
	        },
	        set: function (value) {
	            this._useCondensedIndices = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.clone = function () {
	        /* The cast to SkeletonAnimationSet should never fail, as _animationSet can only be set
	         through the constructor, which will only accept a SkeletonAnimationSet. */
	        return new SkeletonAnimator(this._pAnimationSet, this._skeleton, this._forceCPU);
	    };
	    /**
	     * Plays an animation state registered with the given name in the animation data set.
	     *
	     * @param name The data set name of the animation state to be played.
	     * @param transition An optional transition object that determines how the animator will transition from the currently active animation state.
	     * @param offset An option offset time (in milliseconds) that resets the state's internal clock to the absolute time of the animator plus the offset value. Required for non-looping animation states.
	     */
	    SkeletonAnimator.prototype.play = function (name, transition, offset) {
	        if (transition === void 0) { transition = null; }
	        if (offset === void 0) { offset = NaN; }
	        if (this._pActiveAnimationName == name)
	            return;
	        this._pActiveAnimationName = name;
	        if (!this._pAnimationSet.hasAnimation(name))
	            throw new Error("Animation root node " + name + " not found!");
	        if (transition && this._pActiveNode) {
	            //setup the transition
	            this._pActiveNode = transition.getAnimationNode(this, this._pActiveNode, this._pAnimationSet.getAnimation(name), this._pAbsoluteTime);
	            this._pActiveNode.addEventListener(AnimationStateEvent_1.default.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
	        }
	        else
	            this._pActiveNode = this._pAnimationSet.getAnimation(name);
	        this._pActiveState = this.getAnimationState(this._pActiveNode);
	        if (this.updatePosition) {
	            //update straight away to reset position deltas
	            this._pActiveState.update(this._pAbsoluteTime);
	            this._pActiveState.positionDelta;
	        }
	        this._activeSkeletonState = this._pActiveState;
	        this.start();
	        //apply a time offset if specified
	        if (!isNaN(offset))
	            this.reset(name, offset);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.setRenderState = function (shader, renderable, stage, camera, vertexConstantOffset /*int*/, vertexStreamOffset /*int*/) {
	        // do on request of globalProperties
	        if (this._globalPropertiesDirty)
	            this.updateGlobalProperties();
	        var elements = renderable.graphic.elements;
	        elements.useCondensedIndices = this._useCondensedIndices;
	        if (this._useCondensedIndices) {
	            // using a condensed data set
	            this.updateCondensedMatrices(elements.condensedIndexLookUp);
	            stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, vertexConstantOffset, this._condensedMatrices, this._condensedMatrices.length / 4);
	        }
	        else {
	            if (this._pAnimationSet.usesCPU) {
	                if (this._morphedElementsDirty[elements.id])
	                    this.morphElements(renderable, elements);
	                return;
	            }
	            stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, vertexConstantOffset, this._globalMatrices, this._numJoints * 3);
	        }
	        shader.jointIndexIndex = vertexStreamOffset++;
	        shader.jointWeightIndex = vertexStreamOffset++;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.testGPUCompatibility = function (shader) {
	        if (!this._useCondensedIndices && (this._forceCPU || this._jointsPerVertex > 4 || shader.numUsedVertexConstants + this._numJoints * 3 > 128))
	            this._pAnimationSet.cancelGPUCompatibility();
	    };
	    /**
	     * Applies the calculated time delta to the active animation state node or state transition object.
	     */
	    SkeletonAnimator.prototype._pUpdateDeltaTime = function (dt) {
	        _super.prototype._pUpdateDeltaTime.call(this, dt);
	        //invalidate pose matrices
	        this._globalPropertiesDirty = true;
	        //trigger geometry invalidation if using CPU animation
	        if (this._pAnimationSet.usesCPU)
	            for (var key in this._morphedElementsDirty)
	                this._morphedElementsDirty[key] = true;
	    };
	    SkeletonAnimator.prototype.updateCondensedMatrices = function (condensedIndexLookUp) {
	        var j = 0, k = 0;
	        var len = condensedIndexLookUp.length;
	        var srcIndex;
	        this._condensedMatrices = new Float32Array(len * 12);
	        for (var i = 0; i < len; i++) {
	            srcIndex = condensedIndexLookUp[i] * 12; //12 required for the three 4-component vectors that store the matrix
	            k = 12;
	            // copy into condensed
	            while (k--)
	                this._condensedMatrices[j++] = this._globalMatrices[srcIndex++];
	        }
	    };
	    SkeletonAnimator.prototype.updateGlobalProperties = function () {
	        this._globalPropertiesDirty = false;
	        //get global pose
	        this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);
	        // convert pose to matrix
	        var mtxOffset = 0;
	        var globalPoses = this._globalPose.jointPoses;
	        var raw;
	        var ox, oy, oz, ow;
	        var xy2, xz2, xw2;
	        var yz2, yw2, zw2;
	        var n11, n12, n13;
	        var n21, n22, n23;
	        var n31, n32, n33;
	        var m11, m12, m13, m14;
	        var m21, m22, m23, m24;
	        var m31, m32, m33, m34;
	        var joints = this._skeleton.joints;
	        var pose;
	        var quat;
	        var vec;
	        var t;
	        for (var i = 0; i < this._numJoints; ++i) {
	            pose = globalPoses[i];
	            quat = pose.orientation;
	            vec = pose.translation;
	            ox = quat.x;
	            oy = quat.y;
	            oz = quat.z;
	            ow = quat.w;
	            xy2 = (t = 2.0 * ox) * oy;
	            xz2 = t * oz;
	            xw2 = t * ow;
	            yz2 = (t = 2.0 * oy) * oz;
	            yw2 = t * ow;
	            zw2 = 2.0 * oz * ow;
	            yz2 = 2.0 * oy * oz;
	            yw2 = 2.0 * oy * ow;
	            zw2 = 2.0 * oz * ow;
	            ox *= ox;
	            oy *= oy;
	            oz *= oz;
	            ow *= ow;
	            n11 = (t = ox - oy) - oz + ow;
	            n12 = xy2 - zw2;
	            n13 = xz2 + yw2;
	            n21 = xy2 + zw2;
	            n22 = -t - oz + ow;
	            n23 = yz2 - xw2;
	            n31 = xz2 - yw2;
	            n32 = yz2 + xw2;
	            n33 = -ox - oy + oz + ow;
	            // prepend inverse bind pose
	            raw = joints[i].inverseBindPose;
	            m11 = raw[0];
	            m12 = raw[4];
	            m13 = raw[8];
	            m14 = raw[12];
	            m21 = raw[1];
	            m22 = raw[5];
	            m23 = raw[9];
	            m24 = raw[13];
	            m31 = raw[2];
	            m32 = raw[6];
	            m33 = raw[10];
	            m34 = raw[14];
	            this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
	            this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
	            this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
	            this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
	            this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
	            this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
	            this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
	            this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
	            this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
	            this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
	            this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
	            this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;
	            mtxOffset = mtxOffset + 12;
	        }
	    };
	    SkeletonAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
	        this._morphedElementsDirty[sourceElements.id] = true;
	        //early out for GPU animations
	        if (!this._pAnimationSet.usesCPU)
	            return sourceElements;
	        var targetElements;
	        if (!(targetElements = this._morphedElements[sourceElements.id])) {
	            //not yet stored
	            targetElements = this._morphedElements[sourceElements.id] = sourceElements.clone();
	            //turn off auto calculations on the morphed geometry
	            targetElements.autoDeriveNormals = false;
	            targetElements.autoDeriveTangents = false;
	            //add event listeners for any changes in UV values on the source geometry
	            sourceElements.addEventListener(ElementsEvent_1.default.INVALIDATE_INDICES, this._onIndicesUpdateDelegate);
	            sourceElements.addEventListener(ElementsEvent_1.default.INVALIDATE_VERTICES, this._onVerticesUpdateDelegate);
	        }
	        return targetElements;
	    };
	    /**
	     * If the animation can't be performed on GPU, transform vertices manually
	     * @param subGeom The subgeometry containing the weights and joint index data per vertex.
	     * @param pass The material pass for which we need to transform the vertices
	     */
	    SkeletonAnimator.prototype.morphElements = function (renderable, sourceElements) {
	        this._morphedElementsDirty[sourceElements.id] = false;
	        var numVertices = sourceElements.numVertices;
	        var sourcePositions = sourceElements.positions.get(numVertices);
	        var sourceNormals = sourceElements.normals.get(numVertices);
	        var sourceTangents = sourceElements.tangents.get(numVertices);
	        var posDim = sourceElements.positions.dimensions;
	        var jointIndices = sourceElements.jointIndices.get(numVertices);
	        var jointWeights = sourceElements.jointWeights.get(numVertices);
	        var targetElements = this._morphedElements[sourceElements.id];
	        var targetPositions = targetElements.positions.get(numVertices);
	        var targetNormals = targetElements.normals.get(numVertices);
	        var targetTangents = targetElements.tangents.get(numVertices);
	        var index = 0;
	        var i0 = 0;
	        var i1 = 0;
	        var j = 0;
	        var k;
	        var vx, vy, vz;
	        var nx, ny, nz;
	        var tx, ty, tz;
	        var weight;
	        var vertX, vertY, vertZ;
	        var normX, normY, normZ;
	        var tangX, tangY, tangZ;
	        var m11, m12, m13, m14;
	        var m21, m22, m23, m24;
	        var m31, m32, m33, m34;
	        while (index < numVertices) {
	            i0 = index * posDim;
	            vertX = sourcePositions[i0];
	            vertY = sourcePositions[i0 + 1];
	            vertZ = (posDim == 3) ? sourcePositions[i0 + 2] : 0;
	            i1 = index * 3;
	            normX = sourceNormals[i1];
	            normY = sourceNormals[i1 + 1];
	            normZ = sourceNormals[i1 + 2];
	            tangX = sourceTangents[i1];
	            tangY = sourceTangents[i1 + 1];
	            tangZ = sourceTangents[i1 + 2];
	            vx = 0;
	            vy = 0;
	            vz = 0;
	            nx = 0;
	            ny = 0;
	            nz = 0;
	            tx = 0;
	            ty = 0;
	            tz = 0;
	            k = 0;
	            while (k < this._jointsPerVertex) {
	                weight = jointWeights[j];
	                if (weight > 0) {
	                    // implicit /3*12 (/3 because indices are multiplied by 3 for gpu matrix access, *12 because it's the matrix size)
	                    var mtxOffset = jointIndices[j++] << 2;
	                    m11 = this._globalMatrices[mtxOffset];
	                    m12 = this._globalMatrices[mtxOffset + 1];
	                    m13 = this._globalMatrices[mtxOffset + 2];
	                    m14 = this._globalMatrices[mtxOffset + 3];
	                    m21 = this._globalMatrices[mtxOffset + 4];
	                    m22 = this._globalMatrices[mtxOffset + 5];
	                    m23 = this._globalMatrices[mtxOffset + 6];
	                    m24 = this._globalMatrices[mtxOffset + 7];
	                    m31 = this._globalMatrices[mtxOffset + 8];
	                    m32 = this._globalMatrices[mtxOffset + 9];
	                    m33 = this._globalMatrices[mtxOffset + 10];
	                    m34 = this._globalMatrices[mtxOffset + 11];
	                    vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
	                    vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
	                    vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
	                    nx += weight * (m11 * normX + m12 * normY + m13 * normZ);
	                    ny += weight * (m21 * normX + m22 * normY + m23 * normZ);
	                    nz += weight * (m31 * normX + m32 * normY + m33 * normZ);
	                    tx += weight * (m11 * tangX + m12 * tangY + m13 * tangZ);
	                    ty += weight * (m21 * tangX + m22 * tangY + m23 * tangZ);
	                    tz += weight * (m31 * tangX + m32 * tangY + m33 * tangZ);
	                    ++k;
	                }
	                else {
	                    j += (this._jointsPerVertex - k);
	                    k = this._jointsPerVertex;
	                }
	            }
	            targetPositions[i0] = vx;
	            targetPositions[i0 + 1] = vy;
	            if (posDim == 3)
	                targetPositions[i0 + 2] = vz;
	            targetNormals[i1] = nx;
	            targetNormals[i1 + 1] = ny;
	            targetNormals[i1 + 2] = nz;
	            targetTangents[i1] = tx;
	            targetTangents[i1 + 1] = ty;
	            targetTangents[i1 + 2] = tz;
	            index++;
	        }
	        targetElements.setPositions(targetPositions);
	        targetElements.setNormals(targetNormals);
	        targetElements.setTangents(targetTangents);
	    };
	    /**
	     * Converts a local hierarchical skeleton pose to a global pose
	     * @param targetPose The SkeletonPose object that will contain the global pose.
	     * @param skeleton The skeleton containing the joints, and as such, the hierarchical data to transform to global poses.
	     */
	    SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
	        var globalPoses = targetPose.jointPoses;
	        var globalJointPose;
	        var joints = skeleton.joints;
	        var len = sourcePose.numJointPoses;
	        var jointPoses = sourcePose.jointPoses;
	        var parentIndex;
	        var joint;
	        var parentPose;
	        var pose;
	        var or;
	        var tr;
	        var t;
	        var q;
	        var x1, y1, z1, w1;
	        var x2, y2, z2, w2;
	        var x3, y3, z3;
	        // :s
	        if (globalPoses.length != len)
	            globalPoses.length = len;
	        for (var i = 0; i < len; ++i) {
	            globalJointPose = globalPoses[i];
	            if (globalJointPose == null)
	                globalJointPose = globalPoses[i] = new JointPose_1.default();
	            joint = joints[i];
	            parentIndex = joint.parentIndex;
	            pose = jointPoses[i];
	            q = globalJointPose.orientation;
	            t = globalJointPose.translation;
	            if (parentIndex < 0) {
	                tr = pose.translation;
	                or = pose.orientation;
	                q.x = or.x;
	                q.y = or.y;
	                q.z = or.z;
	                q.w = or.w;
	                t.x = tr.x;
	                t.y = tr.y;
	                t.z = tr.z;
	            }
	            else {
	                // append parent pose
	                parentPose = globalPoses[parentIndex];
	                // rotate point
	                or = parentPose.orientation;
	                tr = pose.translation;
	                x2 = or.x;
	                y2 = or.y;
	                z2 = or.z;
	                w2 = or.w;
	                x3 = tr.x;
	                y3 = tr.y;
	                z3 = tr.z;
	                w1 = -x2 * x3 - y2 * y3 - z2 * z3;
	                x1 = w2 * x3 + y2 * z3 - z2 * y3;
	                y1 = w2 * y3 - x2 * z3 + z2 * x3;
	                z1 = w2 * z3 + x2 * y3 - y2 * x3;
	                // append parent translation
	                tr = parentPose.translation;
	                t.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
	                t.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
	                t.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;
	                // append parent orientation
	                x1 = or.x;
	                y1 = or.y;
	                z1 = or.z;
	                w1 = or.w;
	                or = pose.orientation;
	                x2 = or.x;
	                y2 = or.y;
	                z2 = or.z;
	                w2 = or.w;
	                q.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
	                q.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
	                q.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
	                q.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
	            }
	        }
	    };
	    SkeletonAnimator.prototype.onTransitionComplete = function (event) {
	        if (event.type == AnimationStateEvent_1.default.TRANSITION_COMPLETE) {
	            event.animationNode.removeEventListener(AnimationStateEvent_1.default.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
	            //if this is the current active state transition, revert control to the active node
	            if (this._pActiveState == event.animationState) {
	                this._pActiveNode = this._pAnimationSet.getAnimation(this._pActiveAnimationName);
	                this._pActiveState = this.getAnimationState(this._pActiveNode);
	                this._activeSkeletonState = this._pActiveState;
	            }
	        }
	    };
	    SkeletonAnimator.prototype.onIndicesUpdate = function (event) {
	        var elements = event.target;
	        this._morphedElements[elements.id].setIndices(elements.indices);
	    };
	    SkeletonAnimator.prototype.onVerticesUpdate = function (event) {
	        var elements = event.target;
	        var morphGraphics = this._morphedElements[elements.id];
	        switch (event.attributesView) {
	            case elements.uvs:
	                morphGraphics.setUVs(elements.uvs.get(elements.numVertices));
	                break;
	            case elements.getCustomAtributes("secondaryUVs"):
	                morphGraphics.setCustomAttributes("secondaryUVs", elements.getCustomAtributes("secondaryUVs").get(elements.numVertices));
	                break;
	        }
	    };
	    return SkeletonAnimator;
	}(AnimatorBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonAnimator;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3D_1 = __webpack_require__(28);
	var Quaternion_1 = __webpack_require__(226);
	var Vector3D_1 = __webpack_require__(30);
	/**
	 * Contains transformation data for a skeleton joint, used for skeleton animation.
	 *
	 * @see away.animation.Skeleton
	 * @see away.animation.SkeletonJoint
	 *
	 * todo: support (uniform) scale
	 */
	var JointPose = (function () {
	    function JointPose() {
	        /**
	         * The rotation of the pose stored as a quaternion
	         */
	        this.orientation = new Quaternion_1.default();
	        /**
	         * The translation of the pose
	         */
	        this.translation = new Vector3D_1.default();
	    }
	    /**
	     * Converts the transformation to a Matrix3D representation.
	     *
	     * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
	     * @return The transformation matrix of the pose.
	     */
	    JointPose.prototype.toMatrix3D = function (target) {
	        if (target === void 0) { target = null; }
	        if (target == null)
	            target = new Matrix3D_1.default();
	        this.orientation.toMatrix3D(target);
	        target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
	        return target;
	    };
	    /**
	     * Copies the transformation data from a source pose object into the existing pose object.
	     *
	     * @param pose The source pose to copy from.
	     */
	    JointPose.prototype.copyFrom = function (pose) {
	        var or = pose.orientation;
	        var tr = pose.translation;
	        this.orientation.x = or.x;
	        this.orientation.y = or.y;
	        this.orientation.z = or.z;
	        this.orientation.w = or.w;
	        this.translation.x = tr.x;
	        this.translation.y = tr.y;
	        this.translation.z = tr.z;
	    };
	    return JointPose;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = JointPose;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3DUtils_1 = __webpack_require__(27);
	var Orientation3D_1 = __webpack_require__(32);
	var Matrix3D_1 = __webpack_require__(28);
	var Vector3D_1 = __webpack_require__(30);
	/**
	 * A Quaternion object which can be used to represent rotations.
	 */
	var Quaternion = (function () {
	    /**
	     * Creates a new Quaternion object.
	     * @param x The x value of the quaternion.
	     * @param y The y value of the quaternion.
	     * @param z The z value of the quaternion.
	     * @param w The w value of the quaternion.
	     */
	    function Quaternion(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 1; }
	        /**
	         * The x value of the quaternion.
	         */
	        this.x = 0;
	        /**
	         * The y value of the quaternion.
	         */
	        this.y = 0;
	        /**
	         * The z value of the quaternion.
	         */
	        this.z = 0;
	        /**
	         * The w value of the quaternion.
	         */
	        this.w = 1;
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    Object.defineProperty(Quaternion.prototype, "magnitude", {
	        /**
	         * Returns the magnitude of the quaternion object.
	         */
	        get: function () {
	            return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Fills the quaternion object with the result from a multiplication of two quaternion objects.
	     *
	     * @param    qa    The first quaternion in the multiplication.
	     * @param    qb    The second quaternion in the multiplication.
	     */
	    Quaternion.prototype.multiply = function (qa, qb) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
	        this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
	        this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
	        this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
	    };
	    Quaternion.prototype.multiplyVector = function (vector, target) {
	        if (target === void 0) { target = null; }
	        //target ||= new Quaternion();
	        if (target === null) {
	            target = new Quaternion();
	        }
	        var x2 = vector.x;
	        var y2 = vector.y;
	        var z2 = vector.z;
	        target.w = -this.x * x2 - this.y * y2 - this.z * z2;
	        target.x = this.w * x2 + this.y * z2 - this.z * y2;
	        target.y = this.w * y2 - this.x * z2 + this.z * x2;
	        target.z = this.w * z2 + this.x * y2 - this.y * x2;
	        return target;
	    };
	    /**
	     * Fills the quaternion object with values representing the given rotation around a vector.
	     *
	     * @param    axis    The axis around which to rotate
	     * @param    angle    The angle in radians of the rotation.
	     */
	    Quaternion.prototype.fromAxisAngle = function (axis, angle) {
	        var sin_a = Math.sin(angle / 2);
	        var cos_a = Math.cos(angle / 2);
	        this.x = axis.x * sin_a;
	        this.y = axis.y * sin_a;
	        this.z = axis.z * sin_a;
	        this.w = cos_a;
	        this.normalize();
	    };
	    /**
	     * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
	     * @param qa The first quaternion to interpolate.
	     * @param qb The second quaternion to interpolate.
	     * @param t The interpolation weight, a value between 0 and 1.
	     */
	    Quaternion.prototype.slerp = function (qa, qb, t) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
	        // shortest direction
	        if (dot < 0) {
	            dot = -dot;
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }
	        if (dot < 0.95) {
	            // interpolate angle linearly
	            var angle = Math.acos(dot);
	            var s = 1 / Math.sin(angle);
	            var s1 = Math.sin(angle * (1 - t)) * s;
	            var s2 = Math.sin(angle * t) * s;
	            this.w = w1 * s1 + w2 * s2;
	            this.x = x1 * s1 + x2 * s2;
	            this.y = y1 * s1 + y2 * s2;
	            this.z = z1 * s1 + z2 * s2;
	        }
	        else {
	            // nearly identical angle, interpolate linearly
	            this.w = w1 + t * (w2 - w1);
	            this.x = x1 + t * (x2 - x1);
	            this.y = y1 + t * (y2 - y1);
	            this.z = z1 + t * (z2 - z1);
	            var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	            this.w *= len;
	            this.x *= len;
	            this.y *= len;
	            this.z *= len;
	        }
	    };
	    /**
	     * Linearly interpolates between two quaternions.
	     * @param qa The first quaternion to interpolate.
	     * @param qb The second quaternion to interpolate.
	     * @param t The interpolation weight, a value between 0 and 1.
	     */
	    Quaternion.prototype.lerp = function (qa, qb, t) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        var len;
	        // shortest direction
	        if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }
	        this.w = w1 + t * (w2 - w1);
	        this.x = x1 + t * (x2 - x1);
	        this.y = y1 + t * (y2 - y1);
	        this.z = z1 + t * (z2 - z1);
	        len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	        this.w *= len;
	        this.x *= len;
	        this.y *= len;
	        this.z *= len;
	    };
	    /**
	     * Fills the quaternion object with values representing the given euler rotation.
	     *
	     * @param    ax        The angle in radians of the rotation around the ax axis.
	     * @param    ay        The angle in radians of the rotation around the ay axis.
	     * @param    az        The angle in radians of the rotation around the az axis.
	     */
	    Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
	        var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
	        var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
	        var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
	        var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
	        this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
	        this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
	        this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
	        this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
	    };
	    /**
	     * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
	     * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
	     * @return The Vector3D containing the Euler angles.
	     */
	    Quaternion.prototype.toEulerAngles = function (target) {
	        if (target === void 0) { target = null; }
	        //target ||= new Vector3D();
	        if (target === null) {
	            target = new Vector3D_1.default();
	        }
	        target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
	        target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
	        target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
	        return target;
	    };
	    /**
	     * Normalises the quaternion object.
	     */
	    Quaternion.prototype.normalize = function (val) {
	        if (val === void 0) { val = 1; }
	        var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	        this.x *= mag;
	        this.y *= mag;
	        this.z *= mag;
	        this.w *= mag;
	    };
	    /**
	     * Used to trace the values of a quaternion.
	     *
	     * @return A string representation of the quaternion object.
	     */
	    Quaternion.prototype.toString = function () {
	        return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
	    };
	    /**
	     * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
	     * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
	     * @return A Matrix3D object representing an equivalent rotation.
	     */
	    Quaternion.prototype.toMatrix3D = function (target) {
	        if (target === void 0) { target = null; }
	        var rawData = Matrix3DUtils_1.default.RAW_DATA_CONTAINER;
	        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
	        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
	        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
	        rawData[0] = xx - yy - zz + ww;
	        rawData[4] = xy2 - zw2;
	        rawData[8] = xz2 + yw2;
	        rawData[12] = 0;
	        rawData[1] = xy2 + zw2;
	        rawData[5] = -xx + yy - zz + ww;
	        rawData[9] = yz2 - xw2;
	        rawData[13] = 0;
	        rawData[2] = xz2 - yw2;
	        rawData[6] = yz2 + xw2;
	        rawData[10] = -xx - yy + zz + ww;
	        rawData[14] = 0;
	        rawData[3] = 0.0;
	        rawData[7] = 0.0;
	        rawData[11] = 0;
	        rawData[15] = 1;
	        if (!target)
	            return new Matrix3D_1.default(rawData);
	        else
	            target.copyRawDataFrom(rawData);
	        return target;
	    };
	    /**
	     * Extracts a quaternion rotation matrix out of a given Matrix3D object.
	     * @param matrix The Matrix3D out of which the rotation will be extracted.
	     */
	    Quaternion.prototype.fromMatrix = function (matrix) {
	        var v = matrix.decompose(Orientation3D_1.default.QUATERNION)[1];
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        this.w = v.w;
	    };
	    /**
	     * Converts the quaternion to a Vector.&lt;Number&gt; matrix representation of a rotation equivalent to this quaternion.
	     * @param target The Vector.&lt;Number&gt; to contain the raw matrix data.
	     * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
	     */
	    Quaternion.prototype.toRawData = function (target, exclude4thRow) {
	        if (exclude4thRow === void 0) { exclude4thRow = false; }
	        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
	        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
	        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
	        target[0] = xx - yy - zz + ww;
	        target[1] = xy2 - zw2;
	        target[2] = xz2 + yw2;
	        target[4] = xy2 + zw2;
	        target[5] = -xx + yy - zz + ww;
	        target[6] = yz2 - xw2;
	        target[8] = xz2 - yw2;
	        target[9] = yz2 + xw2;
	        target[10] = -xx - yy + zz + ww;
	        target[3] = target[7] = target[11] = 0;
	        if (!exclude4thRow) {
	            target[12] = target[13] = target[14] = 0;
	            target[15] = 1;
	        }
	    };
	    /**
	     * Clones the quaternion.
	     * @return An exact duplicate of the current Quaternion.
	     */
	    Quaternion.prototype.clone = function () {
	        return new Quaternion(this.x, this.y, this.z, this.w);
	    };
	    /**
	     * Rotates a point.
	     * @param vector The Vector3D object to be rotated.
	     * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
	     * @return A Vector3D object containing the rotated point.
	     */
	    Quaternion.prototype.rotatePoint = function (vector, target) {
	        if (target === void 0) { target = null; }
	        var x1, y1, z1, w1;
	        var x2 = vector.x, y2 = vector.y, z2 = vector.z;
	        //target ||= new Vector3D();
	        if (target === null) {
	            target = new Vector3D_1.default();
	        }
	        // p*q'
	        w1 = -this.x * x2 - this.y * y2 - this.z * z2;
	        x1 = this.w * x2 + this.y * z2 - this.z * y2;
	        y1 = this.w * y2 - this.x * z2 + this.z * x2;
	        z1 = this.w * z2 + this.x * y2 - this.y * x2;
	        target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
	        target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
	        target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
	        return target;
	    };
	    /**
	     * Copies the data from a quaternion into this instance.
	     * @param q The quaternion to copy from.
	     */
	    Quaternion.prototype.copyFrom = function (q) {
	        this.x = q.x;
	        this.y = q.y;
	        this.z = q.z;
	        this.w = q.w;
	    };
	    return Quaternion;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Quaternion;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var JointPose_1 = __webpack_require__(225);
	/**
	 * A collection of pose objects, determining the pose for an entire skeleton.
	 * The <code>jointPoses</code> vector object corresponds to a skeleton's <code>joints</code> vector object, however, there is no
	 * reference to a skeleton's instance, since several skeletons can be influenced by the same pose (eg: animation
	 * clips are added to any animator with a valid skeleton)
	 *
	 * @see away.animators.Skeleton
	 * @see away.animators.JointPose
	 */
	var SkeletonPose = (function (_super) {
	    __extends(SkeletonPose, _super);
	    /**
	     * Creates a new <code>SkeletonPose</code> object.
	     */
	    function SkeletonPose() {
	        _super.call(this);
	        this.jointPoses = new Array();
	    }
	    Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
	        /**
	         * The total number of joint poses in the skeleton pose.
	         */
	        get: function () {
	            return this.jointPoses.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonPose.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return SkeletonPose.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the joint pose object with the given joint name, otherwise returns a null object.
	     *
	     * @param jointName The name of the joint object whose pose is to be found.
	     * @return The pose object with the given joint name.
	     */
	    SkeletonPose.prototype.jointPoseFromName = function (jointName) {
	        var jointPoseIndex = this.jointPoseIndexFromName(jointName);
	        if (jointPoseIndex != -1)
	            return this.jointPoses[jointPoseIndex];
	        else
	            return null;
	    };
	    /**
	     * Returns the pose index, given the joint name. -1 is returned if the joint name is not found in the pose.
	     *
	     * @param The name of the joint object whose pose is to be found.
	     * @return The index of the pose object in the jointPoses Array
	     *
	     * @see #jointPoses
	     */
	    SkeletonPose.prototype.jointPoseIndexFromName = function (jointName) {
	        // this is implemented as a linear search, rather than a possibly
	        // more optimal method (Dictionary lookup, for example) because:
	        // a) it is assumed that it will be called once for each joint
	        // b) it is assumed that it will be called only during load, and not during main loop
	        // c) maintaining a dictionary (for safety) would dictate an interface to access JointPoses,
	        //    rather than direct array access.  this would be sub-optimal.
	        var jointPoseIndex;
	        var jointPose;
	        for (var i; i < this.jointPoses.length; i++) {
	            jointPose = this.jointPoses[i];
	            if (jointPose.name == jointName)
	                return jointPoseIndex;
	            jointPoseIndex++;
	        }
	        return -1;
	    };
	    /**
	     * Creates a copy of the <code>SkeletonPose</code> object, with a dulpicate of its component joint poses.
	     *
	     * @return SkeletonPose
	     */
	    SkeletonPose.prototype.clone = function () {
	        var clone = new SkeletonPose();
	        var numJointPoses = this.jointPoses.length;
	        for (var i = 0; i < numJointPoses; i++) {
	            var cloneJointPose = new JointPose_1.default();
	            var thisJointPose = this.jointPoses[i];
	            cloneJointPose.name = thisJointPose.name;
	            cloneJointPose.copyFrom(thisJointPose);
	            clone.jointPoses[i] = cloneJointPose;
	        }
	        return clone;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonPose.prototype.dispose = function () {
	        this.jointPoses.length = 0;
	    };
	    SkeletonPose.assetType = "[asset SkeletonPose]";
	    return SkeletonPose;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonPose;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	/**
	 * Dispatched to notify changes in an animation state's state.
	 */
	var AnimationStateEvent = (function (_super) {
	    __extends(AnimationStateEvent, _super);
	    /**
	     * Create a new <code>AnimatonStateEvent</code>
	     *
	     * @param type The event type.
	     * @param animator The animation state object that is the subject of this event.
	     * @param animationNode The animation node inside the animation state from which the event originated.
	     */
	    function AnimationStateEvent(type, animator, animationState, animationNode) {
	        _super.call(this, type);
	        this._animator = animator;
	        this._animationState = animationState;
	        this._animationNode = animationNode;
	    }
	    Object.defineProperty(AnimationStateEvent.prototype, "animator", {
	        /**
	         * The animator object that is the subject of this event.
	         */
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
	        /**
	         * The animation state object that is the subject of this event.
	         */
	        get: function () {
	            return this._animationState;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
	        /**
	         * The animation node inside the animation state from which the event originated.
	         */
	        get: function () {
	            return this._animationNode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    AnimationStateEvent.prototype.clone = function () {
	        return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
	    };
	    /**
	     * Dispatched when a non-looping clip node inside an animation state reaches the end of its timeline.
	     */
	    AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";
	    AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
	    return AnimationStateEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationStateEvent;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 * A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
	 *
	 * @see away.animators.SkeletonJoint
	 */
	var Skeleton = (function (_super) {
	    __extends(Skeleton, _super);
	    /**
	     * Creates a new <code>Skeleton</code> object
	     */
	    function Skeleton() {
	        _super.call(this);
	        // in the long run, it might be a better idea to not store Joint objects, but keep all data in Vectors, that we can upload easily?
	        this.joints = new Array();
	    }
	    Object.defineProperty(Skeleton.prototype, "numJoints", {
	        /**
	         * The total number of joints in the skeleton.
	         */
	        get: function () {
	            return this.joints.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the joint object in the skeleton with the given name, otherwise returns a null object.
	     *
	     * @param jointName The name of the joint object to be found.
	     * @return The joint object with the given name.
	     *
	     * @see #joints
	     */
	    Skeleton.prototype.jointFromName = function (jointName) {
	        var jointIndex = this.jointIndexFromName(jointName);
	        if (jointIndex != -1)
	            return this.joints[jointIndex];
	        else
	            return null;
	    };
	    /**
	     * Returns the joint index, given the joint name. -1 is returned if the joint name is not found.
	     *
	     * @param jointName The name of the joint object to be found.
	     * @return The index of the joint object in the joints Array
	     *
	     * @see #joints
	     */
	    Skeleton.prototype.jointIndexFromName = function (jointName) {
	        // this is implemented as a linear search, rather than a possibly
	        // more optimal method (Dictionary lookup, for example) because:
	        // a) it is assumed that it will be called once for each joint
	        // b) it is assumed that it will be called only during load, and not during main loop
	        // c) maintaining a dictionary (for safety) would dictate an interface to access SkeletonJoints,
	        //    rather than direct array access.  this would be sub-optimal.
	        var jointIndex;
	        var joint;
	        for (var i; i < this.joints.length; i++) {
	            joint = this.joints[i];
	            if (joint.name == jointName)
	                return jointIndex;
	            jointIndex++;
	        }
	        return -1;
	    };
	    /**
	     * @inheritDoc
	     */
	    Skeleton.prototype.dispose = function () {
	        this.joints.length = 0;
	    };
	    Object.defineProperty(Skeleton.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return Skeleton.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Skeleton.assetType = "[asset Skeleton]";
	    return Skeleton;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Skeleton;


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A value obect representing a single joint in a skeleton object.
	 *
	 * @see away.animators.Skeleton
	 */
	var SkeletonJoint = (function () {
	    /**
	     * Creates a new <code>SkeletonJoint</code> object
	     */
	    function SkeletonJoint() {
	        /**
	         * The index of the parent joint in the skeleton's joints vector.
	         *
	         * @see away.animators.Skeleton#joints
	         */
	        this.parentIndex = -1;
	    }
	    return SkeletonJoint;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonJoint;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationClipNodeBase_1 = __webpack_require__(232);
	var SkeletonClipState_1 = __webpack_require__(234);
	/**
	 * A skeleton animation node containing time-based animation data as individual skeleton poses.
	 */
	var SkeletonClipNode = (function (_super) {
	    __extends(SkeletonClipNode, _super);
	    /**
	     * Creates a new <code>SkeletonClipNode</code> object.
	     */
	    function SkeletonClipNode() {
	        _super.call(this);
	        this._frames = new Array();
	        /**
	         * Determines whether to use SLERP equations (true) or LERP equations (false) in the calculation
	         * of the output skeleton pose. Defaults to false.
	         */
	        this.highQuality = false;
	        this._pStateClass = SkeletonClipState_1.default;
	    }
	    Object.defineProperty(SkeletonClipNode.prototype, "frames", {
	        /**
	         * Returns a vector of skeleton poses representing the pose of each animation frame in the clip.
	         */
	        get: function () {
	            return this._frames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a skeleton pose frame to the internal timeline of the animation node.
	     *
	     * @param skeletonPose The skeleton pose object to add to the timeline of the node.
	     * @param duration The specified duration of the frame in milliseconds.
	     */
	    SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration /*number /*uint*/) {
	        this._frames.push(skeletonPose);
	        this._pDurations.push(duration);
	        this._pNumFrames = this._pDurations.length;
	        this._pStitchDirty = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipNode.prototype._pUpdateStitch = function () {
	        _super.prototype._pUpdateStitch.call(this);
	        var i = this._pNumFrames - 1;
	        var p1, p2, delta;
	        while (i--) {
	            this._pTotalDuration += this._pDurations[i];
	            p1 = this._frames[i].jointPoses[0].translation;
	            p2 = this._frames[i + 1].jointPoses[0].translation;
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	        if (this._pStitchFinalFrame || !this._pLooping) {
	            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
	            p1 = this._frames[0].jointPoses[0].translation;
	            p2 = this._frames[1].jointPoses[0].translation;
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	    };
	    return SkeletonClipNode;
	}(AnimationClipNodeBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonClipNode;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(30);
	var AnimationNodeBase_1 = __webpack_require__(233);
	/**
	 * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
	 */
	var AnimationClipNodeBase = (function (_super) {
	    __extends(AnimationClipNodeBase, _super);
	    /**
	     * Creates a new <code>AnimationClipNodeBase</code> object.
	     */
	    function AnimationClipNodeBase() {
	        _super.call(this);
	        this._pLooping = true;
	        this._pTotalDuration = 0;
	        this._pStitchDirty = true;
	        this._pStitchFinalFrame = false;
	        this._pNumFrames = 0;
	        this._pDurations = new Array();
	        /*uint*/
	        this._pTotalDelta = new Vector3D_1.default();
	        this.fixedFrameRate = true;
	    }
	    Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
	        /**
	         * Determines whether the contents of the animation node have looping characteristics enabled.
	         */
	        get: function () {
	            return this._pLooping;
	        },
	        set: function (value) {
	            if (this._pLooping == value)
	                return;
	            this._pLooping = value;
	            this._pStitchDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
	        /**
	         * Defines if looping content blends the final frame of animation data with the first (true) or works on the
	         * assumption that both first and last frames are identical (false). Defaults to false.
	         */
	        get: function () {
	            return this._pStitchFinalFrame;
	        },
	        set: function (value) {
	            if (this._pStitchFinalFrame == value)
	                return;
	            this._pStitchFinalFrame = value;
	            this._pStitchDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pTotalDuration;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pTotalDelta;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pLastFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
	        /**
	         * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
	         */
	        get: function () {
	            return this._pDurations;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates the node's final frame stitch state.
	     *
	     * @see #stitchFinalFrame
	     */
	    AnimationClipNodeBase.prototype._pUpdateStitch = function () {
	        this._pStitchDirty = false;
	        this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;
	        this._pTotalDuration = 0;
	        this._pTotalDelta.x = 0;
	        this._pTotalDelta.y = 0;
	        this._pTotalDelta.z = 0;
	    };
	    return AnimationClipNodeBase;
	}(AnimationNodeBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationClipNodeBase;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 * Provides an abstract base class for nodes in an animation blend tree.
	 */
	var AnimationNodeBase = (function (_super) {
	    __extends(AnimationNodeBase, _super);
	    /**
	     * Creates a new <code>AnimationNodeBase</code> object.
	     */
	    function AnimationNodeBase() {
	        _super.call(this);
	    }
	    Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
	        get: function () {
	            return this._pStateClass;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AnimationNodeBase.prototype.dispose = function () {
	    };
	    Object.defineProperty(AnimationNodeBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimationNodeBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimationNodeBase.assetType = "[asset AnimationNodeBase]";
	    return AnimationNodeBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationNodeBase;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(30);
	var JointPose_1 = __webpack_require__(225);
	var SkeletonPose_1 = __webpack_require__(227);
	var AnimationClipState_1 = __webpack_require__(235);
	/**
	 *
	 */
	var SkeletonClipState = (function (_super) {
	    __extends(SkeletonClipState, _super);
	    function SkeletonClipState(animator, skeletonClipNode) {
	        _super.call(this, animator, skeletonClipNode);
	        this._rootPos = new Vector3D_1.default();
	        this._skeletonPose = new SkeletonPose_1.default();
	        this._skeletonPoseDirty = true;
	        this._skeletonClipNode = skeletonClipNode;
	        this._frames = this._skeletonClipNode.frames;
	    }
	    Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
	        /**
	         * Returns the current skeleton pose frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._currentPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
	        /**
	         * Returns the next skeleton pose frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._nextPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdateTime = function (time /*int*/) {
	        this._skeletonPoseDirty = true;
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdateFrames = function () {
	        _super.prototype._pUpdateFrames.call(this);
	        this._currentPose = this._frames[this._pCurrentFrame];
	        if (this._skeletonClipNode.looping && this._pNextFrame >= this._skeletonClipNode.lastFrame) {
	            this._nextPose = this._frames[0];
	            this._pAnimator.dispatchCycleEvent();
	        }
	        else
	            this._nextPose = this._frames[this._pNextFrame];
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the internal playhead position.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        if (!this._skeletonClipNode.totalDuration)
	            return;
	        if (this._pFramesDirty)
	            this._pUpdateFrames();
	        var currentPose = this._currentPose.jointPoses;
	        var nextPose = this._nextPose.jointPoses;
	        var numJoints = skeleton.numJoints;
	        var p1, p2;
	        var pose1, pose2;
	        var endPoses = this._skeletonPose.jointPoses;
	        var endPose;
	        var tr;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
	            throw new Error("joint counts don't match!");
	        for (var i = 0; i < numJoints; ++i) {
	            endPose = endPoses[i];
	            if (endPose == null)
	                endPose = endPoses[i] = new JointPose_1.default();
	            pose1 = currentPose[i];
	            pose2 = nextPose[i];
	            p1 = pose1.translation;
	            p2 = pose2.translation;
	            if (this._skeletonClipNode.highQuality)
	                endPose.orientation.slerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
	            else
	                endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
	            if (i > 0) {
	                tr = endPose.translation;
	                tr.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
	                tr.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
	                tr.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
	            }
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        if (this._pFramesDirty)
	            this._pUpdateFrames();
	        var p1, p2, p3;
	        var totalDelta = this._skeletonClipNode.totalDelta;
	        // jumping back, need to reset position
	        if ((this._pTimeDir > 0 && this._pNextFrame < this._pOldFrame) || (this._pTimeDir < 0 && this._pNextFrame > this._pOldFrame)) {
	            this._rootPos.x -= totalDelta.x * this._pTimeDir;
	            this._rootPos.y -= totalDelta.y * this._pTimeDir;
	            this._rootPos.z -= totalDelta.z * this._pTimeDir;
	        }
	        var dx = this._rootPos.x;
	        var dy = this._rootPos.y;
	        var dz = this._rootPos.z;
	        if (this._skeletonClipNode.stitchFinalFrame && this._pNextFrame == this._skeletonClipNode.lastFrame) {
	            p1 = this._frames[0].jointPoses[0].translation;
	            p2 = this._frames[1].jointPoses[0].translation;
	            p3 = this._currentPose.jointPoses[0].translation;
	            this._rootPos.x = p3.x + p1.x + this._pBlendWeight * (p2.x - p1.x);
	            this._rootPos.y = p3.y + p1.y + this._pBlendWeight * (p2.y - p1.y);
	            this._rootPos.z = p3.z + p1.z + this._pBlendWeight * (p2.z - p1.z);
	        }
	        else {
	            p1 = this._currentPose.jointPoses[0].translation;
	            p2 = this._frames[this._pNextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
	            this._rootPos.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
	            this._rootPos.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
	            this._rootPos.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
	        }
	        this._pRootDelta.x = this._rootPos.x - dx;
	        this._pRootDelta.y = this._rootPos.y - dy;
	        this._pRootDelta.z = this._rootPos.z - dz;
	        this._pOldFrame = this._pNextFrame;
	    };
	    return SkeletonClipState;
	}(AnimationClipState_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonClipState;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationStateBase_1 = __webpack_require__(236);
	var AnimationStateEvent_1 = __webpack_require__(228);
	/**
	 *
	 */
	var AnimationClipState = (function (_super) {
	    __extends(AnimationClipState, _super);
	    function AnimationClipState(animator, animationClipNode) {
	        _super.call(this, animator, animationClipNode);
	        this._pFramesDirty = true;
	        this._animationClipNode = animationClipNode;
	    }
	    Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
	        /**
	         * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
	         * between the current frame (0) and next frame (1) of the animation.
	         *
	         * @see #currentFrame
	         * @see #nextFrame
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pBlendWeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
	        /**
	         * Returns the current frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pCurrentFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
	        /**
	         * Returns the next frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pNextFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype.update = function (time /*int*/) {
	        if (!this._animationClipNode.looping) {
	            if (time > this._pStartTime + this._animationClipNode.totalDuration)
	                time = this._pStartTime + this._animationClipNode.totalDuration;
	            else if (time < this._pStartTime)
	                time = this._pStartTime;
	        }
	        if (this._pTime == time - this._pStartTime)
	            return;
	        this._pUpdateTime(time);
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype.phase = function (value) {
	        var time = value * this._animationClipNode.totalDuration + this._pStartTime;
	        if (this._pTime == time - this._pStartTime)
	            return;
	        this._pUpdateTime(time);
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype._pUpdateTime = function (time /*int*/) {
	        this._pFramesDirty = true;
	        this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
	     *
	     * @see #currentFrame
	     * @see #nextFrame
	     * @see #blendWeight
	     */
	    AnimationClipState.prototype._pUpdateFrames = function () {
	        this._pFramesDirty = false;
	        var looping = this._animationClipNode.looping;
	        var totalDuration = this._animationClipNode.totalDuration;
	        var lastFrame = this._animationClipNode.lastFrame;
	        var time = this._pTime;
	        //trace("time", time, totalDuration)
	        if (looping && (time >= totalDuration || time < 0)) {
	            time %= totalDuration;
	            if (time < 0)
	                time += totalDuration;
	        }
	        if (!looping && time >= totalDuration) {
	            this.notifyPlaybackComplete();
	            this._pCurrentFrame = lastFrame;
	            this._pNextFrame = lastFrame;
	            this._pBlendWeight = 0;
	        }
	        else if (!looping && time <= 0) {
	            this._pCurrentFrame = 0;
	            this._pNextFrame = 0;
	            this._pBlendWeight = 0;
	        }
	        else if (this._animationClipNode.fixedFrameRate) {
	            var t = time / totalDuration * lastFrame;
	            this._pCurrentFrame = Math.floor(t);
	            this._pBlendWeight = t - this._pCurrentFrame;
	            this._pNextFrame = this._pCurrentFrame + 1;
	        }
	        else {
	            this._pCurrentFrame = 0;
	            this._pNextFrame = 0;
	            var dur = 0, frameTime;
	            var durations = this._animationClipNode.durations;
	            do {
	                frameTime = dur;
	                dur += durations[this._pNextFrame];
	                this._pCurrentFrame = this._pNextFrame++;
	            } while (time > dur);
	            if (this._pCurrentFrame == lastFrame) {
	                this._pCurrentFrame = 0;
	                this._pNextFrame = 1;
	            }
	            this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
	        }
	    };
	    AnimationClipState.prototype.notifyPlaybackComplete = function () {
	        if (this._animationStatePlaybackComplete == null)
	            this._animationStatePlaybackComplete = new AnimationStateEvent_1.default(AnimationStateEvent_1.default.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);
	        this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
	    };
	    return AnimationClipState;
	}(AnimationStateBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationClipState;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(30);
	/**
	 *
	 */
	var AnimationStateBase = (function () {
	    function AnimationStateBase(animator, animationNode) {
	        this._pRootDelta = new Vector3D_1.default();
	        this._pPositionDeltaDirty = true;
	        this._pStartTime = 0;
	        this._pAnimator = animator;
	        this._pAnimationNode = animationNode;
	    }
	    Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
	        /**
	         * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
	         */
	        get: function () {
	            if (this._pPositionDeltaDirty) {
	                this._pUpdatePositionDelta();
	            }
	            return this._pRootDelta;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Resets the start time of the node to a  new value.
	     *
	     * @param startTime The absolute start time (in milliseconds) of the node's starting time.
	     */
	    AnimationStateBase.prototype.offset = function (startTime) {
	        this._pStartTime = startTime;
	        this._pPositionDeltaDirty = true;
	    };
	    /**
	     * Updates the configuration of the node to its current state.
	     *
	     * @param time The absolute time (in milliseconds) of the animator's play head position.
	     *
	     * @see AnimatorBase#update()
	     */
	    AnimationStateBase.prototype.update = function (time) {
	        if (this._pTime == time - this._pStartTime) {
	            return;
	        }
	        this._pUpdateTime(time);
	    };
	    /**
	     * Sets the animation phase of the node.
	     *
	     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
	     */
	    AnimationStateBase.prototype.phase = function (value) {
	    };
	    /**
	     * Updates the node's internal playhead position.
	     *
	     * @param time The local time (in milliseconds) of the node's playhead position.
	     */
	    AnimationStateBase.prototype._pUpdateTime = function (time) {
	        this._pTime = time - this._pStartTime;
	        this._pPositionDeltaDirty = true;
	    };
	    /**
	     * Updates the node's root delta position
	     */
	    AnimationStateBase.prototype._pUpdatePositionDelta = function () {
	    };
	    return AnimationStateBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AnimationStateBase;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(30);
	var AnimationClipNodeBase_1 = __webpack_require__(232);
	var VertexClipState_1 = __webpack_require__(238);
	/**
	 * A vertex animation node containing time-based animation data as individual geometry obejcts.
	 */
	var VertexClipNode = (function (_super) {
	    __extends(VertexClipNode, _super);
	    /**
	     * Creates a new <code>VertexClipNode</code> object.
	     */
	    function VertexClipNode() {
	        _super.call(this);
	        this._frames = new Array();
	        this._translations = new Array();
	        this._pStateClass = VertexClipState_1.default;
	    }
	    Object.defineProperty(VertexClipNode.prototype, "frames", {
	        /**
	         * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
	         */
	        get: function () {
	            return this._frames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a geometry object to the internal timeline of the animation node.
	     *
	     * @param geometry The geometry object to add to the timeline of the node.
	     * @param duration The specified duration of the frame in milliseconds.
	     * @param translation The absolute translation of the frame, used in root delta calculations for sprite movement.
	     */
	    VertexClipNode.prototype.addFrame = function (geometry, duration /*uint*/, translation) {
	        if (translation === void 0) { translation = null; }
	        this._frames.push(geometry);
	        this._pDurations.push(duration);
	        this._translations.push(translation || new Vector3D_1.default());
	        this._pNumFrames = this._pDurations.length;
	        this._pStitchDirty = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexClipNode.prototype._pUpdateStitch = function () {
	        _super.prototype._pUpdateStitch.call(this);
	        var i = this._pNumFrames - 1;
	        var p1, p2, delta;
	        while (i--) {
	            this._pTotalDuration += this._pDurations[i];
	            p1 = this._translations[i];
	            p2 = this._translations[i + 1];
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	        if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
	            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
	            p1 = this._translations[0];
	            p2 = this._translations[1];
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	    };
	    return VertexClipNode;
	}(AnimationClipNodeBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexClipNode;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationClipState_1 = __webpack_require__(235);
	/**
	 *
	 */
	var VertexClipState = (function (_super) {
	    __extends(VertexClipState, _super);
	    function VertexClipState(animator, vertexClipNode) {
	        _super.call(this, animator, vertexClipNode);
	        this._vertexClipNode = vertexClipNode;
	        this._frames = this._vertexClipNode.frames;
	    }
	    Object.defineProperty(VertexClipState.prototype, "currentGraphics", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._currentGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexClipState.prototype, "nextGraphics", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._nextGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    VertexClipState.prototype._pUpdateFrames = function () {
	        _super.prototype._pUpdateFrames.call(this);
	        this._currentGraphics = this._frames[this._pCurrentFrame];
	        if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
	            this._nextGraphics = this._frames[0];
	            this._pAnimator.dispatchCycleEvent();
	        }
	        else
	            this._nextGraphics = this._frames[this._pNextFrame];
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexClipState.prototype._pUpdatePositionDelta = function () {
	        //TODO:implement positiondelta functionality for vertex animations
	    };
	    return VertexClipState;
	}(AnimationClipState_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VertexClipState;


/***/ },
/* 239 */
/***/ function(module, exports) {

	"use strict";
	var MethodMaterialMode = (function () {
	    function MethodMaterialMode() {
	    }
	    /**
	     *
	     */
	    MethodMaterialMode.SINGLE_PASS = "singlePass";
	    /**
	     *
	     */
	    MethodMaterialMode.MULTI_PASS = "multiPass";
	    return MethodMaterialMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MethodMaterialMode;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(90);
	var MaterialBase_1 = __webpack_require__(153);
	var Single2DTexture_1 = __webpack_require__(169);
	var ContextGLCompareMode_1 = __webpack_require__(98);
	var MethodMaterialMode_1 = __webpack_require__(239);
	var AmbientBasicMethod_1 = __webpack_require__(241);
	var DiffuseBasicMethod_1 = __webpack_require__(244);
	var NormalBasicMethod_1 = __webpack_require__(246);
	var SpecularBasicMethod_1 = __webpack_require__(247);
	/**
	 * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var MethodMaterial = (function (_super) {
	    __extends(MethodMaterial, _super);
	    function MethodMaterial(imageColor, alpha) {
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this, imageColor, alpha);
	        this._effectMethods = new Array();
	        this._ambientMethod = new AmbientBasicMethod_1.default();
	        this._diffuseMethod = new DiffuseBasicMethod_1.default();
	        this._normalMethod = new NormalBasicMethod_1.default();
	        this._specularMethod = new SpecularBasicMethod_1.default();
	        this._depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;
	        this._mode = MethodMaterialMode_1.default.SINGLE_PASS;
	        //add default methods owners
	        this._ambientMethod.iAddOwner(this);
	        this._diffuseMethod.iAddOwner(this);
	        this._normalMethod.iAddOwner(this);
	        this._specularMethod.iAddOwner(this);
	        //set a texture if an image is present
	        if (imageColor instanceof Image2D_1.default)
	            this._ambientMethod.texture = new Single2DTexture_1.default();
	    }
	    Object.defineProperty(MethodMaterial.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return MethodMaterial.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "mode", {
	        get: function () {
	            return this._mode;
	        },
	        set: function (value) {
	            if (this._mode == value)
	                return;
	            this._mode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "depthCompareMode", {
	        /**
	         * The depth compare mode used to render the renderables using this material.
	         *
	         * @see away.stagegl.ContextGLCompareMode
	         */
	        get: function () {
	            return this._depthCompareMode;
	        },
	        set: function (value) {
	            if (this._depthCompareMode == value)
	                return;
	            this._depthCompareMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "diffuseTexture", {
	        /**
	         * The texture object to use for the ambient colour.
	         */
	        get: function () {
	            return this._diffuseMethod.texture;
	        },
	        set: function (value) {
	            this._diffuseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "ambientMethod", {
	        /**
	         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
	         */
	        get: function () {
	            return this._ambientMethod;
	        },
	        set: function (value) {
	            if (this._ambientMethod == value)
	                return;
	            if (this._ambientMethod)
	                this._ambientMethod.iRemoveOwner(this);
	            this._ambientMethod = value;
	            if (this._ambientMethod)
	                this._ambientMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "shadowMethod", {
	        /**
	         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
	         */
	        get: function () {
	            return this._shadowMethod;
	        },
	        set: function (value) {
	            if (this._shadowMethod == value)
	                return;
	            if (this._shadowMethod)
	                this._shadowMethod.iRemoveOwner(this);
	            this._shadowMethod = value;
	            if (this._shadowMethod)
	                this._shadowMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "diffuseMethod", {
	        /**
	         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
	         */
	        get: function () {
	            return this._diffuseMethod;
	        },
	        set: function (value) {
	            if (this._diffuseMethod == value)
	                return;
	            if (this._diffuseMethod)
	                this._diffuseMethod.iRemoveOwner(this);
	            this._diffuseMethod = value;
	            if (this._diffuseMethod)
	                this._diffuseMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "specularMethod", {
	        /**
	         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
	         */
	        get: function () {
	            return this._specularMethod;
	        },
	        set: function (value) {
	            if (this._specularMethod == value)
	                return;
	            if (this._specularMethod)
	                this._specularMethod.iRemoveOwner(this);
	            this._specularMethod = value;
	            if (this._specularMethod)
	                this._specularMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "normalMethod", {
	        /**
	         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
	         */
	        get: function () {
	            return this._normalMethod;
	        },
	        set: function (value) {
	            if (this._normalMethod == value)
	                return;
	            if (this._normalMethod)
	                this._normalMethod.iRemoveOwner(this);
	            this._normalMethod = value;
	            if (this._normalMethod)
	                this._normalMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "numEffectMethods", {
	        get: function () {
	            return this._effectMethods.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
	     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
	     * methods added prior.
	     */
	    MethodMaterial.prototype.addEffectMethod = function (method) {
	        method.iAddOwner(this);
	        this._effectMethods.push(method);
	        this.invalidate();
	    };
	    /**
	     * Returns the method added at the given index.
	     * @param index The index of the method to retrieve.
	     * @return The method at the given index.
	     */
	    MethodMaterial.prototype.getEffectMethodAt = function (index) {
	        return this._effectMethods[index];
	    };
	    /**
	     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
	     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
	     * etc. The method will be applied to the result of the methods with a lower index.
	     */
	    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {
	        method.iAddOwner(this);
	        this._effectMethods.splice(index, 0, method);
	        this.invalidate();
	    };
	    /**
	     * Removes an effect method from the material.
	     * @param method The method to be removed.
	     */
	    MethodMaterial.prototype.removeEffectMethod = function (method) {
	        method.iRemoveOwner(this);
	        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);
	        this.invalidate();
	    };
	    MethodMaterial.assetType = "[materials MethodMaterial]";
	    return MethodMaterial;
	}(MaterialBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MethodMaterial;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var ShadingMethodBase_1 = __webpack_require__(242);
	/**
	 * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
	 */
	var AmbientBasicMethod = (function (_super) {
	    __extends(AmbientBasicMethod, _super);
	    /**
	     * Creates a new AmbientBasicMethod object.
	     */
	    function AmbientBasicMethod() {
	        _super.call(this);
	        this._alpha = 1;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	        this._strength = 1;
	    }
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));
	            methodVO.textureGL = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iInitConstants = function (shader, methodVO) {
	        if (!methodVO.textureGL) {
	            this._color = shader.numLights ? 0xFFFFFF : methodVO.pass._surface.style.color;
	            this.updateColor();
	        }
	    };
	    Object.defineProperty(AmbientBasicMethod.prototype, "strength", {
	        /**
	         * The strength of the ambient reflection of the surface.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            if (this._strength == value)
	                return;
	            this._strength = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AmbientBasicMethod.prototype, "alpha", {
	        /**
	         * The alpha component of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            if (this._alpha == value)
	                return;
	            this._alpha = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AmbientBasicMethod.prototype, "texture", {
	        /**
	         * The texture to use to define the diffuse reflection color per texel.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.copyFrom = function (method) {
	        var m = method;
	        var b = m;
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (methodVO.textureGL) {
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            if (shader.alphaThreshold > 0) {
	                var cutOffReg = registerCache.getFreeFragmentConstant();
	                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;
	                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" +
	                    "kil " + targetReg + ".w\n" +
	                    "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
	            }
	        }
	        else {
	            var ambientInputRegister = registerCache.getFreeFragmentConstant();
	            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;
	            code += "mov " + targetReg + ", " + ambientInputRegister + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (methodVO.textureGL) {
	            methodVO.textureGL.activate(methodVO.pass._render);
	            if (shader.alphaThreshold > 0)
	                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;
	        }
	        else {
	            var index = methodVO.fragmentConstantsIndex;
	            var data = shader.fragmentConstantData;
	            data[index] = this._colorR;
	            data[index + 1] = this._colorG;
	            data[index + 2] = this._colorB;
	            data[index + 3] = this._alpha;
	        }
	    };
	    AmbientBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (methodVO.textureGL)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Updates the ambient color data used by the render state.
	     */
	    AmbientBasicMethod.prototype.updateColor = function () {
	        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._strength;
	        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._strength;
	        this._colorB = (this._color & 0xff) / 0xff * this._strength;
	    };
	    return AmbientBasicMethod;
	}(ShadingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AmbientBasicMethod;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var ShadingMethodEvent_1 = __webpack_require__(243);
	/**
	 * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
	 * the final shading program.
	 */
	var ShadingMethodBase = (function (_super) {
	    __extends(ShadingMethodBase, _super);
	    /**
	     * Create a new ShadingMethodBase object.
	     */
	    function ShadingMethodBase() {
	        _super.call(this);
	        this._textures = new Array();
	        this._owners = new Array();
	        this._counts = new Array();
	    }
	    Object.defineProperty(ShadingMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return ShadingMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadingMethodBase.prototype.iIsUsed = function (shader) {
	        return true;
	    };
	    /**
	     * Initializes the properties for a MethodVO, including register and texture indices.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInitVO = function (shader, methodVO) {
	    };
	    /**
	     * Initializes unchanging shader constants using the data from a MethodVO.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInitConstants = function (shader, methodVO) {
	    };
	    /**
	     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.
	     */
	    ShadingMethodBase.prototype.iUsesTangentSpace = function () {
	        return true;
	    };
	    /**
	     * Cleans up any resources used by the current object.
	     */
	    ShadingMethodBase.prototype.dispose = function () {
	    };
	    ShadingMethodBase.prototype.iAddOwner = function (owner) {
	        //a method can be used more than once in the same material, so we check for this
	        var index = this._owners.indexOf(owner);
	        if (index != -1) {
	            this._counts[index]++;
	        }
	        else {
	            this._owners.push(owner);
	            this._counts.push(1);
	            //add textures
	            var len = this._textures.length;
	            for (var i = 0; i < len; i++)
	                owner.addTexture(this._textures[i]);
	        }
	    };
	    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {
	        var index = this._owners.indexOf(owner);
	        if (this._counts[index] != 1) {
	            this._counts[index]--;
	        }
	        else {
	            this._owners.splice(index, 1);
	            this._counts.splice(index, 1);
	            //remove textures
	            var len = this._textures.length;
	            for (var i = 0; i < len; i++)
	                owner.removeTexture(this._textures[i]);
	        }
	    };
	    /**
	     *
	     */
	    ShadingMethodBase.prototype.iAddTexture = function (texture) {
	        this._textures.push(texture);
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].addTexture(texture);
	    };
	    /**
	     *
	     */
	    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].removeTexture(texture);
	    };
	    /**
	     * Resets the compilation state of the method.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iReset = function () {
	        this.iCleanCompilationData();
	    };
	    /**
	     * Resets the method's state for compilation.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iCleanCompilationData = function () {
	    };
	    /**
	     * Get the vertex shader code for this method.
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadingMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return null;
	    };
	    /**
	     * Sets the render state for this method.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param stage The Stage object currently used for rendering.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iActivate = function (shader, methodVO, stage) {
	    };
	    /**
	     * Sets the render state for a single renderable.
	     *
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param renderable The renderable currently being rendered.
	     * @param stage The Stage object currently used for rendering.
	     * @param camera The camera from which the scene is currently rendered.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	    };
	    /**
	     * Clears the render state for this method.
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param stage The Stage object currently used for rendering.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iDeactivate = function (shader, methodVO, stage) {
	    };
	    /**
	     * Marks the shader program as invalid, so it will be recompiled before the next render.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
	        this.dispatchEvent(new ShadingMethodEvent_1.default(ShadingMethodEvent_1.default.SHADER_INVALIDATED));
	    };
	    /**
	     * Copies the state from a ShadingMethodBase object into the current object.
	     */
	    ShadingMethodBase.prototype.copyFrom = function (method) {
	    };
	    ShadingMethodBase.assetType = "[asset ShadingMethod]";
	    return ShadingMethodBase;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadingMethodBase;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(2);
	var ShadingMethodEvent = (function (_super) {
	    __extends(ShadingMethodEvent, _super);
	    function ShadingMethodEvent(type) {
	        _super.call(this, type);
	    }
	    ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
	    return ShadingMethodEvent;
	}(EventBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadingMethodEvent;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var LightingMethodBase_1 = __webpack_require__(245);
	/**
	 * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.
	 */
	var DiffuseBasicMethod = (function (_super) {
	    __extends(DiffuseBasicMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     */
	    function DiffuseBasicMethod() {
	        _super.call(this);
	        this._multiply = true;
	        this._ambientColorR = 1;
	        this._ambientColorG = 1;
	        this._ambientColorB = 1;
	        this._color = 0xffffff;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	    }
	    DiffuseBasicMethod.prototype.iIsUsed = function (shader) {
	        if (!shader.numLights)
	            return false;
	        return true;
	    };
	    Object.defineProperty(DiffuseBasicMethod.prototype, "multiply", {
	        /**
	         * Set internally if diffuse color component multiplies or replaces the ambient color
	         */
	        get: function () {
	            return this._multiply;
	        },
	        set: function (value) {
	            if (this._multiply == value)
	                return;
	            this._multiply = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DiffuseBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));
	            methodVO.textureGL = null;
	        }
	        if (shader.numLights > 0) {
	            shader.usesCommonData = true;
	            methodVO.needsNormals = true;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iInitConstants = function (shader, methodVO) {
	        if (shader.numLights > 0) {
	            this._ambientColor = methodVO.pass._surface.style.color;
	            this.updateAmbientColor();
	        }
	        else {
	            this._ambientColor = null;
	        }
	    };
	    Object.defineProperty(DiffuseBasicMethod.prototype, "color", {
	        /**
	         * The color of the diffuse reflection when not using a texture.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            this._color = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseBasicMethod.prototype, "texture", {
	        /**
	         * The texture to use to define the diffuse reflection color per texel.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.dispose = function () {
	        this._texture = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.copyFrom = function (method) {
	        var diff = method;
	        this.texture = diff.texture;
	        this.multiply = diff.multiply;
	        this.color = diff.color;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pTotalLightColorReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        this._pIsFirstLight = true;
	        registerCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".x, " + lightDirReg + ", " + sharedRegisters.normalFragment + "\n" +
	            "max " + t + ".w, " + t + ".x, " + sharedRegisters.commons + ".y\n";
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "tex " + t + ", " + sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" +
	            "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var diffuseColor;
	        var cutOffReg;
	        // incorporate input from ambient
	        if (sharedRegisters.shadowTarget)
	            code += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);
	        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);
	        var ambientColorRegister = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;
	        if (this._texture) {
	            code += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        }
	        else {
	            var diffuseInputRegister = registerCache.getFreeFragmentConstant();
	            code += "mov " + diffuseColor + ", " + diffuseInputRegister + "\n";
	        }
	        code += "sat " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + "\n" +
	            "mul " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._pTotalLightColorReg + "\n";
	        if (this._multiply) {
	            code += "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + ambientColorRegister + "\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n";
	        }
	        else if (this._texture) {
	            code += "mul " + targetReg + ".xyz, " + targetReg + ", " + ambientColorRegister + "\n" +
	                "mul " + this._pTotalLightColorReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" +
	                "sub " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; //add diffuse color and ambient color
	        }
	        else {
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._pTotalLightColorReg + "\n" +
	                "sub " + this._pTotalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._pTotalLightColorReg + "\n" +
	                "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._pTotalLightColorReg + "\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; // multiply by target which could be texture or white
	        }
	        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	        registerCache.removeFragmentTempUsage(diffuseColor);
	        return code;
	    };
	    /**
	     * Generate the code that applies the calculated shadow to the diffuse light
	     * @param methodVO The MethodVO object for which the compilation is currently happening.
	     * @param regCache The register cache the compiler is currently using for the register management.
	     */
	    DiffuseBasicMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {
	        return "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture) {
	            methodVO.textureGL.activate(methodVO.pass._render);
	        }
	        else {
	            var index = methodVO.fragmentConstantsIndex;
	            var data = shader.fragmentConstantData;
	            if (this._multiply) {
	                data[index + 4] = this._colorR * this._ambientColorR;
	                data[index + 5] = this._colorG * this._ambientColorG;
	                data[index + 6] = this._colorB * this._ambientColorB;
	            }
	            else {
	                data[index + 4] = this._colorR;
	                data[index + 5] = this._colorG;
	                data[index + 6] = this._colorB;
	            }
	            data[index + 7] = 1;
	        }
	    };
	    /**
	     * Updates the diffuse color data used by the render state.
	     */
	    DiffuseBasicMethod.prototype.updateColor = function () {
	        this._colorR = ((this._color >> 16) & 0xff) / 0xff;
	        this._colorG = ((this._color >> 8) & 0xff) / 0xff;
	        this._colorB = (this._color & 0xff) / 0xff;
	    };
	    /**
	     * Updates the ambient color data used by the render state.
	     */
	    DiffuseBasicMethod.prototype.updateAmbientColor = function () {
	        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;
	        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;
	        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = shader.ambientR * this._ambientColorR;
	        data[index + 1] = shader.ambientG * this._ambientColorG;
	        data[index + 2] = shader.ambientB * this._ambientColorB;
	        data[index + 3] = 1;
	    };
	    return DiffuseBasicMethod;
	}(LightingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseBasicMethod;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(242);
	/**
	 * LightingMethodBase provides an abstract base method for shading methods that uses lights.
	 * Used for diffuse and specular shaders only.
	 */
	var LightingMethodBase = (function (_super) {
	    __extends(LightingMethodBase, _super);
	    /**
	     * Creates a new LightingMethodBase.
	     */
	    function LightingMethodBase() {
	        _super.call(this);
	    }
	    /**
	     * Get the fragment shader code that will be needed before any per-light code is added.
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @private
	     */
	    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that will generate the code relevant to a single light.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param lightDirReg The register containing the light direction vector.
	     * @param lightColReg The register containing the light colour.
	     * @param regCache The register cache used during the compilation.
	     */
	    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that will generate the code relevant to a single light probe object.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param cubeMapReg The register containing the cube map for the current probe
	     * @param weightRegister A string representation of the register + component containing the current weight
	     * @param regCache The register cache providing any necessary registers to the shader
	     */
	    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register containing the final shading output.
	     * @private
	     */
	    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "";
	    };
	    return LightingMethodBase;
	}(ShadingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LightingMethodBase;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(242);
	/**
	 * NormalBasicMethod is the default method for standard tangent-space normal mapping.
	 */
	var NormalBasicMethod = (function (_super) {
	    __extends(NormalBasicMethod, _super);
	    /**
	     * Creates a new NormalBasicMethod object.
	     */
	    function NormalBasicMethod(texture) {
	        if (texture === void 0) { texture = null; }
	        _super.call(this);
	        this._texture = texture;
	        if (this._texture)
	            this.iAddTexture(this._texture);
	    }
	    NormalBasicMethod.prototype.iIsUsed = function (shader) {
	        if (this._texture && shader.normalDependencies)
	            return true;
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	    };
	    /**
	     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
	     */
	    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.copyFrom = function (method) {
	        var s = method;
	        var bnm = method;
	        if (bnm.texture != null)
	            this.texture = bnm.texture;
	    };
	    Object.defineProperty(NormalBasicMethod.prototype, "texture", {
	        /**
	         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects
	         * tangent-space normal maps, but others could expect object-space maps.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.dispose = function () {
	        if (this._texture)
	            this._texture = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture)
	            methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    NormalBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (this._texture)
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        code += "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx\n" +
	            "nrm " + targetReg + ".xyz, " + targetReg + "\n";
	        return code;
	    };
	    return NormalBasicMethod;
	}(ShadingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = NormalBasicMethod;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var LightingMethodBase_1 = __webpack_require__(245);
	/**
	 * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
	 * version of Phong specularity).
	 */
	var SpecularBasicMethod = (function (_super) {
	    __extends(SpecularBasicMethod, _super);
	    /**
	     * Creates a new SpecularBasicMethod object.
	     */
	    function SpecularBasicMethod() {
	        _super.call(this);
	        this._gloss = 50;
	        this._strength = 1;
	        this._color = 0xffffff;
	        this._iSpecularR = 1;
	        this._iSpecularG = 1;
	        this._iSpecularB = 1;
	    }
	    SpecularBasicMethod.prototype.iIsUsed = function (shader) {
	        if (!shader.numLights)
	            return false;
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = shader.numLights > 0;
	        methodVO.needsView = shader.numLights > 0;
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));
	            methodVO.textureGL = null;
	        }
	    };
	    Object.defineProperty(SpecularBasicMethod.prototype, "gloss", {
	        /**
	         * The glossiness of the material (sharpness of the specular highlight).
	         */
	        get: function () {
	            return this._gloss;
	        },
	        set: function (value) {
	            this._gloss = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "strength", {
	        /**
	         * The overall strength of the specular highlights.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            if (value == this._strength)
	                return;
	            this._strength = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "color", {
	        /**
	         * The colour of the specular reflection of the surface.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            // specular is now either enabled or disabled
	            if (this._color == 0 || value == 0)
	                this.iInvalidateShaderProgram();
	            this._color = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "texture", {
	        /**
	         * A texture that defines the strength of specular reflections for each texel in the red channel,
	         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set
	         * specular and gloss maps from grayscale images, but correctly authored images are preferred.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.copyFrom = function (method) {
	        var m = method;
	        var bsm = method;
	        var spec = bsm; //SpecularBasicMethod(method);
	        this.texture = spec.texture;
	        this.strength = spec.strength;
	        this.color = spec.color;
	        this.gloss = spec.gloss;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pTotalLightColorReg = null;
	        this._pSpecularTexData = null;
	        this._pSpecularDataRegister = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        this._pIsFirstLight = true;
	        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;
	        if (this._texture) {
	            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);
	            code += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        }
	        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        // blinn-phong half vector model
	        code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" +
	            "nrm " + t + ".xyz, " + t + "\n" +
	            "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" +
	            "sat " + t + ".w, " + t + ".w\n";
	        if (this._texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else {
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        }
	        // attenuate
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var normalReg = sharedRegisters.normalFragment;
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" +
	            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ", " + t + ".w, " + normalReg + "\n" +
	            "sub " + t + ", " + t + ", " + viewDirReg + "\n" +
	            "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + "linear" + ",miplinear>\n" +
	            "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (sharedRegisters.shadowTarget)
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
	        if (this._texture) {
	            // apply strength modulation from texture
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularTexData + ".x\n";
	            registerCache.removeFragmentTempUsage(this._pSpecularTexData);
	        }
	        // apply material's specular reflection
	        code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularDataRegister + "\n" +
	            "add " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n";
	        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture)
	            methodVO.textureGL.activate(methodVO.pass._render);
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._iSpecularR;
	        data[index + 1] = this._iSpecularG;
	        data[index + 2] = this._iSpecularB;
	        data[index + 3] = this._gloss;
	    };
	    SpecularBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Updates the specular color data used by the render state.
	     */
	    SpecularBasicMethod.prototype.updateSpecular = function () {
	        this._iSpecularR = ((this._color >> 16) & 0xff) / 0xff * this._strength;
	        this._iSpecularG = ((this._color >> 8) & 0xff) / 0xff * this._strength;
	        this._iSpecularB = (this._color & 0xff) / 0xff * this._strength;
	    };
	    return SpecularBasicMethod;
	}(LightingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularBasicMethod;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var AmbientBasicMethod_1 = __webpack_require__(241);
	/**
	 * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to
	 * approximate global lighting rather than lights.
	 */
	var AmbientEnvMapMethod = (function (_super) {
	    __extends(AmbientEnvMapMethod, _super);
	    /**
	     * Creates a new <code>AmbientEnvMapMethod</code> object.
	     *
	     * @param envMap The cube environment map to use for the ambient lighting.
	     */
	    function AmbientEnvMapMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    AmbientEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));
	            methodVO.textureGL = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        return (this._texture) ? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : "";
	    };
	    return AmbientEnvMapMethod;
	}(AmbientBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AmbientEnvMapMethod;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(244);
	/**
	 * DiffuseDepthMethod provides a debug method to visualise depth maps
	 */
	var DiffuseDepthMethod = (function (_super) {
	    __extends(DiffuseDepthMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     */
	    function DiffuseDepthMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseDepthMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = 1.0;
	        data[index + 1] = 1 / 255.0;
	        data[index + 2] = 1 / 65025.0;
	        data[index + 3] = 1 / 16581375.0;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var temp;
	        var decReg;
	        if (!this._texture)
	            throw new Error("DiffuseDepthMethod requires texture!");
	        // incorporate input from ambient
	        if (shader.numLights > 0) {
	            if (sharedRegisters.shadowTarget)
	                code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + sharedRegisters.shadowTarget + ".w\n";
	            code += "add " + targetReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + targetReg + ".xyz\n" +
	                "sat " + targetReg + ".xyz, " + targetReg + ".xyz\n";
	            registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	            registerCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);
	        }
	        else {
	            temp = targetReg;
	        }
	        decReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	            "dp4 " + temp + ".x, " + temp + ", " + decReg + "\n" +
	            "mov " + temp + ".yz, " + temp + ".xx			\n" +
	            "mov " + temp + ".w, " + decReg + ".x\n" +
	            "sub " + temp + ".xyz, " + decReg + ".xxx, " + temp + ".xyz\n";
	        if (shader.numLights == 0)
	            return code;
	        code += "mul " + targetReg + ".xyz, " + temp + ".xyz, " + targetReg + ".xyz\n" +
	            "mov " + targetReg + ".w, " + temp + ".w\n";
	        if (shader.numLights > 0)
	            registerCache.removeFragmentTempUsage(temp);
	        return code;
	    };
	    return DiffuseDepthMethod;
	}(DiffuseBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseDepthMethod;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseCompositeMethod_1 = __webpack_require__(251);
	/**
	 * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.
	 */
	var DiffuseCelMethod = (function (_super) {
	    __extends(DiffuseCelMethod, _super);
	    /**
	     * Creates a new DiffuseCelMethod object.
	     * @param levels The amount of shadow gradations.
	     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
	     */
	    function DiffuseCelMethod(levels, baseMethod) {
	        var _this = this;
	        if (levels === void 0) { levels = 3; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._smoothness = .1;
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._levels = levels;
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        data[index + 1] = 1;
	        data[index + 2] = 0;
	    };
	    Object.defineProperty(DiffuseCelMethod.prototype, "levels", {
	        /**
	         * The amount of shadow gradations.
	         */
	        get: function () {
	            return this._levels;
	        },
	        set: function (value /*uint*/) {
	            this._levels = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCelMethod.prototype, "smoothness", {
	        /**
	         * The smoothness of the edge between 2 shading levels.
	         */
	        get: function () {
	            return this._smoothness;
	        },
	        set: function (value) {
	            this._smoothness = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        data[index] = this._levels;
	        data[index + 3] = this._smoothness;
	    };
	    /**
	     * Snaps the diffuse shading of the wrapped method to one of the levels.
	     * @param vo The MethodVO used to compile the current shader.
	     * @param t The register containing the diffuse strength in the "w" component.
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared register data for this shader.
	     * @return The AGAL fragment code for the method.
	     */
	    DiffuseCelMethod.prototype.clampDiffuse = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "mul " + targetReg + ".w, " + targetReg + ".w, " + this._dataReg + ".x\n" +
	            "frc " + targetReg + ".z, " + targetReg + ".w\n" +
	            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".z\n" +
	            "mov " + targetReg + ".x, " + this._dataReg + ".x\n" +
	            "sub " + targetReg + ".x, " + targetReg + ".x, " + this._dataReg + ".y\n" +
	            "rcp " + targetReg + ".x," + targetReg + ".x\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".y, " + targetReg + ".x\n" +
	            // previous clamped strength
	            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".x\n" +
	            // fract/epsilon (so 0 - epsilon will become 0 - 1)
	            "div " + targetReg + ".z, " + targetReg + ".z, " + this._dataReg + ".w\n" +
	            "sat " + targetReg + ".z, " + targetReg + ".z\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".z\n" +
	            // 1-z
	            "sub " + targetReg + ".z, " + this._dataReg + ".y, " + targetReg + ".z\n" +
	            "mul " + targetReg + ".y, " + targetReg + ".y, " + targetReg + ".z\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n" +
	            "sat " + targetReg + ".w, " + targetReg + ".w\n";
	    };
	    return DiffuseCelMethod;
	}(DiffuseCompositeMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseCelMethod;


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(243);
	var DiffuseBasicMethod_1 = __webpack_require__(244);
	/**
	 * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
	 * calculated diffuse reflection strength.
	 */
	var DiffuseCompositeMethod = (function (_super) {
	    __extends(DiffuseCompositeMethod, _super);
	    /**
	     * Creates a new <code>DiffuseCompositeMethod</code> object.
	     *
	     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
	     * @param baseMethod The base diffuse method on which this method's shading is based.
	     */
	    function DiffuseCompositeMethod(modulateMethod, baseMethod) {
	        var _this = this;
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this.pBaseMethod = baseMethod || new DiffuseBasicMethod_1.default();
	        this.pBaseMethod._iModulateMethod = modulateMethod;
	        this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "baseMethod", {
	        /**
	         * The base diffuse method on which this method's shading is based.
	         */
	        get: function () {
	            return this.pBaseMethod;
	        },
	        set: function (value) {
	            if (this.pBaseMethod == value)
	                return;
	            this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.pBaseMethod = value;
	            this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iInitVO = function (shader, methodVO) {
	        this.pBaseMethod.iInitVO(shader, methodVO);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {
	        this.pBaseMethod.iInitConstants(shader, methodVO);
	    };
	    DiffuseCompositeMethod.prototype.iAddOwner = function (owner) {
	        _super.prototype.iAddOwner.call(this, owner);
	        this.pBaseMethod.iAddOwner(owner);
	    };
	    DiffuseCompositeMethod.prototype.iRemoveOwner = function (owner) {
	        _super.prototype.iRemoveOwner.call(this, owner);
	        this.pBaseMethod.iRemoveOwner(owner);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.dispose = function () {
	        this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	        this.pBaseMethod.dispose();
	    };
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "texture", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.texture;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "color", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.color;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.color = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "multiply", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.multiply;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.multiply = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);
	        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);
	        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this.pBaseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        this.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this.pBaseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iReset = function () {
	        this.pBaseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this.pBaseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return DiffuseCompositeMethod;
	}(DiffuseBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseCompositeMethod;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(244);
	/**
	 * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient
	 * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude
	 * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate
	 * scattered light within the skin attributing to the final colour)
	 */
	var DiffuseGradientMethod = (function (_super) {
	    __extends(DiffuseGradientMethod, _super);
	    /**
	     * Creates a new DiffuseGradientMethod object.
	     * @param gradient A texture that contains the light colour based on the angle. This can be used to change
	     * the light colour due to subsurface scattering when the surface faces away from the light.
	     */
	    function DiffuseGradientMethod(gradient) {
	        _super.call(this);
	        this._gradient = gradient;
	        if (this._gradient)
	            this.iAddTexture(this._gradient);
	    }
	    DiffuseGradientMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        methodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);
	    };
	    Object.defineProperty(DiffuseGradientMethod.prototype, "gradient", {
	        /**
	         * A texture that contains the light colour based on the angle. This can be used to change the light colour
	         * due to subsurface scattering when the surface faces away from the light.
	         */
	        get: function () {
	            return this._gradient;
	        },
	        set: function (value) {
	            if (this._gradient == value)
	                return;
	            if (this._gradient)
	                this.iRemoveTexture(this._gradient);
	            this._gradient = value;
	            if (this._gradient)
	                this.iAddTexture(this._gradient);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	        this._pIsFirstLight = true;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight)
	            t = this._pTotalLightColorReg;
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".w, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "mul " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
	            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
	            "mul " + t + ".xyz, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +
	            //					"mul " + t + ".xyz, " + t + ".xyz, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + t + ".xyz, " + lightColReg + ".xyz\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {
	        var t = regCache.getFreeFragmentVectorTemp();
	        return "mov " + t + ", " + sharedRegisters.shadowTarget + ".wwww\n" +
	            methodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +
	            "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        if (shader.numLights > 0)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    return DiffuseGradientMethod;
	}(DiffuseBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseGradientMethod;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseCompositeMethod_1 = __webpack_require__(251);
	/**
	 * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse
	 * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather
	 * than only the diffuse lighting value.
	 */
	var DiffuseLightMapMethod = (function (_super) {
	    __extends(DiffuseLightMapMethod, _super);
	    /**
	     * Creates a new DiffuseLightMapMethod method.
	     *
	     * @param lightMap The texture containing the light map.
	     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
	     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
	     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
	     */
	    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {
	        if (blendMode === void 0) { blendMode = "multiply"; }
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._useSecondaryUV = useSecondaryUV;
	        this._lightMap = lightMap;
	        this.blendMode = blendMode;
	        if (this._lightMap)
	            this.iAddTexture(this._lightMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which the light map should be applied to the lighting result.
	         *
	         * @see DiffuseLightMapMethod.ADD
	         * @see DiffuseLightMapMethod.MULTIPLY
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)
	                throw new Error("Unknown blendmode!");
	            if (this._blendMode == value)
	                return;
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "lightMap", {
	        /**
	         * The texture containing the light map data.
	         */
	        get: function () {
	            return this._lightMap;
	        },
	        set: function (value) {
	            if (this._lightMap == value)
	                return;
	            if (this._lightMap)
	                this.iRemoveTexture(this._lightMap);
	            this._lightMap = value;
	            if (this._lightMap)
	                this.iAddTexture(this._lightMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicates whether the secondary UV set should be used to map the light map.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
	        switch (this._blendMode) {
	            case DiffuseLightMapMethod.MULTIPLY:
	                code += "mul " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
	                break;
	            case DiffuseLightMapMethod.ADD:
	                code += "add " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
	                break;
	        }
	        code += _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * Indicates the light map should be multiplied with the calculated shading result.
	     * This can be used to add pre-calculated shadows or occlusion.
	     */
	    DiffuseLightMapMethod.MULTIPLY = "multiply";
	    /**
	     * Indicates the light map should be added into the calculated shading result.
	     * This can be used to add pre-calculated lighting or global illumination.
	     */
	    DiffuseLightMapMethod.ADD = "add";
	    return DiffuseLightMapMethod;
	}(DiffuseCompositeMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseLightMapMethod;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(244);
	/**
	 * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be "wrapped around" the normally dark area, to some extent.
	 * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.
	 */
	var DiffuseWrapMethod = (function (_super) {
	    __extends(DiffuseWrapMethod, _super);
	    /**
	     * Creates a new DiffuseWrapMethod object.
	     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap
	     */
	    function DiffuseWrapMethod(wrapFactor) {
	        if (wrapFactor === void 0) { wrapFactor = .5; }
	        _super.call(this);
	        this.wrapFactor = wrapFactor;
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._wrapDataRegister = null;
	    };
	    Object.defineProperty(DiffuseWrapMethod.prototype, "wrapFactor", {
	        /**
	         * A factor to indicate the amount by which the light is allowed to wrap.
	         */
	        get: function () {
	            return this._wrapFactor;
	        },
	        set: function (value) {
	            this._wrapFactor = value;
	            this._wrapFactor = 1 / (value + 1);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	        this._pIsFirstLight = true;
	        this._wrapDataRegister = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".x, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "add " + t + ".y, " + t + ".x, " + this._wrapDataRegister + ".x\n" +
	            "mul " + t + ".y, " + t + ".y, " + this._wrapDataRegister + ".y\n" +
	            "sat " + t + ".w, " + t + ".y\n" +
	            "mul " + t + ".xz, " + t + ".w, " + lightDirReg + ".wz\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);
	        code += "mul " + t + ", " + t + ".x, " + lightColReg + "\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._wrapFactor;
	        data[index + 1] = 1 / (this._wrapFactor + 1);
	    };
	    return DiffuseWrapMethod;
	}(DiffuseBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DiffuseWrapMethod;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used
	 * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water
	 * etc).
	 */
	var EffectAlphaMaskMethod = (function (_super) {
	    __extends(EffectAlphaMaskMethod, _super);
	    /**
	     * Creates a new EffectAlphaMaskMethod object.
	     *
	     * @param texture The texture to use as the alpha mask.
	     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.
	     */
	    function EffectAlphaMaskMethod(texture, useSecondaryUV) {
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        _super.call(this);
	        this._texture = texture;
	        this._useSecondaryUV = useSecondaryUV;
	        if (this._texture)
	            this.iAddTexture(this._texture);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.textureGL = shader.getAbstraction(this._texture);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(EffectAlphaMaskMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for
	         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the
	         * transparency over a tiled water surface.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectAlphaMaskMethod.prototype, "texture", {
	        /**
	         * The texture to use as the alpha mask.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +
	            "mul " + targetReg + ", " + targetReg + ", " + temp + ".x\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectAlphaMaskMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    return EffectAlphaMaskMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectAlphaMaskMethod;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var ShadingMethodBase_1 = __webpack_require__(242);
	/**
	 * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
	 * and are in essence post-process effects on the materials.
	 */
	var EffectMethodBase = (function (_super) {
	    __extends(EffectMethodBase, _super);
	    function EffectMethodBase() {
	        _super.call(this);
	    }
	    Object.defineProperty(EffectMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return EffectMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register that will be containing the method's output.
	     * @private
	     */
	    EffectMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        throw new AbstractMethodError_1.default();
	    };
	    EffectMethodBase.assetType = "[asset EffectMethod]";
	    return EffectMethodBase;
	}(ShadingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectMethodBase;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.
	 */
	var EffectColorMatrixMethod = (function (_super) {
	    __extends(EffectColorMatrixMethod, _super);
	    /**
	     * Creates a new EffectColorTransformMethod.
	     *
	     * @param matrix An array of 20 items for 4 x 5 color transform.
	     */
	    function EffectColorMatrixMethod(matrix) {
	        _super.call(this);
	        if (matrix.length != 20)
	            throw new Error("Matrix length must be 20!");
	        this._matrix = matrix;
	    }
	    Object.defineProperty(EffectColorMatrixMethod.prototype, "colorMatrix", {
	        /**
	         * The 4 x 5 matrix to transform the color of the material.
	         */
	        get: function () {
	            return this._matrix;
	        },
	        set: function (value) {
	            this._matrix = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectColorMatrixMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var colorMultReg = registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        var colorOffsetReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code += "m44 " + temp + ", " + targetReg + ", " + colorMultReg + "\n" +
	            "add " + targetReg + ", " + temp + ", " + colorOffsetReg + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectColorMatrixMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var matrix = this._matrix;
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        // r
	        data[index] = matrix[0];
	        data[index + 1] = matrix[1];
	        data[index + 2] = matrix[2];
	        data[index + 3] = matrix[3];
	        // g
	        data[index + 4] = matrix[5];
	        data[index + 5] = matrix[6];
	        data[index + 6] = matrix[7];
	        data[index + 7] = matrix[8];
	        // b
	        data[index + 8] = matrix[10];
	        data[index + 9] = matrix[11];
	        data[index + 10] = matrix[12];
	        data[index + 11] = matrix[13];
	        // a
	        data[index + 12] = matrix[15];
	        data[index + 13] = matrix[16];
	        data[index + 14] = matrix[17];
	        data[index + 15] = matrix[18];
	        // rgba offset
	        data[index + 16] = matrix[4];
	        data[index + 17] = matrix[9];
	        data[index + 18] = matrix[14];
	        data[index + 19] = matrix[19];
	    };
	    return EffectColorMatrixMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectColorMatrixMethod;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a
	 * ColorTransform object.
	 */
	var EffectColorTransformMethod = (function (_super) {
	    __extends(EffectColorTransformMethod, _super);
	    /**
	     * Creates a new EffectColorTransformMethod.
	     */
	    function EffectColorTransformMethod() {
	        _super.call(this);
	    }
	    Object.defineProperty(EffectColorTransformMethod.prototype, "colorTransform", {
	        /**
	         * The ColorTransform object to transform the colour of the material with.
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (value) {
	            this._colorTransform = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var colorMultReg = registerCache.getFreeFragmentConstant();
	        var colorOffsReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;
	        //TODO: AGAL <> GLSL
	        code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectColorTransformMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var inv = 1 / 0xff;
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._colorTransform.redMultiplier;
	        data[index + 1] = this._colorTransform.greenMultiplier;
	        data[index + 2] = this._colorTransform.blueMultiplier;
	        data[index + 3] = this._colorTransform.alphaMultiplier;
	        data[index + 4] = this._colorTransform.redOffset * inv;
	        data[index + 5] = this._colorTransform.greenOffset * inv;
	        data[index + 6] = this._colorTransform.blueOffset * inv;
	        data[index + 7] = this._colorTransform.alphaOffset * inv;
	    };
	    return EffectColorTransformMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectColorTransformMethod;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.
	 */
	var EffectEnvMapMethod = (function (_super) {
	    __extends(EffectEnvMapMethod, _super);
	    /**
	     * Creates an EffectEnvMapMethod object.
	     * @param envMap The environment map containing the reflected scene.
	     * @param alpha The reflectivity of the surface.
	     */
	    function EffectEnvMapMethod(envMap, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._envMap = envMap;
	        this._alpha = alpha;
	        if (this._envMap)
	            this.iAddTexture(this._envMap);
	    }
	    Object.defineProperty(EffectEnvMapMethod.prototype, "mask", {
	        /**
	         * An optional texture to modulate the reflectivity of the surface.
	         */
	        get: function () {
	            return this._mask;
	        },
	        set: function (value) {
	            if (value == this._mask)
	                return;
	            if (this._mask)
	                this.iRemoveTexture(this._mask);
	            this._mask = value;
	            if (this._mask)
	                this.iAddTexture(this._mask);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	        if (this._envMap)
	            methodVO.textureGL = shader.getAbstraction(this._envMap);
	        if (this._mask) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);
	            shader.uvDependencies++;
	        }
	    };
	    Object.defineProperty(EffectEnvMapMethod.prototype, "envMap", {
	        /**
	         * The cubic environment map containing the reflected scene.
	         */
	        get: function () {
	            return this._envMap;
	        },
	        set: function (value) {
	            if (this._envMap == value)
	                return;
	            if (this._envMap)
	                this.iRemoveTexture(this._envMap);
	            this._envMap = value;
	            if (this._envMap)
	                this.iAddTexture(this._envMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.dispose = function () {
	    };
	    Object.defineProperty(EffectEnvMapMethod.prototype, "alpha", {
	        /**
	         * The reflectivity of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;
	        methodVO.textureGL.activate(methodVO.pass._render);
	        if (this._mask)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    EffectEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	        if (this._mask)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var code = "";
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // r = I - 2(I.N)*N
	        code += "dp3 " + temp + ".w, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
	            "mul " + temp + ".xyz, " + sharedRegisters.normalFragment + ".xyz, " + temp + ".w\n" +
	            "sub " + temp + ".xyz, " + temp + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
	            "kil " + temp2 + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
	        if (this._mask) {
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	                "mul " + temp + ", " + temp2 + ", " + temp + "\n";
	        }
	        code += "mul " + temp + ", " + temp + ", " + dataRegister + ".x\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    return EffectEnvMapMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectEnvMapMethod;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectFogMethod provides a method to add distance-based fog to a material.
	 */
	var EffectFogMethod = (function (_super) {
	    __extends(EffectFogMethod, _super);
	    /**
	     * Creates a new EffectFogMethod object.
	     * @param minDistance The distance from which the fog starts appearing.
	     * @param maxDistance The distance at which the fog is densest.
	     * @param fogColor The colour of the fog.
	     */
	    function EffectFogMethod(minDistance, maxDistance, fogColor) {
	        if (fogColor === void 0) { fogColor = 0x808080; }
	        _super.call(this);
	        this._minDistance = 0;
	        this._maxDistance = 1000;
	        this.minDistance = minDistance;
	        this.maxDistance = maxDistance;
	        this.fogColor = fogColor;
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsProjection = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 3] = 1;
	        data[index + 6] = 0;
	        data[index + 7] = 0;
	    };
	    Object.defineProperty(EffectFogMethod.prototype, "minDistance", {
	        /**
	         * The distance from which the fog starts appearing.
	         */
	        get: function () {
	            return this._minDistance;
	        },
	        set: function (value) {
	            this._minDistance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFogMethod.prototype, "maxDistance", {
	        /**
	         * The distance at which the fog is densest.
	         */
	        get: function () {
	            return this._maxDistance;
	        },
	        set: function (value) {
	            this._maxDistance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFogMethod.prototype, "fogColor", {
	        /**
	         * The colour of the fog.
	         */
	        get: function () {
	            return this._fogColor;
	        },
	        set: function (value /*uint*/) {
	            this._fogColor = value;
	            this._fogR = ((value >> 16) & 0xff) / 0xff;
	            this._fogG = ((value >> 8) & 0xff) / 0xff;
	            this._fogB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = this._fogR;
	        data[index + 1] = this._fogG;
	        data[index + 2] = this._fogB;
	        data[index + 4] = this._minDistance;
	        data[index + 5] = 1 / (this._maxDistance - this._minDistance);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var fogColor = registerCache.getFreeFragmentConstant();
	        var fogData = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        var code = "";
	        methodVO.fragmentConstantsIndex = fogColor.index * 4;
	        code += "sub " + temp2 + ".w, " + sharedRegisters.projectionFragment + ".z, " + fogData + ".x\n" +
	            "mul " + temp2 + ".w, " + temp2 + ".w, " + fogData + ".y\n" +
	            "sat " + temp2 + ".w, " + temp2 + ".w\n" +
	            "sub " + temp + ", " + fogColor + ", " + targetReg + "\n" +
	            "mul " + temp + ", " + temp + ", " + temp2 + ".w\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n"; // fogRatio*(fogColor- col) + col
	        registerCache.removeFragmentTempUsage(temp);
	        return code;
	    };
	    return EffectFogMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectFogMethod;


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets
	 * stronger as the viewing angle becomes more grazing.
	 */
	var EffectFresnelEnvMapMethod = (function (_super) {
	    __extends(EffectFresnelEnvMapMethod, _super);
	    /**
	     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.
	     *
	     * @param envMap The environment map containing the reflected scene.
	     * @param alpha The reflectivity of the material.
	     */
	    function EffectFresnelEnvMapMethod(envMap, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._fresnelPower = 5;
	        this._normalReflectance = 0;
	        this._envMap = envMap;
	        this._alpha = alpha;
	        if (this._envMap)
	            this.iAddTexture(this._envMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	        methodVO.textureGL = shader.getAbstraction(this._envMap);
	        if (this._mask != null) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);
	            shader.uvDependencies++;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;
	    };
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "mask", {
	        /**
	         * An optional texture to modulate the reflectivity of the surface.
	         */
	        get: function () {
	            return this._mask;
	        },
	        set: function (value) {
	            if (this._mask == value)
	                return;
	            if (this._mask)
	                this.iRemoveTexture(this._mask);
	            this._mask = value;
	            if (this._mask)
	                this.iAddTexture(this._mask);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "fresnelPower", {
	        /**
	         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
	         */
	        get: function () {
	            return this._fresnelPower;
	        },
	        set: function (value) {
	            this._fresnelPower = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "envMap", {
	        /**
	         * The cubic environment map containing the reflected scene.
	         */
	        get: function () {
	            return this._envMap;
	        },
	        set: function (value) {
	            if (this._envMap == value)
	                return;
	            if (this._envMap)
	                this.iRemoveTexture(this._envMap);
	            this._envMap = value;
	            if (this._envMap)
	                this.iAddTexture(this._envMap);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "alpha", {
	        /**
	         * The reflectivity of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "normalReflectance", {
	        /**
	         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
	         */
	        get: function () {
	            return this._normalReflectance;
	        },
	        set: function (value) {
	            this._normalReflectance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = this._alpha;
	        data[index + 1] = this._normalReflectance;
	        data[index + 2] = this._fresnelPower;
	        methodVO.textureGL.activate(methodVO.pass._render);
	        if (this._mask)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    EffectFresnelEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	        if (this._mask)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var code = "";
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // r = V - 2(V.N)*N
	        code += "dp3 " + temp + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
	            "mul " + temp + ".xyz, " + normalReg + ".xyz, " + temp + ".w\n" +
	            "sub " + temp + ".xyz, " + temp + ".xyz, " + viewDirReg + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
	            "kil " + temp2 + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
	        // calculate fresnel term
	        code += "dp3 " + viewDirReg + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	            "sub " + viewDirReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
	            "pow " + viewDirReg + ".w, " + viewDirReg + ".w, " + dataRegister + ".z\n" +
	            "sub " + normalReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
	            "mul " + normalReg + ".w, " + dataRegister + ".y, " + normalReg + ".w\n" +
	            "add " + viewDirReg + ".w, " + viewDirReg + ".w, " + normalReg + ".w\n" +
	            // total alpha
	            "mul " + viewDirReg + ".w, " + dataRegister + ".x, " + viewDirReg + ".w\n";
	        if (this._mask) {
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	                "mul " + viewDirReg + ".w, " + temp2 + ".x, " + viewDirReg + ".w\n";
	        }
	        // blend
	        code += "mul " + temp + ", " + temp + ", " + viewDirReg + ".w\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    return EffectFresnelEnvMapMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectFresnelEnvMapMethod;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.
	 * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather
	 * than the whole pixel colour.
	 */
	var EffectLightMapMethod = (function (_super) {
	    __extends(EffectLightMapMethod, _super);
	    /**
	     * Creates a new EffectLightMapMethod object.
	     *
	     * @param lightMap The texture containing the light map.
	     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
	     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
	     */
	    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {
	        if (blendMode === void 0) { blendMode = "multiply"; }
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        _super.call(this);
	        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)
	            throw new Error("Unknown blendmode!");
	        this._lightMap = lightMap;
	        this._blendMode = blendMode;
	        this._useSecondaryUV = useSecondaryUV;
	        if (this._lightMap)
	            this.iAddTexture(this._lightMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.textureGL = shader.getAbstraction(this._lightMap);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(EffectLightMapMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which the light map should be applied to the lighting result.
	         *
	         * @see EffectLightMapMethod.ADD
	         * @see EffectLightMapMethod.MULTIPLY
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (this._blendMode == value)
	                return;
	            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)
	                throw new Error("Unknown blendmode!");
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectLightMapMethod.prototype, "lightMap", {
	        /**
	         * The lightMap containing the light map.
	         */
	        get: function () {
	            return this._lightMap;
	        },
	        set: function (value) {
	            if (this._lightMap == value)
	                return;
	            if (this._lightMap)
	                this.iRemoveTexture(this._lightMap);
	            this._lightMap = value;
	            if (this._lightMap)
	                this.iAddTexture(this._lightMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectLightMapMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicates whether the secondary UV set should be used to map the light map.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
	        switch (this._blendMode) {
	            case EffectLightMapMethod.MULTIPLY:
	                code += "mul " + targetReg + ", " + targetReg + ", " + temp + "\n";
	                break;
	            case EffectLightMapMethod.ADD:
	                code += "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	                break;
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Indicates the light map should be multiplied with the calculated shading result.
	     */
	    EffectLightMapMethod.MULTIPLY = "multiply";
	    /**
	     * Indicates the light map should be added into the calculated shading result.
	     */
	    EffectLightMapMethod.ADD = "add";
	    return EffectLightMapMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectLightMapMethod;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(256);
	/**
	 * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.
	 */
	var EffectRimLightMethod = (function (_super) {
	    __extends(EffectRimLightMethod, _super);
	    /**
	     * Creates a new <code>EffectRimLightMethod</code> object.
	     *
	     * @param color The colour of the rim light.
	     * @param strength The strength of the rim light.
	     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.
	     * @param blend The blend mode with which to add the light to the object.
	     */
	    function EffectRimLightMethod(color, strength, power, blend) {
	        if (color === void 0) { color = 0xffffff; }
	        if (strength === void 0) { strength = .4; }
	        if (power === void 0) { power = 2; }
	        if (blend === void 0) { blend = "mix"; }
	        _super.call(this);
	        this._blendMode = blend;
	        this._strength = strength;
	        this._power = power;
	        this.color = color;
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iInitConstants = function (shader, methodVO) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	    };
	    Object.defineProperty(EffectRimLightMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which to add the light to the object.
	         *
	         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.
	         * EffectRimLightMethod.ADD adds the rim light with the material's colour.
	         * EffectRimLightMethod.MIX provides normal alpha blending.
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (this._blendMode == value)
	                return;
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "color", {
	        /**
	         * The color of the rim light.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value /*uint*/) {
	            this._color = value;
	            this._colorR = ((value >> 16) & 0xff) / 0xff;
	            this._colorG = ((value >> 8) & 0xff) / 0xff;
	            this._colorB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "strength", {
	        /**
	         * The strength of the rim light.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            this._strength = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "power", {
	        /**
	         * The power of the rim light. Higher values will result in a higher edge fall-off.
	         */
	        get: function () {
	            return this._power;
	        },
	        set: function (value) {
	            this._power = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._colorR;
	        data[index + 1] = this._colorG;
	        data[index + 2] = this._colorB;
	        data[index + 4] = this._strength;
	        data[index + 5] = this._power;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var dataRegister2 = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        var code = "";
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        code += "dp3 " + temp + ".x, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "sat " + temp + ".x, " + temp + ".x\n" +
	            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
	            "pow " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".y\n" +
	            "mul " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".x\n" +
	            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
	            "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".x\n" +
	            "sub " + temp + ".w, " + dataRegister + ".w, " + temp + ".x\n";
	        if (this._blendMode == EffectRimLightMethod.ADD) {
	            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {
	            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        else {
	            code += "sub " + temp + ".xyz, " + dataRegister + ".xyz, " + targetReg + ".xyz\n" +
	                "mul " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        return code;
	    };
	    EffectRimLightMethod.ADD = "add";
	    EffectRimLightMethod.MULTIPLY = "multiply";
	    EffectRimLightMethod.MIX = "mix";
	    return EffectRimLightMethod;
	}(EffectMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EffectRimLightMethod;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NormalBasicMethod_1 = __webpack_require__(246);
	/**
	 * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
	 */
	var NormalSimpleWaterMethod = (function (_super) {
	    __extends(NormalSimpleWaterMethod, _super);
	    /**
	     * Creates a new NormalSimpleWaterMethod object.
	     * @param waveMap1 A normal map containing one layer of a wave structure.
	     * @param waveMap2 A normal map containing a second layer of a wave structure.
	     */
	    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {
	        if (normalMap === void 0) { normalMap = null; }
	        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }
	        _super.call(this, normalMap);
	        this._water1OffsetX = 0;
	        this._water1OffsetY = 0;
	        this._water2OffsetX = 0;
	        this._water2OffsetY = 0;
	        this._secondaryNormalMap = secondaryNormalMap;
	        if (this._secondaryNormalMap)
	            this.iAddTexture(this._secondaryNormalMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = .5;
	        data[index + 1] = 0;
	        data[index + 2] = 0;
	        data[index + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        if (this._secondaryNormalMap) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);
	            shader.uvDependencies++;
	        }
	    };
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetX", {
	        /**
	         * The translation of the first wave layer along the X-axis.
	         */
	        get: function () {
	            return this._water1OffsetX;
	        },
	        set: function (value) {
	            this._water1OffsetX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetY", {
	        /**
	         * The translation of the first wave layer along the Y-axis.
	         */
	        get: function () {
	            return this._water1OffsetY;
	        },
	        set: function (value) {
	            this._water1OffsetY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetX", {
	        /**
	         * The translation of the second wave layer along the X-axis.
	         */
	        get: function () {
	            return this._water2OffsetX;
	        },
	        set: function (value) {
	            this._water2OffsetX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetY", {
	        /**
	         * The translation of the second wave layer along the Y-axis.
	         */
	        get: function () {
	            return this._water2OffsetY;
	        },
	        set: function (value) {
	            this._water2OffsetY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "secondaryNormalMap", {
	        /**
	         * A second normal map that will be combined with the first to create a wave-like animation pattern.
	         */
	        get: function () {
	            return this._secondaryNormalMap;
	        },
	        set: function (value) {
	            if (this._secondaryNormalMap == value)
	                return;
	            if (this._secondaryNormalMap)
	                this.iRemoveTexture(this._secondaryNormalMap);
	            this._secondaryNormalMap = value;
	            if (this._secondaryNormalMap)
	                this.iAddTexture(this._secondaryNormalMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._secondaryNormalMap = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 4] = this._water1OffsetX;
	        data[index + 5] = this._water1OffsetY;
	        data[index + 6] = this._water2OffsetX;
	        data[index + 7] = this._water2OffsetY;
	        if (this._secondaryNormalMap)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        if (this._secondaryNormalMap)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = dataReg.index * 4;
	        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n";
	        if (this.texture)
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);
	        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n";
	        if (this._secondaryNormalMap)
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);
	        code += "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" +
	            "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" +
	            "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx	\n" +
	            "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
	        return code;
	    };
	    return NormalSimpleWaterMethod;
	}(NormalBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = NormalSimpleWaterMethod;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(89);
	var Single2DTexture_1 = __webpack_require__(169);
	var ShadowMethodBase_1 = __webpack_require__(266);
	/**
	 * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
	 */
	var ShadowDitheredMethod = (function (_super) {
	    __extends(ShadowDitheredMethod, _super);
	    /**
	     * Creates a new ShadowDitheredMethod object.
	     * @param castingLight The light casting the shadows
	     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
	     */
	    function ShadowDitheredMethod(castingLight, numSamples, range) {
	        if (numSamples === void 0) { numSamples = 4; }
	        if (range === void 0) { range = 1; }
	        _super.call(this, castingLight);
	        this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;
	        this.numSamples = numSamples;
	        this.range = range;
	        ++ShadowDitheredMethod._grainUsages;
	        if (!ShadowDitheredMethod._grainTexture)
	            this.initGrainTexture();
	    }
	    Object.defineProperty(ShadowDitheredMethod.prototype, "numSamples", {
	        /**
	         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
	         * complexity of the shader.
	         */
	        get: function () {
	            return this._numSamples;
	        },
	        set: function (value /*int*/) {
	            if (value < 1)
	                value = 1;
	            else if (value > 24)
	                value = 24;
	            if (this._numSamples == value)
	                return;
	            this._numSamples = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        methodVO.needsProjection = true;
	        methodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index + 8] = 1 / this._numSamples;
	    };
	    Object.defineProperty(ShadowDitheredMethod.prototype, "range", {
	        /**
	         * The range in the shadow map in which to distribute the samples.
	         */
	        get: function () {
	            return this._range * 2;
	        },
	        set: function (value) {
	            this._range = value / 2;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a texture containing the dithering noise texture.
	     */
	    ShadowDitheredMethod.prototype.initGrainTexture = function () {
	        ShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D_1.default(64, 64, false);
	        var vec = new Array();
	        var len = 4096;
	        var step = 1 / (this._depthMapSize * this._range);
	        var r, g;
	        for (var i = 0; i < len; ++i) {
	            r = 2 * (Math.random() - .5);
	            g = 2 * (Math.random() - .5);
	            if (r < 0)
	                r -= step;
	            else
	                r += step;
	            if (g < 0)
	                g -= step;
	            else
	                g += step;
	            if (r > 1)
	                r = 1;
	            else if (r < -1)
	                r = -1;
	            if (g > 1)
	                g = 1;
	            else if (g < -1)
	                g = -1;
	            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
	        }
	        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);
	        ShadowDitheredMethod._grainTexture = new Single2DTexture_1.default(ShadowDitheredMethod._grainBitmapImage2D);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.dispose = function () {
	        if (--ShadowDitheredMethod._grainUsages == 0) {
	            ShadowDitheredMethod._grainTexture.dispose();
	            ShadowDitheredMethod._grainBitmapImage2D.dispose();
	            ShadowDitheredMethod._grainTexture = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 9] = (stage.width - 1) / 63;
	        data[index + 10] = (stage.height - 1) / 63;
	        data[index + 11] = 2 * this._range / this._depthMapSize;
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var decReg = regCache.getFreeFragmentConstant();
	        var dataReg = regCache.getFreeFragmentConstant();
	        var customDataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        return this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);
	    };
	    /**
	     * Get the actual shader code for shadow mapping
	     * @param regCache The register cache managing the registers.
	     * @param depthMapRegister The texture register containing the depth map.
	     * @param decReg The register containing the depth map decoding data.
	     * @param targetReg The target register to add the shadow coverage.
	     */
	    ShadowDitheredMethod.prototype.getSampleCode = function (shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var numSamples = this._numSamples;
	        var uvReg = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(uvReg, 1);
	        var temp = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(temp, 1);
	        var projectionReg = sharedRegisters.projectionFragment;
	        code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" +
	            "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";
	        while (numSamples > 0) {
	            if (numSamples == this._numSamples) {
	                code += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);
	            }
	            else {
	                code += "mov " + temp + ", " + uvReg + ".zwxy \n" +
	                    methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);
	            }
	            // keep grain in uvReg.zw
	            code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" +
	                "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n"; // (tex unpack scale and tex scale in one)
	            if (numSamples == this._numSamples) {
	                // first sample
	                code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._pDepthMapCoordReg + ".xy\n" +
	                    methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +
	                    "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
	                    "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow
	            }
	            else {
	                code += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            }
	            if (numSamples > 4)
	                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 1)
	                code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 5)
	                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 2) {
	                code += "neg " + uvReg + ".w, " + uvReg + ".w\n"; // will be rotated 90 degrees when being accessed as wz
	                code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._pDepthMapCoordReg + ".xy\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            }
	            if (numSamples > 6)
	                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 3)
	                code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 7)
	                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            numSamples -= 8;
	        }
	        regCache.removeFragmentTempUsage(temp);
	        regCache.removeFragmentTempUsage(uvReg);
	        code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n"; // average
	        return code;
	    };
	    /**
	     * Adds the code for another tap to the shader code.
	     * @param uvReg The uv register for the tap.
	     * @param depthMapRegister The texture register containing the depth map.
	     * @param decReg The register containing the depth map decoding data.
	     * @param targetReg The target register to add the tap comparison result.
	     * @param regCache The register cache managing the registers.
	     * @return
	     */
	    ShadowDitheredMethod.prototype.addSample = function (shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters) {
	        var temp = regCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +
	            "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
	            "slt " + temp + ".z, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        data[index] = 1 / this._numSamples;
	        data[index + 1] = (stage.width - 1) / 63;
	        data[index + 2] = (stage.height - 1) / 63;
	        data[index + 3] = 2 * this._range / this._depthMapSize;
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        this._pDepthMapCoordReg = depthProjection;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        return this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);
	    };
	    return ShadowDitheredMethod;
	}(ShadowMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowDitheredMethod;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(20);
	var PointLight_1 = __webpack_require__(199);
	var ShadowMapMethodBase_1 = __webpack_require__(267);
	/**
	 * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
	 */
	var ShadowMethodBase = (function (_super) {
	    __extends(ShadowMethodBase, _super);
	    /**
	     * Creates a new ShadowMethodBase object.
	     * @param castingLight The light used to cast shadows.
	     */
	    function ShadowMethodBase(castingLight) {
	        _super.call(this, castingLight);
	        this._pUsePoint = (castingLight instanceof PointLight_1.default);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsView = true;
	        methodVO.needsGlobalVertexPos = true;
	        methodVO.needsGlobalFragmentPos = this._pUsePoint;
	        methodVO.needsNormals = shader.numLights > 0;
	        //methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iInitConstants = function (shader, methodVO) {
	        var fragmentData = shader.fragmentConstantData;
	        var vertexData = shader.vertexConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index] = 1.0;
	        fragmentData[index + 1] = 1 / 255.0;
	        fragmentData[index + 2] = 1 / 65025.0;
	        fragmentData[index + 3] = 1 / 16581375.0;
	        fragmentData[index + 6] = 0;
	        fragmentData[index + 7] = 1;
	        if (this._pUsePoint) {
	            fragmentData[index + 8] = 0;
	            fragmentData[index + 9] = 0;
	            fragmentData[index + 10] = 0;
	            fragmentData[index + 11] = 1;
	        }
	        index = methodVO.vertexConstantsIndex;
	        if (index != -1) {
	            vertexData[index] = .5;
	            vertexData[index + 1] = .5;
	            vertexData[index + 2] = 0.0;
	            vertexData[index + 3] = 1.0;
	        }
	    };
	    Object.defineProperty(ShadowMethodBase.prototype, "_iDepthMapCoordReg", {
	        /**
	         * Wrappers that override the vertex shader need to set this explicitly
	         */
	        get: function () {
	            return this._pDepthMapCoordReg;
	        },
	        set: function (value) {
	            this._pDepthMapCoordReg = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pDepthMapCoordReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iGetVertexCode = function (shader, methodVO, regCache, sharedRegisters) {
	        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);
	    };
	    /**
	     * Gets the vertex code for shadow mapping with a point light.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     */
	    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {
	        methodVO.vertexConstantsIndex = -1;
	        return "";
	    };
	    /**
	     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     */
	    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {
	        var code = "";
	        var temp = regCache.getFreeVertexVectorTemp();
	        var dataReg = regCache.getFreeVertexConstant();
	        var depthMapProj = regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        this._pDepthMapCoordReg = regCache.getFreeVarying();
	        methodVO.vertexConstantsIndex = dataReg.index * 4;
	        // todo: can epsilon be applied here instead of fragment shader?
	        code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" +
	            "div " + temp + ", " + temp + ", " + temp + ".w\n" +
	            "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" +
	            "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";
	        //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = this._pUsePoint ? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	        code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (methodVO.fragmentConstantsIndex / 4 + 1) + ".y\n" +
	            "sat " + targetReg + ".w, " + targetReg + ".w\n";
	        return code;
	    };
	    /**
	     * Gets the fragment code for shadow mapping with a planar shadow map.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * Gets the fragment code for shadow mapping with a point light.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        throw new AbstractMethodError_1.default();
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (!this._pUsePoint)
	            this._pShadowMapper.iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Gets the fragment code for combining this method with a cascaded shadow map method.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param decodeRegister The register containing the data to decode the shadow map depth value.
	     * @param depthTexture The texture containing the shadow map.
	     * @param depthProjection The projection of the fragment relative to the light.
	     * @param targetRegister The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        throw new Error("This shadow method is incompatible with cascade shadows");
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iActivate = function (shader, methodVO, stage) {
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        if (this._pUsePoint)
	            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);
	        else
	            shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);
	        fragmentData[index + 5] = 1 - this._pAlpha;
	        if (this._pUsePoint) {
	            var pos = this._pCastingLight.scenePosition;
	            fragmentData[index + 8] = pos.x;
	            fragmentData[index + 9] = pos.y;
	            fragmentData[index + 10] = pos.z;
	            // used to decompress distance
	            var f = this._pCastingLight.fallOff;
	            fragmentData[index + 11] = 1 / (2 * f * f);
	        }
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * Sets the method state for cascade shadow mapping.
	     */
	    ShadowMethodBase.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        throw new Error("This shadow method is incompatible with cascade shadows");
	    };
	    return ShadowMethodBase;
	}(ShadowMapMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowMethodBase;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(242);
	/**
	 * ShadowMapMethodBase provides an abstract base method for shadow map methods.
	 */
	var ShadowMapMethodBase = (function (_super) {
	    __extends(ShadowMapMethodBase, _super);
	    /**
	     * Creates a new ShadowMapMethodBase object.
	     * @param castingLight The light used to cast shadows.
	     */
	    function ShadowMapMethodBase(castingLight) {
	        _super.call(this);
	        this._pEpsilon = .02;
	        this._pAlpha = 1;
	        this._pCastingLight = castingLight;
	        castingLight.shadowsEnabled = true;
	        this._pShadowMapper = castingLight.shadowMapper;
	        this.iAddTexture(castingLight.shadowMapper.depthMap);
	    }
	    Object.defineProperty(ShadowMapMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return ShadowMapMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
	        /**
	         * The "transparency" of the shadows. This allows making shadows less strong.
	         */
	        get: function () {
	            return this._pAlpha;
	        },
	        set: function (value) {
	            this._pAlpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
	        /**
	         * The light casting the shadows.
	         */
	        get: function () {
	            return this._pCastingLight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
	        /**
	         * A small value to counter floating point precision errors when comparing values in the shadow map with the
	         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
	         */
	        get: function () {
	            return this._pEpsilon;
	        },
	        set: function (value) {
	            this._pEpsilon = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapMethodBase.assetType = "[asset ShadowMapMethod]";
	    return ShadowMapMethodBase;
	}(ShadingMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowMapMethodBase;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadowMethodBase_1 = __webpack_require__(266);
	/**
	 * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
	 * results of neighbouring pixels.
	 */
	var ShadowFilteredMethod = (function (_super) {
	    __extends(ShadowFilteredMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     *
	     * @param castingLight The light casting the shadow
	     */
	    function ShadowFilteredMethod(castingLight) {
	        _super.call(this, castingLight);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index + 8] = .5;
	        var size = this.castingLight.shadowMapper.depthMapSize;
	        fragmentData[index + 9] = size;
	        fragmentData[index + 10] = 1 / size;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var customDataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        var depthCol = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(depthCol, 1);
	        var uvReg = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(uvReg, 1);
	        code += "mov " + uvReg + ", " + this._pDepthMapCoordReg + "\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
	            "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
	            "mov " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x\n" +
	            "add " + uvReg + ".y, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            // recalculate fraction, since we ran out of registers :(
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
	            "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";
	        regCache.removeFragmentTempUsage(depthCol);
	        regCache.removeFragmentTempUsage(uvReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        var size = this.castingLight.shadowMapper.depthMapSize;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = size;
	        data[index + 1] = 1 / size;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        var code;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var predicate = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(predicate, 1);
	        code = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" +
	            "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" +
	            "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" +
	            "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" +
	            "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" +
	            "frc " + temp + ".xy, " + temp + ".xy\n" +
	            // some strange register juggling to prevent agal bugging out
	            "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" +
	            "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" +
	            "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" +
	            "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" +
	            "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" +
	            "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(predicate);
	        return code;
	    };
	    return ShadowFilteredMethod;
	}(ShadowMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowFilteredMethod;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularCompositeMethod_1 = __webpack_require__(270);
	/**
	 * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.
	 */
	var SpecularFresnelMethod = (function (_super) {
	    __extends(SpecularFresnelMethod, _super);
	    /**
	     * Creates a new SpecularFresnelMethod object.
	     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
	     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.
	     */
	    function SpecularFresnelMethod(basedOnSurface, baseMethod) {
	        var _this = this;
	        if (basedOnSurface === void 0) { basedOnSurface = true; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        // may want to offer diff speculars
	        _super.call(this, null, baseMethod);
	        this._fresnelPower = 5;
	        this._normalReflectance = .028; // default value for skin
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._incidentLight = !basedOnSurface;
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        shader.fragmentConstantData[index + 2] = 1;
	        shader.fragmentConstantData[index + 3] = 0;
	    };
	    Object.defineProperty(SpecularFresnelMethod.prototype, "basedOnSurface", {
	        /**
	         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
	         */
	        get: function () {
	            return !this._incidentLight;
	        },
	        set: function (value) {
	            if (this._incidentLight != value)
	                return;
	            this._incidentLight = !value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularFresnelMethod.prototype, "fresnelPower", {
	        /**
	         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
	         */
	        get: function () {
	            return this._fresnelPower;
	        },
	        set: function (value) {
	            this._fresnelPower = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    Object.defineProperty(SpecularFresnelMethod.prototype, "normalReflectance", {
	        /**
	         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
	         */
	        get: function () {
	            return this._normalReflectance;
	        },
	        set: function (value) {
	            this._normalReflectance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index] = this._normalReflectance;
	        fragmentData[index + 1] = this._fresnelPower;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * Applies the fresnel effect to the specular strength.
	     *
	     * @param vo The MethodVO object containing the method data for the currently compiled material pass.
	     * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared registers created by the compiler.
	     * @return The AGAL fragment code for the method.
	     */
	    SpecularFresnelMethod.prototype.modulateSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        code = "dp3 " + targetReg + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._incidentLight ? targetReg : sharedRegisters.normalFragment) + ".xyz\n" +
	            "sub " + targetReg + ".y, " + this._dataReg + ".z, " + targetReg + ".y\n" +
	            "pow " + targetReg + ".x, " + targetReg + ".y, " + this._dataReg + ".y\n" +
	            "sub " + targetReg + ".y, " + this._dataReg + ".z, " + targetReg + ".y\n" +
	            "mul " + targetReg + ".y, " + this._dataReg + ".x, " + targetReg + ".y\n" +
	            "add " + targetReg + ".y, " + targetReg + ".x, " + targetReg + ".y\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
	        return code;
	    };
	    return SpecularFresnelMethod;
	}(SpecularCompositeMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularFresnelMethod;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(243);
	var SpecularBasicMethod_1 = __webpack_require__(247);
	/**
	 * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the
	 * calculated specular reflection strength.
	 */
	var SpecularCompositeMethod = (function (_super) {
	    __extends(SpecularCompositeMethod, _super);
	    /**
	     * Creates a new <code>SpecularCompositeMethod</code> object.
	     *
	     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
	     * @param baseMethod The base specular method on which this method's shading is based.
	     */
	    function SpecularCompositeMethod(modulateMethod, baseMethod) {
	        var _this = this;
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this._baseMethod = baseMethod || new SpecularBasicMethod_1.default();
	        this._baseMethod._iModulateMethod = modulateMethod;
	        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iInitVO = function (shader, methodVO) {
	        this._baseMethod.iInitVO(shader, methodVO);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {
	        this._baseMethod.iInitConstants(shader, methodVO);
	    };
	    SpecularCompositeMethod.prototype.iAddOwner = function (owner) {
	        _super.prototype.iAddOwner.call(this, owner);
	        this._baseMethod.iAddOwner(owner);
	    };
	    SpecularCompositeMethod.prototype.iRemoveOwner = function (owner) {
	        _super.prototype.iRemoveOwner.call(this, owner);
	        this._baseMethod.iRemoveOwner(owner);
	    };
	    Object.defineProperty(SpecularCompositeMethod.prototype, "baseMethod", {
	        /**
	         * The base specular method on which this method's shading is based.
	         */
	        get: function () {
	            return this._baseMethod;
	        },
	        set: function (value) {
	            if (this._baseMethod == value)
	                return;
	            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this._baseMethod = value;
	            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "gloss", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.gloss;
	        },
	        set: function (value) {
	            this._baseMethod.gloss = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "strength", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.strength;
	        },
	        set: function (value) {
	            this._baseMethod.strength = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "color", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.color;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this._baseMethod.color = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.dispose = function () {
	        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	        this._baseMethod.dispose();
	    };
	    Object.defineProperty(SpecularCompositeMethod.prototype, "texture", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.texture;
	        },
	        set: function (value) {
	            this._baseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this._baseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this._baseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     * @return
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iReset = function () {
	        this._baseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._baseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return SpecularCompositeMethod;
	}(SpecularBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularCompositeMethod;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadowMethodBase_1 = __webpack_require__(266);
	/**
	 * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.
	 */
	var ShadowHardMethod = (function (_super) {
	    __extends(ShadowHardMethod, _super);
	    /**
	     * Creates a new ShadowHardMethod object.
	     */
	    function ShadowHardMethod(castingLight) {
	        _super.call(this, castingLight);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var depthCol = regCache.getFreeFragmentVectorTemp();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n"; // 0 if in shadow
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        var epsReg = regCache.getFreeFragmentConstant();
	        var posReg = regCache.getFreeFragmentConstant();
	        var depthSampleCol = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(depthSampleCol, 1);
	        var lightDir = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(lightDir, 1);
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += "sub " + lightDir + ", " + sharedRegisters.globalPositionVarying + ", " + posReg + "\n" +
	            "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
	            "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" +
	            "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +
	            "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" +
	            "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" +
	            "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n"; // 0 if in shadow
	        regCache.removeFragmentTempUsage(lightDir);
	        regCache.removeFragmentTempUsage(depthSampleCol);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n"; // 0 if in shadow
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	    };
	    return ShadowHardMethod;
	}(ShadowMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowHardMethod;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularBasicMethod_1 = __webpack_require__(247);
	/**
	 * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for
	 * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.
	 * The tangent vectors are used as the surface groove directions.
	 */
	var SpecularAnisotropicMethod = (function (_super) {
	    __extends(SpecularAnisotropicMethod, _super);
	    /**
	     * Creates a new SpecularAnisotropicMethod object.
	     */
	    function SpecularAnisotropicMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularAnisotropicMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsTangents = true;
	        methodVO.needsView = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight)
	            t = this._pTotalLightColorReg;
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k
	        code += "nrm " + t + ".xyz, " + sharedRegisters.tangentVarying + ".xyz\n" +
	            "dp3 " + t + ".w, " + t + ".xyz, " + lightDirReg + ".xyz\n" +
	            "dp3 " + t + ".z, " + t + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n";
	        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k
	        code += "sin " + t + ".x, " + t + ".w\n" +
	            "sin " + t + ".y, " + t + ".z\n" +
	            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k
	            "mul " + t + ".x, " + t + ".x, " + t + ".y\n" +
	            // (t.x - cos(t.w)*cos(t.z)) ^ k
	            "cos " + t + ".z, " + t + ".z\n" +
	            "cos " + t + ".w, " + t + ".w\n" +
	            // (t.x - t.w*t.z) ^ k
	            "mul " + t + ".w, " + t + ".w, " + t + ".z\n" +
	            // (t.x - t.w) ^ k
	            "sub " + t + ".w, " + t + ".x, " + t + ".w\n";
	        if (this.texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        // attenuate
	        code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    return SpecularAnisotropicMethod;
	}(SpecularBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularAnisotropicMethod;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularCompositeMethod_1 = __webpack_require__(270);
	/**
	 * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.
	 */
	var SpecularCelMethod = (function (_super) {
	    __extends(SpecularCelMethod, _super);
	    /**
	     * Creates a new SpecularCelMethod object.
	     * @param specularCutOff The threshold at which the specular highlight should be shown.
	     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.
	     */
	    function SpecularCelMethod(specularCutOff, baseMethod) {
	        var _this = this;
	        if (specularCutOff === void 0) { specularCutOff = .5; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._smoothness = .1;
	        this._specularCutOff = .1;
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._specularCutOff = specularCutOff;
	    }
	    Object.defineProperty(SpecularCelMethod.prototype, "smoothness", {
	        /**
	         * The smoothness of the highlight edge.
	         */
	        get: function () {
	            return this._smoothness;
	        },
	        set: function (value) {
	            this._smoothness = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCelMethod.prototype, "specularCutOff", {
	        /**
	         * The threshold at which the specular highlight should be shown.
	         */
	        get: function () {
	            return this._specularCutOff;
	        },
	        set: function (value) {
	            this._specularCutOff = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._smoothness;
	        data[index + 1] = this._specularCutOff;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    /**
	     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff
	     * @param vo The MethodVO used to compile the current shader.
	     * @param t The register containing the specular strength in the "w" component, and either the half-vector or the reflection vector in "xyz".
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared register data for this shader.
	     * @return The AGAL fragment code for the method.
	     */
	    SpecularCelMethod.prototype.clampSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "sub " + targetReg + ".y, " + targetReg + ".w, " + this._dataReg + ".y\n" +
	            "div " + targetReg + ".y, " + targetReg + ".y, " + this._dataReg + ".x\n" +
	            "sat " + targetReg + ".y, " + targetReg + ".y\n" +
	            "sge " + targetReg + ".w, " + targetReg + ".w, " + this._dataReg + ".y\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    return SpecularCelMethod;
	}(SpecularCompositeMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularCelMethod;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularBasicMethod_1 = __webpack_require__(247);
	/**
	 * SpecularPhongMethod provides a specular method that provides Phong highlights.
	 */
	var SpecularPhongMethod = (function (_super) {
	    __extends(SpecularPhongMethod, _super);
	    /**
	     * Creates a new SpecularPhongMethod object.
	     */
	    function SpecularPhongMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        // phong model
	        code += "dp3 " + t + ".w, " + lightDirReg + ", " + normalReg + "\n" +
	            //find the reflected light vector R
	            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + normalReg + ", " + t + ".w\n" +
	            "sub " + t + ".xyz, " + t + ", " + lightDirReg + "\n" +
	            //smooth the edge as incidence angle approaches 90
	            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".w\n" +
	            "sat " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + t + ", " + t + ".w\n" +
	            //find the dot product between R and V
	            "dp3 " + t + ".w, " + t + ", " + viewDirReg + "\n" +
	            "sat " + t + ".w, " + t + ".w\n";
	        if (this.texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        // attenuate
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    return SpecularPhongMethod;
	}(SpecularBasicMethod_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SpecularPhongMethod;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(243);
	var ShadowMethodBase_1 = __webpack_require__(266);
	// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
	/**
	 * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize
	 * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
	 *
	 * @see away.lights.NearDirectionalShadowMapper
	 */
	var ShadowNearMethod = (function (_super) {
	    __extends(ShadowNearMethod, _super);
	    /**
	     * Creates a new ShadowNearMethod object.
	     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
	     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
	     */
	    function ShadowNearMethod(baseMethod, fadeRatio) {
	        var _this = this;
	        if (fadeRatio === void 0) { fadeRatio = .1; }
	        _super.call(this, baseMethod.castingLight);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this._baseMethod = baseMethod;
	        this._fadeRatio = fadeRatio;
	        this._nearShadowMapper = this._pCastingLight.shadowMapper;
	        if (!this._nearShadowMapper)
	            throw new Error("ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
	        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    Object.defineProperty(ShadowNearMethod.prototype, "baseMethod", {
	        /**
	         * The base shadow map method on which this method's shading is based.
	         */
	        get: function () {
	            return this._baseMethod;
	        },
	        set: function (value) {
	            if (this._baseMethod == value)
	                return;
	            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this._baseMethod = value;
	            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        this._baseMethod.iInitConstants(shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index + 2] = 0;
	        fragmentData[index + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iInitVO = function (shader, methodVO) {
	        this._baseMethod.iInitVO(shader, methodVO);
	        methodVO.needsProjection = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.dispose = function () {
	        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    };
	    Object.defineProperty(ShadowNearMethod.prototype, "alpha", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.alpha;
	        },
	        set: function (value) {
	            this._baseMethod.alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowNearMethod.prototype, "epsilon", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.epsilon;
	        },
	        set: function (value) {
	            this._baseMethod.epsilon = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowNearMethod.prototype, "fadeRatio", {
	        /**
	         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
	         */
	        get: function () {
	            return this._fadeRatio;
	        },
	        set: function (value) {
	            this._fadeRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentSingleTemp();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        code += "abs " + temp + ", " + sharedRegisters.projectionFragment + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + dataReg + ".x\n" +
	            "mul " + temp + ", " + temp + ", " + dataReg + ".y\n" +
	            "sat " + temp + ", " + temp + "\n" +
	            "sub " + temp + ", " + dataReg + ".w," + temp + "\n" +
	            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + temp + "\n" +
	            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this._baseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this._baseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        // todo: move this to activate (needs camera)
	        var near = camera.projection.near;
	        var d = camera.projection.far - near;
	        var maxDistance = this._nearShadowMapper.coverageRatio;
	        var minDistance = maxDistance * (1 - this._fadeRatio);
	        maxDistance = near + maxDistance * d;
	        minDistance = near + minDistance * d;
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index] = minDistance;
	        fragmentData[index + 1] = 1 / (maxDistance - minDistance);
	        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iReset = function () {
	        this._baseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._baseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    ShadowNearMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return ShadowNearMethod;
	}(ShadowMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowNearMethod;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PoissonLookup_1 = __webpack_require__(277);
	var ShadowMethodBase_1 = __webpack_require__(266);
	/**
	 * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.
	 */
	var ShadowSoftMethod = (function (_super) {
	    __extends(ShadowSoftMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     *
	     * @param castingLight The light casting the shadows
	     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
	     */
	    function ShadowSoftMethod(castingLight, numSamples, range) {
	        if (numSamples === void 0) { numSamples = 5; }
	        if (range === void 0) { range = 1; }
	        _super.call(this, castingLight);
	        this._range = 1;
	        this.numSamples = numSamples;
	        this.range = range;
	    }
	    Object.defineProperty(ShadowSoftMethod.prototype, "numSamples", {
	        /**
	         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
	         * complexity of the shader.
	         */
	        get: function () {
	            return this._numSamples;
	        },
	        set: function (value /*int*/) {
	            this._numSamples = value;
	            if (this._numSamples < 1)
	                this._numSamples = 1;
	            else if (this._numSamples > 32)
	                this._numSamples = 32;
	            this._offsets = PoissonLookup_1.default.getDistribution(this._numSamples);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowSoftMethod.prototype, "range", {
	        /**
	         * The range in the shadow map in which to distribute the samples.
	         */
	        get: function () {
	            return this._range;
	        },
	        set: function (value) {
	            this._range = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1 / this._numSamples;
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex + 10;
	        var len = this._numSamples << 1;
	        for (var i = 0; i < len; ++i)
	            data[index + i] = this._offsets[i] * texRange;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        // todo: move some things to super
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var dataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        return this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);
	    };
	    /**
	     * Adds the code for another tap to the shader code.
	     * @param uv The uv register for the tap.
	     * @param texture The texture register containing the depth map.
	     * @param decode The register containing the depth map decoding data.
	     * @param target The target register to add the tap comparison result.
	     * @param regCache The register cache managing the registers.
	     * @return
	     */
	    ShadowSoftMethod.prototype.addSample = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" +
	            "add " + targetRegister + ".w, " + targetRegister + ".w, " + uvReg + ".w\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var len = this._numSamples << 1;
	        data[index] = 1 / this._numSamples;
	        data[index + 1] = 0;
	        index += 2;
	        for (var i = 0; i < len; ++i)
	            data[index + i] = this._offsets[i] * texRange;
	        if (len % 4 == 0) {
	            data[index + len] = 0;
	            data[index + len + 1] = 0;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        this._pDepthMapCoordReg = depthProjection;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        return this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);
	    };
	    /**
	     * Get the actual shader code for shadow mapping
	     * @param regCache The register cache managing the registers.
	     * @param depthTexture The texture register containing the depth map.
	     * @param decodeRegister The register containing the depth map decoding data.
	     * @param targetReg The target register to add the shadow coverage.
	     * @param dataReg The register containing additional data.
	     */
	    ShadowSoftMethod.prototype.getSampleCode = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {
	        var code;
	        var uvReg = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(uvReg, 1);
	        var offsets = new Array(dataReg + ".zw");
	        var numRegs = this._numSamples >> 1;
	        for (var i = 0; i < numRegs; ++i) {
	            var reg = registerCache.getFreeFragmentConstant();
	            offsets.push(reg + ".xy");
	            offsets.push(reg + ".zw");
	        }
	        for (i = 0; i < this._numSamples; ++i) {
	            if (i == 0) {
	                var temp = registerCache.getFreeFragmentVectorTemp();
	                code = "add " + uvReg + ", " + this._pDepthMapCoordReg + ", " + dataReg + ".zwyy\n" +
	                    methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
	                    "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	                    "slt " + targetRegister + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow;
	            }
	            else {
	                code += "add " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + offsets[i] + "\n" +
	                    this.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);
	            }
	        }
	        registerCache.removeFragmentTempUsage(uvReg);
	        code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n"; // average
	        return code;
	    };
	    return ShadowSoftMethod;
	}(ShadowMethodBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ShadowSoftMethod;


/***/ },
/* 277 */
/***/ function(module, exports) {

	"use strict";
	var PoissonLookup = (function () {
	    function PoissonLookup() {
	    }
	    PoissonLookup.initDistributions = function () {
	        // precalculated for best control
	        this._distributions = new Array();
	        this._distributions[0] = new Array(0.3082841, 0.4320919);
	        this._distributions[1] = new Array(0.3082841, 0.4320919, -0.2274942, -0.6640266);
	        this._distributions[2] = new Array(0.8742689, 0.0009265686, -0.6864116, -0.5536607, -0.2325206, 0.7678371);
	        this._distributions[3] = new Array(0.3913446, -0.7084417, -0.7511101, -0.5935929, -0.2323436, 0.5320091, 0.8435315, 0.5035911);
	        this._distributions[4] = new Array(0.2122471, -0.5771395, -0.8543506, -0.1763534, 0.5189021, 0.8323698, -0.3616908, 0.5865368, 0.9523004, -0.04948437);
	        this._distributions[5] = new Array(0.5791035, 0.3496495, 0.2959551, -0.6006749, -0.2419119, -0.06879545, -0.7403072, 0.6110353, -0.04555973, 0.8059174, -0.5275017, -0.737129);
	        this._distributions[6] = new Array(0.06941478, 0.8519508, -0.7441907, 0.2426432, 0.6439992, -0.2405252, -0.1007523, -0.2327587, -0.6427067, -0.7248485, 0.8050759, 0.5492936, 0.3573822, -0.8824506);
	        this._distributions[7] = new Array(0.8509863, 0.4452587, -0.09507271, 0.2073005, 0.1706571, -0.6434793, 0.8029777, -0.2718274, -0.4401725, 0.8196304, 0.2715359, 0.8598521, -0.8121575, -0.006447683, -0.6486837, -0.7237598);
	        this._distributions[8] = new Array(0.6951686, -0.2680728, -0.04933243, 0.3710589, 0.6592212, 0.3661054, -0.01579228, -0.6909603, -0.3275101, -0.1756866, 0.3811549, 0.9218544, -0.216032, 0.9755028, -0.7065172, 0.3355389, -0.6579109, -0.6798355);
	        this._distributions[9] = new Array(0.6181276, -0.09790418, -0.2537868, -0.5570995, -0.1964931, 0.3459414, 0.3474613, -0.8885581, 0.5135743, 0.5753114, -0.9549091, 0.1480672, -0.8711916, -0.4293123, -0.6928071, 0.6190156, -0.13369, 0.8892705, 0.0548224, -0.1246777);
	        this._distributions[10] = new Array(0.4853027, -0.5080479, -0.1331675, -0.506597, 0.139575, 0.01316885, 0.803486, -0.07568797, 0.5240274, 0.4883182, -0.4334005, 0.1207938, -0.7794577, -0.3985141, 0.1576432, -0.9861221, -0.3712867, 0.6959021, 0.1517378, 0.9847429, -0.9762396, 0.1661073);
	        this._distributions[11] = new Array(-0.2790166, -0.01252619, 0.3389016, 0.3921154, 0.2408341, -0.313211, -0.8151779, -0.3898362, -0.6347761, 0.3486495, 0.09471484, -0.7722448, -0.1385674, 0.6364574, 0.2456331, 0.9295807, -0.3864306, -0.8247881, 0.6111673, -0.7164014, 0.8287669, 0.05466961, 0.837706, 0.5415626);
	        this._distributions[12] = new Array(0.056417, 0.3185693, -0.8245888, 0.1882799, 0.8575996, 0.1136829, 0.1070375, 0.875332, 0.4076743, -0.06000621, -0.4311306, 0.7239349, 0.2677574, -0.538472, -0.08486642, -0.2083647, -0.888989, -0.3906443, -0.4768958, -0.6664082, 0.09334993, -0.9861541, 0.808736, -0.455949, 0.5889823, 0.7660807);
	        this._distributions[13] = new Array(-0.2681346, -0.3955857, -0.1315102, -0.8852947, -0.5143692, 0.09551838, 0.4344836, -0.546945, -0.8620899, -0.3813288, 0.1650431, 0.02034803, -0.1543657, 0.3842218, -0.828457, 0.5376903, -0.6145, -0.7818927, -0.2639062, 0.8784655, 0.1912684, 0.9720125, 0.3135219, 0.5224229, 0.7850655, 0.4592297, 0.7465045, -0.1368916);
	        this._distributions[14] = new Array(0.4241029, 0.695281, 0.150511, -0.02304107, -0.2482675, 0.9120338, 0.8057325, 0.2622084, -0.2445909, 0.2765962, 0.8588713, -0.1772072, 0.3117845, -0.4385471, -0.3923851, -0.3298936, -0.1751254, -0.7405846, 0.6926506, -0.684163, -0.9304563, -0.3254691, -0.8533293, 0.1523024, 0.2510415, -0.917345, -0.6239773, -0.7105472, -0.6104624, 0.6041355);
	        this._distributions[15] = new Array(0.5844554, 0.06651045, 0.1343258, 0.6756578, 0.3799674, -0.6301104, 0.5590436, 0.7940555, 0.09574714, 0.02262517, 0.8697868, 0.393301, 0.003945862, -0.421735, 0.9043913, -0.2432393, -0.4844007, 0.7190998, -0.3201078, 0.2972371, -0.3852352, -0.6341155, -0.5413069, -0.09223081, -0.8468984, -0.5126905, 0.004156174, -0.8633173, -0.9681889, -0.03305046, -0.846509, 0.4414353);
	        this._distributions[16] = new Array(0.4506488, 0.657668, 0.4621297, 0.07441051, -0.2782125, 0.6201044, 0.9750003, 0.09110117, 0.1019436, 0.2986514, 0.03457398, 0.9631706, 0.542098, -0.5505635, 0.8675668, 0.4938077, -0.5414361, 0.2655292, -0.7941836, 0.6003053, -0.09847672, -0.1001604, -0.9316511, -0.08572888, 0.07286467, -0.611899, -0.5232627, -0.4082253, -0.5481608, -0.827938, -0.1551939, -0.9621193, 0.9220031, -0.3315949);
	        this._distributions[17] = new Array(0.197908, -0.4697656, -0.4474689, -0.3428435, 0.8529873, -0.2228634, 0.6022478, -0.5469642, 0.2545276, -0.931133, -0.1507547, -0.7855865, -0.07606658, 0.1011628, 0.3046715, 0.2785755, 0.4698432, -0.1064076, 0.6831254, 0.4152522, 0.1374381, 0.8363233, -0.2166121, 0.6682042, 0.5511393, 0.7996449, -0.4278994, 0.28836, -0.8875198, 0.2181732, -0.8772842, -0.2818254, -0.7000262, 0.5762185, -0.6062385, -0.7439126);
	        this._distributions[18] = new Array(0.6645703, -0.05678739, 0.5720971, 0.4533803, -0.07660709, 0.08802763, 0.5163431, -0.4426552, 0.1163455, -0.3404382, -0.4004807, -0.5046007, 0.2932099, -0.8201418, -0.5322125, 0.03834766, -0.1490209, -0.8817304, -0.8000439, -0.3509448, 0.5260983, 0.8421043, 0.1197811, 0.6963812, 0.9498612, 0.3122156, -0.9285746, 0.02120355, -0.6670724, 0.7217396, 0.9155889, -0.3510147, -0.271941, 0.4727852, 0.318879, 0.1634057, -0.2686755, 0.9253026);
	        this._distributions[19] = new Array(0.5064292, 0.422527, 0.8935515, -0.06610427, 0.1199719, 0.175568, 0.403388, -0.2003276, 0.1657927, 0.8154403, 0.9301245, 0.2929218, -0.1644068, 0.6201534, 0.7113559, -0.6589743, -0.3364046, -0.1799502, 0.02109996, -0.392765, -0.382213, 0.3219992, -0.9201946, 0.1207967, -0.726185, 0.4291916, -0.7443482, -0.2480059, -0.5147594, 0.7418784, 0.1935272, -0.7406143, -0.3643523, -0.5559214, -0.7147766, -0.6326278, -0.2524151, -0.9096627, 0.5161405, 0.7908453);
	        this._distributions[20] = new Array(0.7921003, -0.3032096, 0.5992879, -0.009052323, 0.2538549, -0.1872749, 0.7053444, 0.3677175, 0.5417761, -0.8170255, 0.9749611, 0.1210478, 0.1969143, -0.6117041, -0.1824499, -0.4634196, -0.1181338, -0.8668742, -0.3050112, -0.1352596, -0.4409327, -0.7082354, -0.03225285, 0.1171548, 0.3113096, 0.3250439, -0.8166144, -0.463995, -0.01014475, 0.4715334, -0.6868284, 0.05091889, -0.4011163, 0.2717285, -0.06756835, 0.8307694, -0.7938535, 0.4352129, -0.4663842, 0.7165329, 0.559729, 0.8093995);
	        this._distributions[21] = new Array(0.07832243, 0.426151, -0.3856795, 0.5799953, 0.01970797, 0.06706189, 0.4822682, 0.3014512, -0.1532982, 0.87485, -0.4959527, 0.07888043, 0.260601, -0.2304784, 0.4996209, 0.7167382, 0.585986, -0.04265174, -0.7679967, 0.5509416, -0.9041753, 0.1802134, -0.8407655, -0.4442826, -0.2058258, -0.2636995, -0.4984115, -0.5928579, 0.2926032, -0.7886473, -0.06933882, -0.621177, 0.578115, -0.4813387, 0.8981777, -0.3291056, 0.1942733, 0.9255584, 0.8084362, 0.5066984, 0.9920095, 0.03103104, -0.2403206, -0.9389018);
	        this._distributions[22] = new Array(-0.5691095, 0.1014316, -0.7788262, 0.384012, -0.8253665, -0.1645582, -0.1830993, 0.002997211, -0.2555013, -0.4177977, -0.6640869, -0.4794711, -0.2351242, 0.5850121, 0.02436554, 0.2825883, 0.006061143, -0.8200245, 0.1618791, -0.3063331, -0.3765897, -0.7249815, 0.6092919, -0.6769328, -0.5956934, 0.6957655, 0.5383642, 0.4522677, -0.1489165, 0.9125596, 0.4167473, 0.1335986, 0.1898309, 0.5874342, 0.2288171, 0.9624356, 0.7540846, -0.07672304, 0.8986252, 0.2788797, 0.3555991, -0.9262139, 0.8454325, -0.4027667, 0.4945236, -0.2935512);
	        this._distributions[23] = new Array(-0.4481403, -0.3758374, -0.8877251, 0.08739938, 0.05015831, -0.1339983, -0.4070427, -0.8534173, 0.1019274, -0.5503222, -0.445998, 0.1997541, -0.8686263, -0.2788867, -0.7695944, -0.6033704, -0.05515742, -0.885711, -0.7714347, 0.5790485, 0.3466263, -0.8799297, 0.4487582, -0.5321087, -0.2461368, 0.6053771, -0.05568117, 0.2457351, -0.4668669, 0.8523816, 0.8103387, -0.4255538, 0.4054182, -0.175663, -0.2802011, -0.08920153, 0.2665959, 0.382935, 0.555679, 0.1621837, 0.105246, 0.8420411, 0.6921161, 0.6902903, 0.880946, 0.2483067, 0.9699264, -0.1021767);
	        this._distributions[24] = new Array(-0.1703323, -0.3119385, 0.2916039, -0.2988263, -0.008472982, -0.9277695, -0.7730271, -0.3277904, 0.3440474, -0.6815342, -0.2910278, 0.03461745, -0.6764899, -0.657078, -0.3505501, -0.7311988, -0.03478927, 0.3258755, -0.6048835, 0.159423, 0.2035525, 0.02212214, 0.5116573, 0.2226856, 0.6664805, -0.2500189, 0.7147882, -0.6609634, 0.03030632, -0.5763278, -0.2516585, 0.6116219, -0.9434413, -0.0116792, 0.9061816, 0.2491155, 0.182867, 0.6076167, 0.286593, 0.9485695, -0.5992439, 0.6970096, -0.2082874, 0.9416641, 0.9880044, -0.1541709, -0.9122881, 0.331555, 0.7324886, 0.6725098);
	        this._distributions[25] = new Array(0.3869598, -0.04974834, 0.7168844, -0.0693711, -0.07166742, 0.1725325, 0.4599592, 0.3232779, 0.5872094, -0.4198674, 0.2442266, -0.625667, 0.1254557, 0.4500048, -0.2290154, -0.1803567, 0.890583, 0.3373493, 0.1256081, 0.7853789, -0.2676466, 0.5305805, -0.7063224, 0.252168, -0.3989835, 0.1189921, 0.09617215, -0.2451447, 0.6302541, 0.6085876, 0.9380925, -0.3234899, 0.5086241, -0.8573482, 0.03576187, -0.9876697, -0.0876712, -0.6365195, -0.5276513, 0.823456, -0.6935764, -0.2240411, -0.5212318, -0.5383121, -0.2116208, 0.9639363, -0.9840096, 0.02743555, -0.3991577, -0.8994547, -0.7830126, 0.614068);
	        this._distributions[26] = new Array(-0.8366601, 0.4464895, -0.5917366, -0.02073906, -0.9845258, 0.1635625, -0.3097973, 0.4379579, -0.5478154, 0.7173221, -0.1685888, 0.9261969, 0.01503595, 0.6046097, 0.4452421, 0.5449086, 0.0315687, 0.1944619, 0.3753404, 0.8688548, 0.4143643, 0.1396648, 0.8711032, 0.4304703, 0.7328773, 0.1461501, 0.6374492, -0.3521495, 0.145613, -0.1341466, 0.9040975, -0.135123, -0.7839059, -0.5450199, -0.516019, -0.3320859, -0.206158, -0.4431106, -0.9703014, -0.2368356, -0.2473119, -0.0864351, 0.2130725, -0.4604077, -0.003726701, -0.7122303, -0.4072131, -0.6833169, 0.1632999, -0.9776646, 0.4686888, -0.680495, -0.2293511, -0.9509777);
	        this._distributions[27] = new Array(0.107311, -0.1311369, -0.4194764, -0.3148777, 0.6171439, -0.2745973, 0.2796618, 0.1937153, -0.09106886, 0.4180236, 0.6044006, 0.05577846, 0.02927299, -0.6738263, -0.2580845, 0.1179939, -0.09023564, -0.3830024, 0.3570953, -0.5000587, 0.81591, -0.5518309, 0.9300217, -0.1257987, 0.4904627, -0.8381903, -0.3163182, -0.8632009, 0.1137595, -0.9875998, 0.8390043, 0.3538185, 0.2149114, 0.4993694, 0.5191584, 0.3833552, 0.5002763, 0.7061465, -0.2567276, 0.9068756, -0.5197366, 0.3467845, 0.03668867, 0.9734009, -0.5347553, 0.66747, -0.9028882, 0.1023768, -0.8967977, 0.412834, -0.5821944, 0.0426479, -0.8032165, -0.2397038, -0.5597343, -0.6358021);
	        this._distributions[28] = new Array(-0.6562496, -0.1781036, -0.9301494, 0.1185208, -0.3861143, -0.4153562, -0.1560799, -0.1099607, -0.5587025, 0.395218, -0.5322112, -0.699701, -0.5008639, 0.08726846, -0.970524, -0.1963461, -0.813577, -0.5185111, -0.1644458, 0.298, -0.3216791, 0.639982, 0.3315373, 0.3339162, 0.2383235, -0.00105722, 0.1137828, 0.5450742, -0.01899921, 0.8798413, 0.2849685, 0.8255596, 0.6974412, 0.2123175, 0.7588523, 0.5470437, 0.5102502, -0.1687844, 0.5853448, 0.8033476, 0.2590716, -0.5262504, 0.5607718, -0.6342825, 0.8666443, -0.1491841, 0.8341052, -0.4935003, -0.1568441, -0.6634066, 0.2512113, -0.8769391, -0.2559827, -0.9572457, -0.01928852, -0.3966542, -0.750667, 0.6409678);
	        this._distributions[29] = new Array(0.3454786, -0.04837726, 0.2649553, 0.2406852, 0.5599093, -0.3839145, -0.1111814, -0.05502108, 0.7586042, -0.05818377, 0.2519488, -0.4665135, -0.1264972, 0.2602723, -0.08766216, -0.3671907, 0.6428129, 0.3999204, -0.6105871, -0.1246869, -0.4589451, -0.7646643, -0.03021116, -0.7899352, -0.6036922, -0.4293956, -0.2481938, 0.6534185, 0.102798, 0.6784465, -0.6392644, 0.4821358, -0.6789002, 0.1779133, -0.9140783, -0.1989647, -0.9262617, 0.3381507, 0.4794891, -0.8093274, 0.3959447, 0.668478, 0.9602883, 0.2272305, -0.123672, 0.9210883, 0.2375148, 0.9523395, -0.52898, 0.7973378, -0.382433, 0.1228794, 0.695015, 0.6948439, 0.7530277, -0.6458191, 0.8777987, -0.3272956, 0.2318525, -0.962768);
	        this._distributions[30] = new Array(0.4518921, -0.1146195, 0.4720805, -0.4238748, 0.3655423, 0.1806341, 0.1589939, -0.23568, 0.7673324, -0.5149941, 0.01163658, 0.09045836, 0.7010971, 0.1245747, 0.7518286, -0.1855433, 0.4960719, 0.4601022, 0.2566979, -0.6308268, -0.0654714, -0.5126389, -0.1823319, -0.1343282, -0.1464312, 0.4883236, -0.3858738, 0.203523, 0.1484799, 0.4432284, -0.477109, -0.116241, 0.2719092, 0.7208626, 0.9104174, 0.3578536, -0.5956199, 0.7662588, -0.6996251, 0.3678654, -0.2514512, 0.9251933, 0.1275825, -0.9478135, -0.204608, -0.8611552, 0.4264838, -0.877443, 0.9854161, 0.05521112, 0.5912951, 0.7997434, 0.1140349, 0.982093, -0.9324368, -0.2094094, -0.42436, -0.6441524, -0.6722705, -0.3554261, -0.7844236, 0.08587621);
	        this._distributions[31] = new Array(-0.4206714, -0.5613642, -0.8733016, -0.3373051, -0.1046226, -0.2902999, -0.1318562, -0.8434365, 0.1145093, -0.5962623, -0.4965627, -0.1873259, -0.5011808, -0.8546229, -0.7165636, -0.5743566, 0.1090901, 0.2017643, 0.3404809, -0.220455, -0.1989015, 0.2372122, -0.4538706, 0.0979171, 0.4514146, -0.572846, 0.2314168, -0.8514503, -0.4247236, 0.5650803, -0.943347, 0.04514639, -0.1309718, 0.5221877, -0.7004157, 0.4561877, 0.6306441, 0.04448673, 0.4301621, 0.5766876, 0.1078042, 0.7245752, 0.3875354, 0.2794483, 0.702876, -0.2924213, 0.7360667, -0.6210318, 0.7486517, 0.6531103, 0.4898235, 0.8591025, 0.6549174, 0.3854057, -0.2596106, 0.7916998, 0.9251194, -0.05296265, -0.5620695, 0.820877, -0.01228026, 0.9937211, 0.9612103, 0.2628758);
	    };
	    PoissonLookup.getDistribution = function (n /*int*/) {
	        if (!this._distributions)
	            this.initDistributions();
	        if (n < 2 || n > 32)
	            return null;
	        return this._distributions[n - 1];
	    };
	    return PoissonLookup;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PoissonLookup;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AS2MovieClipAdapter_1 = __webpack_require__(279);
	var AS2TextFieldAdapter_1 = __webpack_require__(286);
	var TextField_1 = __webpack_require__(281);
	var MovieClip_1 = __webpack_require__(280);
	var AS2SceneGraphFactory = (function () {
	    function AS2SceneGraphFactory(view) {
	        this._view = view;
	    }
	    AS2SceneGraphFactory.prototype.createMovieClip = function (timeline) {
	        var mc = new MovieClip_1.default(timeline);
	        mc.adapter = new AS2MovieClipAdapter_1.default(mc, this._view);
	        return mc;
	    };
	    AS2SceneGraphFactory.prototype.createTextField = function () {
	        var tf = new TextField_1.default();
	        tf.adapter = new AS2TextFieldAdapter_1.default(tf, this._view);
	        return tf;
	    };
	    return AS2SceneGraphFactory;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2SceneGraphFactory;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var Point_1 = __webpack_require__(36);
	var AssetLibrary_1 = __webpack_require__(4);
	var MovieClip_1 = __webpack_require__(280);
	var MouseEvent_1 = __webpack_require__(71);
	var AS2SymbolAdapter_1 = __webpack_require__(284);
	var AS2MCSoundProps_1 = __webpack_require__(285);
	var includeString = 'var Color			from "awayjs-player/lib/adapters/AS2ColorAdapter";\n' +
	    'var System				from "awayjs-player/lib/adapters/AS2SystemAdapter";\n' +
	    'var Sound				from "awayjs-player/lib/adapters/AS2SoundAdapter";\n' +
	    'var Key				from "awayjs-player/lib/adapters/AS2KeyAdapter";\n' +
	    'var Mouse				from "awayjs-player/lib/adapters/AS2MouseAdapter";\n' +
	    'var Stage				from "awayjs-player/lib/adapters/AS2StageAdapter";\n' +
	    'var SharedObject		from "awayjs-player/lib/adapters/AS2SharedObjectAdapter";\n' +
	    'var int = function(value) {return Math.floor(value) | 0;}\n' +
	    'var string = function(value) {return value.toString();}\n' +
	    'var getURL = function(value) {return value;}\n';
	var AS2MovieClipAdapter = (function (_super) {
	    __extends(AS2MovieClipAdapter, _super);
	    function AS2MovieClipAdapter(adaptee, view) {
	        // create an empty MovieClip if none is passed
	        _super.call(this, adaptee || new MovieClip_1.default(), view);
	        this.__pSoundProps = new AS2MCSoundProps_1.default();
	    }
	    AS2MovieClipAdapter.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this.__pSoundProps.dispose();
	        this.__pSoundProps = null;
	    };
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_framesloaded", {
	        get: function () {
	            // not loading frame by frame?
	            return this.adaptee.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_currentframe", {
	        get: function () {
	            return this.adaptee.currentFrameIndex + 1;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_totalframes", {
	        get: function () {
	            return this.adaptee.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "enabled", {
	        get: function () {
	            return this.adaptee.mouseEnabled;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2MovieClipAdapter.prototype.evalScript = function (str) {
	        try {
	            var tag = document.createElement('script');
	            tag.text = includeString + 'var __framescript__ = function() {\n' + str + '\n}';
	            //add and remove script tag to dom to trigger compilation
	            var sibling = document.scripts[0];
	            sibling.parentNode.insertBefore(tag, sibling).parentNode.removeChild(tag);
	            var script = __framescript__;
	            delete window['__framescript__'];
	        }
	        catch (err) {
	            console.log("Syntax error in script:\n", str);
	            console.log(err.message);
	            throw err;
	        }
	        return script;
	    };
	    //attachAudio(id: AS2SoundAdapter):void {	}
	    //attachBitmap(bmp: BitmapImage2D, depth: Number, pixelSnapping: String = null, smoothing: boolean = false):void { }
	    AS2MovieClipAdapter.prototype.attachMovie = function (id, name, depth, initObject) {
	        if (initObject === void 0) { initObject = null; }
	        var attached_mc = AssetLibrary_1.default.getAsset(id);
	        var cloned_mc = attached_mc.clone();
	        var adapter = new AS2MovieClipAdapter(cloned_mc, this._view);
	        this.adaptee.addChildAtDepth(adapter.adaptee, depth);
	        adapter.adaptee.name = name;
	        this.registerScriptObject(adapter.adaptee);
	        return attached_mc;
	        // todo: apply object from initObject to attached_mc
	    };
	    //beginBitmapFill(bmp: BitmapImage2D, matrix: Matrix = null, repeat: boolean = false, smoothing: boolean = false):void {}
	    //beginFill(rgb: Number, alpha: number = 1.0):void {}
	    //beginGradientFill(fillType: string, colors: Array, alphas: Array, ratios: Array, matrix: Object, spreadMethod: string = null, interpolationMethod: string  = null, focalPointRatio: number  = null):void {}
	    //clear():void {}
	    AS2MovieClipAdapter.prototype.createEmptyMovieClip = function (name, depth) {
	        var mc = new MovieClip_1.default();
	        mc.adapter = new AS2MovieClipAdapter(mc, this._view);
	        mc.name = name;
	        this.adaptee.addChildAtDepth(mc, depth);
	        this.registerScriptObject(mc);
	        return mc.adapter;
	    };
	    //createTextField(instanceName: String, depth: Number, x: Number, y: Number, width: Number, height: Number):TextField {}
	    //curveTo(controlX: number, controlY: number, anchorX: number, anchorY: number):void {}
	    AS2MovieClipAdapter.prototype.duplicateMovieClip = function (name, depth, initObject) {
	        var duplicate = this.adaptee.clone().adapter;
	        duplicate.adaptee.name = name;
	        if (initObject)
	            for (var key in initObject)
	                if (duplicate.hasOwnProperty(key))
	                    duplicate[key] = initObject[key];
	        this.adaptee.parent.addChildAtDepth(duplicate.adaptee, depth);
	        return duplicate;
	    };
	    //endFill():void {}
	    //getBounds(bounds: Object):Object { return null; }
	    // not applicable?
	    AS2MovieClipAdapter.prototype.getBytesLoaded = function () { return 1; };
	    // not applicable?
	    AS2MovieClipAdapter.prototype.getBytesTotal = function () { return 1; };
	    AS2MovieClipAdapter.prototype.getInstanceAtDepth = function (depth) {
	        return this.adaptee.getChildAtDepth(depth);
	    };
	    AS2MovieClipAdapter.prototype.getNextHighestDepth = function () {
	        return this.adaptee.getNextHighestDepth();
	    };
	    //getRect(bounds: Object):Object { return null; }
	    //getSWFVersion():number { return 0; }
	    //getTextSnapshot():TextSnapshot {}
	    //getURL(url: string, window: string, method: string):void {}
	    AS2MovieClipAdapter.prototype.globalToLocal = function (pt) {
	        var newPoint = this.adaptee.globalToLocal(new Point_1.default(pt.x, pt.y));
	        pt.x = newPoint.x;
	        pt.y = newPoint.y;
	    };
	    AS2MovieClipAdapter.prototype.gotoAndPlay = function (frame) {
	        if (frame == null)
	            return;
	        this.play();
	        this._gotoFrame(frame);
	    };
	    AS2MovieClipAdapter.prototype.gotoAndStop = function (frame) {
	        if (frame == null)
	            return;
	        this.stop();
	        this._gotoFrame(frame);
	    };
	    AS2MovieClipAdapter.prototype.play = function () {
	        this.adaptee.play();
	    };
	    AS2MovieClipAdapter.prototype.stop = function () {
	        this.adaptee.stop();
	    };
	    AS2MovieClipAdapter.prototype.hitTest = function (x, y, shapeFlag) {
	        if (shapeFlag === void 0) { shapeFlag = false; }
	        return this.adaptee.hitTestPoint(x, y, shapeFlag);
	    };
	    //lineGradientStyle(fillType: string, colors: array, alphas: array, ratios: array, matrix: Object, spreadMethod: string = null, interpolationMethod: string, focalPointRatio: number):void {}
	    //lineStyle(thickness: number, rgb: number, alpha: number, pixelHinting: boolean, noScale: string, capsStyle: string, jointStyle: string, miterLimit: number):void {}
	    //lineTo(x: number, y: number):void {}
	    //loadMovie(url: string, method: string = null):void {}
	    //loadVariables(url: string, method: string = null):void {}
	    AS2MovieClipAdapter.prototype.localToGlobal = function (pt) {
	        var newPoint = this.adaptee.localToGlobal(new Point_1.default(pt.x, pt.y));
	        pt.x = newPoint.x;
	        pt.y = newPoint.y;
	    };
	    //moveTo(x: number, y: number):void {}
	    AS2MovieClipAdapter.prototype.nextFrame = function () {
	        ++this.adaptee.currentFrameIndex;
	    };
	    AS2MovieClipAdapter.prototype.prevFrame = function () {
	        --this.adaptee.currentFrameIndex;
	    };
	    //removeMovieClip():void {}
	    AS2MovieClipAdapter.prototype.setMask = function (mc) {
	        this.adaptee.masks = [mc];
	    };
	    //startDrag(lockCenter: boolean = false, left: number = 0, top: number = 0, right: number = 0, bottom: number = 0):void {}
	    //stopDrag():void {}
	    AS2MovieClipAdapter.prototype.swapDepths = function (target) {
	        var parent = this.adaptee.parent;
	        if (parent != null && target.parent == parent)
	            parent.swapChildren(this.adaptee, target);
	    };
	    //unloadMovie():void {}
	    AS2MovieClipAdapter.prototype.clone = function (newAdaptee) {
	        return new AS2MovieClipAdapter(newAdaptee, this._view);
	    };
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onEnterFrame", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onEnterFrame;
	        },
	        set: function (value) {
	            this._onEnterFrame = this._replaceEventListener(AssetEvent_1.default.ENTER_FRAME, this._onEnterFrame, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOut", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRollOut;
	        },
	        set: function (value) {
	            this._onRollOut = this._replaceEventListener(MouseEvent_1.default.MOUSE_OUT, this._onRollOut, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOver", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRollOver;
	        },
	        set: function (value) {
	            this._onRollOver = this._replaceEventListener(MouseEvent_1.default.MOUSE_OVER, this._onRollOver, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRelease", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRelease;
	        },
	        set: function (value) {
	            this._onRelease = this._replaceEventListener(MouseEvent_1.default.MOUSE_UP, this._onRelease, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onPress", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onPress;
	        },
	        set: function (value) {
	            this._onPress = this._replaceEventListener(MouseEvent_1.default.MOUSE_DOWN, this._onPress, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseDown", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onMouseDown;
	        },
	        set: function (value) {
	            this._onMouseDown = this._replaceEventListener(MouseEvent_1.default.MOUSE_DOWN, this._onMouseDown, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseUp", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onMouseUp;
	        },
	        set: function (value) {
	            this._onMouseUp = this._replaceEventListener(MouseEvent_1.default.MOUSE_UP, this._onMouseUp, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2MovieClipAdapter.prototype.registerScriptObject = function (child) {
	        if (child.name)
	            this[child.name] = child.adapter ? child.adapter : child;
	    };
	    AS2MovieClipAdapter.prototype.unregisterScriptObject = function (child) {
	        delete this[child.name];
	        if (child.isAsset(MovieClip_1.default))
	            child.removeButtonListeners();
	    };
	    AS2MovieClipAdapter.prototype._gotoFrame = function (frame) {
	        var mc = this.adaptee;
	        if (typeof frame === "string")
	            mc.jumpToLabel(frame);
	        else
	            mc.currentFrameIndex = frame - 1;
	    };
	    AS2MovieClipAdapter.prototype._replaceEventListener = function (eventType, currentListener, newListener) {
	        var mc = this.adaptee;
	        if (currentListener)
	            mc.removeEventListener(eventType, currentListener);
	        if (newListener) {
	            var self = this;
	            var delegate = function () { return newListener.call(self); };
	            mc.addEventListener(eventType, delegate);
	        }
	        return delegate;
	    };
	    return AS2MovieClipAdapter;
	}(AS2SymbolAdapter_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2MovieClipAdapter;


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var Sprite_1 = __webpack_require__(73);
	var TextField_1 = __webpack_require__(281);
	var MouseEvent_1 = __webpack_require__(71);
	var Timeline_1 = __webpack_require__(283);
	var FrameScriptManager_1 = __webpack_require__(72);
	var MovieClip = (function (_super) {
	    __extends(MovieClip, _super);
	    function MovieClip(timeline) {
	        var _this = this;
	        if (timeline === void 0) { timeline = null; }
	        _super.call(this);
	        this._isButton = false;
	        this._time = 0; // the current time inside the animation
	        this._currentFrameIndex = -1; // the current frame
	        this._isPlaying = true; // false if paused or stopped
	        this._isInit = true;
	        this._potentialInstances = [];
	        this._depth_sessionIDs = {};
	        this._sessionID_childs = {};
	        /**
	         *
	         */
	        this.loop = true;
	        /**
	         * the current index of the current active frame
	         */
	        this.constructedKeyFrameIndex = -1;
	        this._enterFrame = new AssetEvent_1.default(AssetEvent_1.default.ENTER_FRAME, this);
	        this.inheritColorTransform = true;
	        this._onMouseOver = function (event) { return _this.currentFrameIndex = 1; };
	        this._onMouseOut = function (event) { return _this.currentFrameIndex = 0; };
	        this._onMouseDown = function (event) { return _this.currentFrameIndex = 2; };
	        this._onMouseUp = function (event) { return _this.currentFrameIndex = _this.currentFrameIndex == 0 ? 0 : 1; };
	        this._timeline = timeline || new Timeline_1.default();
	    }
	    Object.defineProperty(MovieClip.prototype, "adapter", {
	        /**
	         * adapter is used to provide MovieClip to scripts taken from different platforms
	         * setter typically managed by factory
	         */
	        get: function () {
	            return this._adapter;
	        },
	        set: function (value) {
	            this._adapter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.dispose = function () {
	        this.disposeValues();
	        MovieClip._movieClips.push(this);
	    };
	    MovieClip.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._potentialInstances = [];
	        this._depth_sessionIDs = {};
	        this._sessionID_childs = {};
	    };
	    MovieClip.prototype.reset_textclones = function () {
	        if (this.timeline) {
	            var len = this._potentialInstances.length;
	            for (var i = 0; i < len; i++) {
	                if (this._potentialInstances[i] != null) {
	                    if (this._potentialInstances[i].isAsset(TextField_1.default))
	                        this._potentialInstances[i].text = this.timeline.getPotentialChildPrototype(i).text;
	                    else if (this._potentialInstances[i].isAsset(MovieClip))
	                        this._potentialInstances[i].reset_textclones();
	                }
	            }
	        }
	    };
	    Object.defineProperty(MovieClip.prototype, "isInit", {
	        get: function () {
	            return this._isInit;
	        },
	        set: function (value) {
	            this._isInit = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MovieClip.prototype, "timeline", {
	        get: function () {
	            return this._timeline;
	        },
	        set: function (value) {
	            this._timeline = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MovieClip.prototype, "numFrames", {
	        get: function () {
	            return this._timeline.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.jumpToLabel = function (label) {
	        // the timeline.jumpTolabel will set currentFrameIndex
	        this._timeline.jumpToLabel(this, label);
	    };
	    MovieClip.prototype.reset = function () {
	        _super.prototype.reset.call(this);
	        // time only is relevant for the root mc, as it is the only one that executes the update function
	        this._time = 0;
	        if (this.adapter)
	            this.adapter.freeFromScript();
	        this.constructedKeyFrameIndex = -1;
	        for (var i = this.numChildren - 1; i >= 0; i--)
	            this.removeChildAt(i);
	        this._skipAdvance = MovieClip._skipAdvance;
	        var numFrames = this._timeline.keyframe_indices.length;
	        this._isPlaying = Boolean(numFrames > 1);
	        if (numFrames) {
	            this._currentFrameIndex = 0;
	            this._timeline.constructNextFrame(this, true, true);
	        }
	        else {
	            this._currentFrameIndex = -1;
	        }
	    };
	    MovieClip.prototype.resetSessionIDs = function () {
	        this._depth_sessionIDs = {};
	    };
	    Object.defineProperty(MovieClip.prototype, "currentFrameIndex", {
	        /*
	        * Setting the currentFrameIndex will move the playhead for this movieclip to the new position
	         */
	        get: function () {
	            return this._currentFrameIndex;
	        },
	        set: function (value) {
	            //if currentFrame is set greater than the available number of
	            //frames, the playhead is moved to the last frame in the timeline.
	            //But because the frame specified was not a keyframe, no scripts are
	            //executed, even if they exist on the last frame.
	            var skip_script = false;
	            var numFrames = this._timeline.keyframe_indices.length;
	            if (!numFrames)
	                return;
	            if (value < 0) {
	                value = 0;
	            }
	            else if (value >= numFrames) {
	                value = numFrames - 1;
	                skip_script = true;
	            }
	            if (this._currentFrameIndex == value)
	                return;
	            this._currentFrameIndex = value;
	            //changing current frame will ignore advance command for that
	            //update's advanceFrame function, unless advanceFrame has
	            //already been executed
	            this._skipAdvance = MovieClip._skipAdvance;
	            this._timeline.gotoFrame(this, value, skip_script);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.addButtonListeners = function () {
	        this._isButton = true;
	        this.stop();
	        this.addEventListener(MouseEvent_1.default.MOUSE_OVER, this._onMouseOver);
	        this.addEventListener(MouseEvent_1.default.MOUSE_OUT, this._onMouseOut);
	        this.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this._onMouseDown);
	        this.addEventListener(MouseEvent_1.default.MOUSE_UP, this._onMouseUp);
	    };
	    MovieClip.prototype.removeButtonListeners = function () {
	        this.removeEventListener(MouseEvent_1.default.MOUSE_OVER, this._onMouseOver);
	        this.removeEventListener(MouseEvent_1.default.MOUSE_OUT, this._onMouseOut);
	        this.removeEventListener(MouseEvent_1.default.MOUSE_DOWN, this._onMouseDown);
	        this.removeEventListener(MouseEvent_1.default.MOUSE_UP, this._onMouseUp);
	    };
	    MovieClip.prototype.getChildAtSessionID = function (sessionID) {
	        return this._sessionID_childs[sessionID];
	    };
	    MovieClip.prototype.getSessionIDDepths = function () {
	        return this._depth_sessionIDs;
	    };
	    MovieClip.prototype.addChildAtDepth = function (child, depth, replace) {
	        if (replace === void 0) { replace = true; }
	        //this should be implemented for all display objects
	        child.inheritColorTransform = true;
	        child.reset(); // this takes care of transform and visibility
	        return _super.prototype.addChildAtDepth.call(this, child, depth, replace);
	    };
	    MovieClip.prototype._addTimelineChildAt = function (child, depth, sessionID) {
	        this._depth_sessionIDs[depth] = child._sessionID = sessionID;
	        this._sessionID_childs[sessionID] = child;
	        return this.addChildAtDepth(child, depth);
	    };
	    MovieClip.prototype.removeChildAtInternal = function (index) {
	        var child = this._children[index];
	        if (child.adapter)
	            child.adapter.freeFromScript();
	        this.adapter.unregisterScriptObject(child);
	        //check to make sure _depth_sessionIDs wasn't modified with a new child
	        if (this._depth_sessionIDs[child._depthID] == child._sessionID)
	            delete this._depth_sessionIDs[child._depthID];
	        delete this._sessionID_childs[child._sessionID];
	        child._sessionID = -1;
	        return _super.prototype.removeChildAtInternal.call(this, index);
	    };
	    Object.defineProperty(MovieClip.prototype, "assetType", {
	        get: function () {
	            return MovieClip.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Starts playback of animation from current position
	     */
	    MovieClip.prototype.play = function () {
	        if (this._timeline.keyframe_indices.length > 1)
	            this._isPlaying = true;
	    };
	    /**
	     * should be called right before the call to away3d-render.
	     */
	    MovieClip.prototype.update = function () {
	        MovieClip._skipAdvance = true;
	        this.advanceFrame();
	        MovieClip._skipAdvance = false;
	        // after we advanced the scenegraph, we might have some script that needs executing
	        FrameScriptManager_1.default.execute_queue();
	        // now we want to execute the onEnter
	        this.dispatchEvent(this._enterFrame);
	        // after we executed the onEnter, we might have some script that needs executing
	        FrameScriptManager_1.default.execute_queue();
	        // now we execute any intervals queued
	        FrameScriptManager_1.default.execute_intervals();
	        // finally, we execute any scripts that were added from intervals
	        FrameScriptManager_1.default.execute_queue();
	        //execute any disposes as a result of framescripts
	        FrameScriptManager_1.default.execute_dispose();
	    };
	    MovieClip.prototype.getPotentialChildInstance = function (id) {
	        if (!this._potentialInstances[id])
	            this._potentialInstances[id] = this._timeline.getPotentialChildInstance(id);
	        return this._potentialInstances[id];
	    };
	    /**
	     * Stop playback of animation and hold current position
	     */
	    MovieClip.prototype.stop = function () {
	        this._isPlaying = false;
	    };
	    MovieClip.prototype.clone = function () {
	        var newInstance = (MovieClip._movieClips.length) ? MovieClip._movieClips.pop() : new MovieClip(this._timeline);
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    MovieClip.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.timeline = this._timeline;
	        newInstance.loop = this.loop;
	    };
	    MovieClip.prototype.advanceFrame = function () {
	        if (this._isPlaying && !this._skipAdvance) {
	            if (this._currentFrameIndex == this._timeline.keyframe_indices.length - 1) {
	                if (this.loop)
	                    this.currentFrameIndex = 0;
	                else
	                    this._isPlaying = false;
	            }
	            else {
	                this._currentFrameIndex++;
	                this._timeline.constructNextFrame(this);
	            }
	        }
	        var len = this._children.length;
	        var child;
	        for (var i = 0; i < len; ++i) {
	            child = this._children[i];
	            if (child.isAsset(MovieClip))
	                child.advanceFrame();
	        }
	        this._skipAdvance = false;
	    };
	    // DEBUG CODE:
	    MovieClip.prototype.logHierarchy = function (depth) {
	        if (depth === void 0) { depth = 0; }
	        this.printHierarchyName(depth, this);
	        var len = this._children.length;
	        var child;
	        for (var i = 0; i < len; i++) {
	            child = this._children[i];
	            if (child.isAsset(MovieClip))
	                child.logHierarchy(depth + 1);
	            else
	                this.printHierarchyName(depth + 1, child);
	        }
	    };
	    MovieClip.prototype.printHierarchyName = function (depth, target) {
	        var str = "";
	        for (var i = 0; i < depth; ++i)
	            str += "--";
	        str += " " + target.name + " = " + target.id;
	        console.log(str);
	    };
	    MovieClip.prototype.clear = function () {
	        //clear out potential instances
	        var len = this._potentialInstances.length;
	        for (var i = 0; i < len; i++) {
	            var instance = this._potentialInstances[i];
	            //only dispose instances that are not used in script ie. do not have an instance name
	            if (instance && instance.name == "") {
	                FrameScriptManager_1.default.add_child_to_dispose(instance);
	                delete this._potentialInstances[i];
	            }
	        }
	        _super.prototype.clear.call(this);
	    };
	    MovieClip._movieClips = new Array();
	    MovieClip.assetType = "[asset MovieClip]";
	    return MovieClip;
	}(Sprite_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MovieClip;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(82);
	var Float2Attributes_1 = __webpack_require__(186);
	var Byte4Attributes_1 = __webpack_require__(84);
	var Matrix_1 = __webpack_require__(96);
	var ColorTransform_1 = __webpack_require__(46);
	var Sampler2D_1 = __webpack_require__(157);
	var HierarchicalProperties_1 = __webpack_require__(49);
	var Style_1 = __webpack_require__(155);
	var TextFieldType_1 = __webpack_require__(282);
	var Sprite_1 = __webpack_require__(73);
	var TriangleElements_1 = __webpack_require__(192);
	/**
	 * The TextField class is used to create display objects for text display and
	 * input. <ph outputclass="flexonly">You can use the TextField class to
	 * perform low-level text rendering. However, in Flex, you typically use the
	 * Label, Text, TextArea, and TextInput controls to process text. <ph
	 * outputclass="flashonly">You can give a text field an instance name in the
	 * Property inspector and use the methods and properties of the TextField
	 * class to manipulate it with ActionScript. TextField instance names are
	 * displayed in the Movie Explorer and in the Insert Target Path dialog box in
	 * the Actions panel.
	 *
	 * <p>To create a text field dynamically, use the <code>TextField()</code>
	 * constructor.</p>
	 *
	 * <p>The methods of the TextField class let you set, select, and manipulate
	 * text in a dynamic or input text field that you create during authoring or
	 * at runtime. </p>
	 *
	 * <p>ActionScript provides several ways to format your text at runtime. The
	 * TextFormat class lets you set character and paragraph formatting for
	 * TextField objects. You can apply Cascading Style Sheets(CSS) styles to
	 * text fields by using the <code>TextField.styleSheet</code> property and the
	 * StyleSheet class. You can use CSS to style built-in HTML tags, define new
	 * formatting tags, or apply styles. You can assign HTML formatted text, which
	 * optionally uses CSS styles, directly to a text field. HTML text that you
	 * assign to a text field can contain embedded media(movie clips, SWF files,
	 * GIF files, PNG files, and JPEG files). The text wraps around the embedded
	 * media in the same way that a web browser wraps text around media embedded
	 * in an HTML document. </p>
	 *
	 * <p>Flash Player supports a subset of HTML tags that you can use to format
	 * text. See the list of supported HTML tags in the description of the
	 * <code>htmlText</code> property.</p>
	 *
	 * @event change                    Dispatched after a control value is
	 *                                  modified, unlike the
	 *                                  <code>textInput</code> event, which is
	 *                                  dispatched before the value is modified.
	 *                                  Unlike the W3C DOM Event Model version of
	 *                                  the <code>change</code> event, which
	 *                                  dispatches the event only after the
	 *                                  control loses focus, the ActionScript 3.0
	 *                                  version of the <code>change</code> event
	 *                                  is dispatched any time the control
	 *                                  changes. For example, if a user types text
	 *                                  into a text field, a <code>change</code>
	 *                                  event is dispatched after every keystroke.
	 * @event link                      Dispatched when a user clicks a hyperlink
	 *                                  in an HTML-enabled text field, where the
	 *                                  URL begins with "event:". The remainder of
	 *                                  the URL after "event:" is placed in the
	 *                                  text property of the LINK event.
	 *
	 *                                  <p><b>Note:</b> The default behavior,
	 *                                  adding the text to the text field, occurs
	 *                                  only when Flash Player generates the
	 *                                  event, which in this case happens when a
	 *                                  user attempts to input text. You cannot
	 *                                  put text into a text field by sending it
	 *                                  <code>textInput</code> events.</p>
	 * @event scroll                    Dispatched by a TextField object
	 *                                  <i>after</i> the user scrolls.
	 * @event textInput                 Flash Player dispatches the
	 *                                  <code>textInput</code> event when a user
	 *                                  enters one or more characters of text.
	 *                                  Various text input methods can generate
	 *                                  this event, including standard keyboards,
	 *                                  input method editors(IMEs), voice or
	 *                                  speech recognition systems, and even the
	 *                                  act of pasting plain text with no
	 *                                  formatting or style information.
	 * @event textInteractionModeChange Flash Player dispatches the
	 *                                  <code>textInteractionModeChange</code>
	 *                                  event when a user changes the interaction
	 *                                  mode of a text field. for example on
	 *                                  Android, one can toggle from NORMAL mode
	 *                                  to SELECTION mode using context menu
	 *                                  options
	 */
	var TextField = (function (_super) {
	    __extends(TextField, _super);
	    /**
	     * Creates a new TextField instance. After you create the TextField instance,
	     * call the <code>addChild()</code> or <code>addChildAt()</code> method of
	     * the parent DisplayObjectContainer object to add the TextField instance to
	     * the display list.
	     *
	     * <p>The default size for a text field is 100 x 100 pixels.</p>
	     */
	    function TextField() {
	        _super.call(this);
	        this._text = "";
	        this.type = TextFieldType_1.default.STATIC;
	    }
	    Object.defineProperty(TextField.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return TextField.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "bottomScrollV", {
	        /**
	         * An integer(1-based index) that indicates the bottommost line that is
	         * currently visible in the specified text field. Think of the text field as
	         * a window onto a block of text. The <code>scrollV</code> property is the
	         * 1-based index of the topmost visible line in the window.
	         *
	         * <p>All the text between the lines indicated by <code>scrollV</code> and
	         * <code>bottomScrollV</code> is currently visible in the text field.</p>
	         */
	        get: function () {
	            return this._bottomScrollV;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "caretIndex", {
	        /**
	         * The index of the insertion point(caret) position. If no insertion point
	         * is displayed, the value is the position the insertion point would be if
	         * you restored focus to the field(typically where the insertion point last
	         * was, or 0 if the field has not had focus).
	         *
	         * <p>Selection span indexes are zero-based(for example, the first position
	         * is 0, the second position is 1, and so on).</p>
	         */
	        get: function () {
	            return this._caretIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "length", {
	        /**
	         * The number of characters in a text field. A character such as tab
	         * (<code>\t</code>) counts as one character.
	         */
	        get: function () {
	            return this._length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * The maximum value of <code>scrollH</code>.
	     */
	    TextField.prototype.maxScrollH = function () {
	        return this._maxScrollH;
	    };
	    /**
	     * The maximum value of <code>scrollV</code>.
	     */
	    TextField.prototype.maxScrollV = function () {
	        return this._maxScrollV;
	    };
	    Object.defineProperty(TextField.prototype, "numLines", {
	        /**
	         * Defines the number of text lines in a multiline text field. If
	         * <code>wordWrap</code> property is set to <code>true</code>, the number of
	         * lines increases when text wraps.
	         */
	        get: function () {
	            return this._numLines;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "selectionBeginIndex", {
	        /**
	         * The zero-based character index value of the first character in the current
	         * selection. For example, the first character is 0, the second character is
	         * 1, and so on. If no text is selected, this property is the value of
	         * <code>caretIndex</code>.
	         */
	        get: function () {
	            return this._selectionBeginIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "selectionEndIndex", {
	        /**
	         * The zero-based character index value of the last character in the current
	         * selection. For example, the first character is 0, the second character is
	         * 1, and so on. If no text is selected, this property is the value of
	         * <code>caretIndex</code>.
	         */
	        get: function () {
	            return this._selectionEndIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "text", {
	        /**
	         * A string that is the current text in the text field. Lines are separated
	         * by the carriage return character(<code>'\r'</code>, ASCII 13). This
	         * property contains unformatted text in the text field, without HTML tags.
	         *
	         * <p>To get the text in HTML form, use the <code>htmlText</code>
	         * property.</p>
	         */
	        get: function () {
	            return this._text;
	        },
	        set: function (value) {
	            value = value.toString();
	            if (this._text == value)
	                return;
	            this._text = value;
	            this._textGraphicsDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textFormat", {
	        get: function () {
	            return this._textFormat;
	        },
	        set: function (value) {
	            if (this._textFormat == value)
	                return;
	            this._textFormat = value;
	            this._textGraphicsDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "graphics", {
	        /**
	         * The graphics used by the sprite that provides it with its shape.
	         */
	        get: function () {
	            if (this._textGraphicsDirty)
	                this.reConstruct();
	            return this._graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textColor", {
	        get: function () {
	            return this._textColor;
	        },
	        set: function (value) {
	            this._textColor = value;
	            if (!this.transform.colorTransform)
	                this.transform.colorTransform = new ColorTransform_1.default();
	            this.transform.colorTransform.color = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.COLOR_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textInteractionMode", {
	        /**
	         * The interaction mode property, Default value is
	         * TextInteractionMode.NORMAL. On mobile platforms, the normal mode implies
	         * that the text can be scrolled but not selected. One can switch to the
	         * selectable mode through the in-built context menu on the text field. On
	         * Desktop, the normal mode implies that the text is in scrollable as well as
	         * selection mode.
	         */
	        get: function () {
	            return this._textInteractionMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textWidth", {
	        /**
	         * The width of the text in pixels.
	         */
	        get: function () {
	            return this._textWidth;
	        },
	        set: function (value) {
	            this._textWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textHeight", {
	        /**
	         * The width of the text in pixels.
	         */
	        get: function () {
	            return this._textHeight;
	        },
	        set: function (value) {
	            this._textHeight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "isEntity", {
	        /**
	         *
	         */
	        get: function () {
	            return true; //TODO do this better
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextField.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        if (this._textElements)
	            this._textElements.clear();
	    };
	    /**
	     * @inheritDoc
	     */
	    TextField.prototype.dispose = function () {
	        this.disposeValues();
	        TextField._textFields.push(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    TextField.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._textFormat = null;
	        this._textGraphic = null;
	        if (this._textElements) {
	            this._textElements.dispose();
	            this._textElements = null;
	        }
	    };
	    /**
	     * Reconstructs the Graphics for this Text-field.
	     */
	    TextField.prototype.reConstruct = function () {
	        this._textGraphicsDirty = false;
	        if (this._textFormat == null)
	            return;
	        if (this._textGraphic) {
	            this._textGraphic.dispose();
	            this._textGraphic = null;
	            this._textElements.clear();
	            this._textElements.dispose();
	            this._textElements = null;
	        }
	        if (this._text == "")
	            return;
	        var numVertices = 0;
	        var elements;
	        var char_scale = this._textFormat.size / this._textFormat.font_table.get_font_em_size();
	        var y_offset = 0;
	        var prev_char = null;
	        var j = 0;
	        var k = 0;
	        var whitespace_width = (this._textFormat.font_table.get_whitespace_width() * char_scale) + this._textFormat.letterSpacing;
	        var textlines = this.text.toString().split("\\n");
	        var final_lines_chars = [];
	        var final_lines_char_scale = [];
	        var final_lines_width = [];
	        var final_lines_justify_bool = [];
	        var final_lines_justify = [];
	        var maxlineWidth = this.textWidth - (4 + this._textFormat.leftMargin + this._textFormat.rightMargin + this._textFormat.indent);
	        for (var tl = 0; tl < textlines.length; tl++) {
	            final_lines_chars.push([]);
	            final_lines_char_scale.push([]);
	            final_lines_width.push(0);
	            final_lines_justify.push(0);
	            final_lines_justify_bool.push(false);
	            var words = textlines[tl].split(" ");
	            for (var i = 0; i < words.length; i++) {
	                var word_width = 0;
	                var word_chars = [];
	                var word_chars_scale = [];
	                var c_cnt = 0;
	                for (var w = 0; w < words[i].length; w++) {
	                    char_scale = this._textFormat.size / this._textFormat.font_table.get_font_em_size();
	                    var this_char = this._textFormat.font_table.getChar(words[i].charCodeAt(w).toString());
	                    if (this_char == null) {
	                        if (this._textFormat.fallback_font_table) {
	                            char_scale = this._textFormat.size / this._textFormat.fallback_font_table.get_font_em_size();
	                            this_char = this._textFormat.fallback_font_table.getChar(words[i].charCodeAt(w).toString());
	                        }
	                    }
	                    if (this_char != null) {
	                        elements = this_char.elements;
	                        if (elements != null) {
	                            numVertices += elements.numVertices;
	                            // find kerning value that has been set for this char_code on previous char (if non exists, kerning_value will stay 0)
	                            var kerning_value = 0;
	                            if (prev_char != null) {
	                                for (var k = 0; k < prev_char.kerningCharCodes.length; k++) {
	                                    if (prev_char.kerningCharCodes[k] == words[i].charCodeAt(w)) {
	                                        kerning_value = prev_char.kerningValues[k];
	                                        break;
	                                    }
	                                }
	                            }
	                            word_width += ((2 + this_char.char_width + kerning_value) * char_scale) + this._textFormat.letterSpacing;
	                        }
	                        else {
	                            // if no char-elements was found, we insert a "space"
	                            word_width += whitespace_width;
	                        }
	                    }
	                    else {
	                        // if no char-elements was found, we insert a "space"
	                        //x_offset += this._textFormat.font_table.get_font_em_size() * char_scale;
	                        word_width += whitespace_width;
	                    }
	                    word_chars_scale[c_cnt] = char_scale;
	                    word_chars[c_cnt++] = this_char;
	                }
	                if (((final_lines_width[final_lines_width.length - 1] + word_width) <= maxlineWidth) || (final_lines_chars[final_lines_chars.length - 1].length == 0)) {
	                    // if line can hold this word without breaking the bounds, we can just add all chars
	                    for (var fw = 0; fw < word_chars_scale.length; fw++) {
	                        final_lines_chars[final_lines_chars.length - 1].push(word_chars[fw]);
	                        final_lines_char_scale[final_lines_char_scale.length - 1].push(word_chars_scale[fw]);
	                    }
	                    final_lines_width[final_lines_width.length - 1] += word_width;
	                }
	                else {
	                    // word does not fit
	                    // todo respect autowrapping properties.
	                    // right now we just pretend everything has autowrapping and multiline
	                    if (final_lines_chars[final_lines_chars.length - 1][final_lines_chars[final_lines_chars.length - 1].length - 1] == null) {
	                        final_lines_chars[final_lines_chars.length - 1].pop();
	                        final_lines_char_scale[final_lines_char_scale.length - 1].pop();
	                        final_lines_width[final_lines_width.length - 1] -= whitespace_width;
	                        final_lines_justify[final_lines_justify.length - 1] -= 1;
	                    }
	                    final_lines_justify_bool[final_lines_justify_bool.length - 1] = true;
	                    final_lines_chars.push([]);
	                    final_lines_char_scale.push([]);
	                    final_lines_width.push(0);
	                    final_lines_justify.push(0);
	                    final_lines_justify_bool.push(false);
	                    for (var fw = 0; fw < word_chars_scale.length; fw++) {
	                        final_lines_chars[final_lines_chars.length - 1].push(word_chars[fw]);
	                        final_lines_char_scale[final_lines_char_scale.length - 1].push(word_chars_scale[fw]);
	                    }
	                    final_lines_width[final_lines_width.length - 1] = word_width;
	                }
	                if (i < (words.length - 1)) {
	                    if ((final_lines_width[final_lines_width.length - 1]) <= maxlineWidth) {
	                        final_lines_chars[final_lines_chars.length - 1].push(null);
	                        final_lines_char_scale[final_lines_char_scale.length - 1].push(char_scale);
	                        final_lines_width[final_lines_width.length - 1] += whitespace_width;
	                        final_lines_justify[final_lines_justify.length - 1] += 1;
	                    }
	                }
	            }
	        }
	        y_offset = 2 + (this._textFormat.font_table.ascent - this._textFormat.font_table.get_font_em_size()) * char_scale;
	        var vertices = new Float32Array(numVertices * 3);
	        for (var i = 0; i < final_lines_chars.length; i++) {
	            var x_offset = 2 + this._textFormat.leftMargin + this._textFormat.indent;
	            var justify_addion = 0;
	            if (this._textFormat.align == "center") {
	                x_offset = 2 + this._textFormat.leftMargin + this._textFormat.indent + (maxlineWidth - final_lines_width[i]) / 2;
	            }
	            else if (this._textFormat.align == "justify") {
	                if (final_lines_justify_bool[i]) {
	                    justify_addion = ((maxlineWidth) - final_lines_width[i]) / final_lines_justify[i];
	                }
	            }
	            else if (this._textFormat.align == "right") {
	                x_offset = (this._textWidth - final_lines_width[i]) - (2 + this._textFormat.rightMargin);
	            }
	            //console.log("this._textFormat.align="+this._textFormat.align);
	            //console.log("this._width="+this._width);
	            for (var t = 0; t < final_lines_chars[i].length; t++) {
	                var this_char = final_lines_chars[i][t];
	                char_scale = final_lines_char_scale[i][t];
	                if (this_char != null) {
	                    elements = this_char.elements;
	                    if (elements != null) {
	                        var buffer = new Float32Array(elements.concatenatedBuffer.buffer);
	                        for (var v = 0; v < elements.numVertices; v++) {
	                            vertices[j++] = buffer[v * 3] * char_scale + x_offset;
	                            vertices[j++] = buffer[v * 3 + 1] * char_scale + y_offset;
	                            vertices[j++] = buffer[v * 3 + 2];
	                        }
	                        // find kerning value that has been set for this char_code on previous char (if non exists, kerning_value will stay 0)
	                        var kerning_value = 0;
	                        if (prev_char != null) {
	                            for (var k = 0; k < prev_char.kerningCharCodes.length; k++) {
	                                if (prev_char.kerningCharCodes[k] == this._text.charCodeAt(i)) {
	                                    kerning_value = prev_char.kerningValues[k];
	                                    break;
	                                }
	                            }
	                        }
	                        x_offset += ((this_char.char_width + kerning_value) * char_scale) + this._textFormat.letterSpacing;
	                    }
	                    else {
	                        // if no char-elements was found, we insert a "space"
	                        x_offset += whitespace_width + justify_addion;
	                    }
	                }
	                else {
	                    x_offset += whitespace_width + justify_addion;
	                }
	            }
	            // hack for multiline textfield in icycle.
	            y_offset += (this._textFormat.font_table.ascent + this._textFormat.font_table.descent) * char_scale;
	            //y_offset+=(this._textFormat.font_table.get_font_em_size()-this._textFormat.font_table.descent)*char_scale;
	            y_offset += this._textFormat.leading;
	        }
	        var attributesView = new AttributesView_1.default(Float32Array, 3);
	        attributesView.set(vertices);
	        var vertexBuffer = attributesView.buffer;
	        attributesView.dispose();
	        this._textElements = new TriangleElements_1.default(vertexBuffer);
	        this._textElements.setPositions(new Float2Attributes_1.default(vertexBuffer));
	        this._textElements.setCustomAttributes("curves", new Byte4Attributes_1.default(vertexBuffer, false));
	        this._textGraphic = this._graphics.addGraphic(this._textElements);
	        this.material = this._textFormat.material;
	        var sampler = new Sampler2D_1.default();
	        this.style = new Style_1.default();
	        this.style.addSamplerAt(sampler, this.material.getTextureAt(0));
	        this.style.uvMatrix = new Matrix_1.default(0, 0, 0, 0, this._textFormat.uv_values[0], this._textFormat.uv_values[1]);
	        this.material.animateUVs = true;
	    };
	    /**
	     * Appends the string specified by the <code>newText</code> parameter to the
	     * end of the text of the text field. This method is more efficient than an
	     * addition assignment(<code>+=</code>) on a <code>text</code> property
	     * (such as <code>someTextField.text += moreText</code>), particularly for a
	     * text field that contains a significant amount of content.
	     *
	     * @param newText The string to append to the existing text.
	     */
	    TextField.prototype.appendText = function (newText) {
	        this._text += newText;
	    };
	    /**
	     * *tells the Textfield that a paragraph is defined completly.
	     * e.g. the textfield will start a new line for future added text.
	     */
	    TextField.prototype.closeParagraph = function () {
	        //TODO
	    };
	    /**
	     * Returns a rectangle that is the bounding box of the character.
	     *
	     * @param charIndex The zero-based index value for the character(for
	     *                  example, the first position is 0, the second position is
	     *                  1, and so on).
	     * @return A rectangle with <code>x</code> and <code>y</code> minimum and
	     *         maximum values defining the bounding box of the character.
	     */
	    TextField.prototype.getCharBoundaries = function (charIndex) {
	        return this._charBoundaries;
	    };
	    /**
	     * Returns the zero-based index value of the character at the point specified
	     * by the <code>x</code> and <code>y</code> parameters.
	     *
	     * @param x The <i>x</i> coordinate of the character.
	     * @param y The <i>y</i> coordinate of the character.
	     * @return The zero-based index value of the character(for example, the
	     *         first position is 0, the second position is 1, and so on). Returns
	     *         -1 if the point is not over any character.
	     */
	    TextField.prototype.getCharIndexAtPoint = function (x, y) {
	        return this._charIndexAtPoint;
	    };
	    /**
	     * Given a character index, returns the index of the first character in the
	     * same paragraph.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return The zero-based index value of the first character in the same
	     *         paragraph.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getFirstCharInParagraph = function (charIndex /*int*/) {
	        return this._firstCharInParagraph;
	    };
	    /**
	     * Returns a DisplayObject reference for the given <code>id</code>, for an
	     * image or SWF file that has been added to an HTML-formatted text field by
	     * using an <code><img></code> tag. The <code><img></code> tag is in the
	     * following format:
	     *
	     * <p><pre xml:space="preserve"><code> <img src = 'filename.jpg' id =
	     * 'instanceName' ></code></pre></p>
	     *
	     * @param id The <code>id</code> to match(in the <code>id</code> attribute
	     *           of the <code><img></code> tag).
	     * @return The display object corresponding to the image or SWF file with the
	     *         matching <code>id</code> attribute in the <code><img></code> tag
	     *         of the text field. For media loaded from an external source, this
	     *         object is a Loader object, and, once loaded, the media object is a
	     *         child of that Loader object. For media embedded in the SWF file,
	     *         it is the loaded object. If no <code><img></code> tag with the
	     *         matching <code>id</code> exists, the method returns
	     *         <code>null</code>.
	     */
	    TextField.prototype.getImageReference = function (id) {
	        return this._imageReference;
	    };
	    /**
	     * Returns the zero-based index value of the line at the point specified by
	     * the <code>x</code> and <code>y</code> parameters.
	     *
	     * @param x The <i>x</i> coordinate of the line.
	     * @param y The <i>y</i> coordinate of the line.
	     * @return The zero-based index value of the line(for example, the first
	     *         line is 0, the second line is 1, and so on). Returns -1 if the
	     *         point is not over any line.
	     */
	    TextField.prototype.getLineIndexAtPoint = function (x, y) {
	        return this._lineIndexAtPoint;
	    };
	    /**
	     * Returns the zero-based index value of the line containing the character
	     * specified by the <code>charIndex</code> parameter.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return The zero-based index value of the line.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getLineIndexOfChar = function (charIndex /*int*/) {
	        return this._lineIndexOfChar;
	    };
	    /**
	     * Returns the number of characters in a specific text line.
	     *
	     * @param lineIndex The line number for which you want the length.
	     * @return The number of characters in the line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineLength = function (lineIndex /*int*/) {
	        return this._lineLength;
	    };
	    /**
	     * Returns metrics information about a given text line.
	     *
	     * @param lineIndex The line number for which you want metrics information.
	     * @return A TextLineMetrics object.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineMetrics = function (lineIndex /*int*/) {
	        return this._lineMetrics;
	    };
	    /**
	     * Returns the character index of the first character in the line that the
	     * <code>lineIndex</code> parameter specifies.
	     *
	     * @param lineIndex The zero-based index value of the line(for example, the
	     *                  first line is 0, the second line is 1, and so on).
	     * @return The zero-based index value of the first character in the line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineOffset = function (lineIndex /*int*/) {
	        return this._lineOffset;
	    };
	    /**
	     * Returns the text of the line specified by the <code>lineIndex</code>
	     * parameter.
	     *
	     * @param lineIndex The zero-based index value of the line(for example, the
	     *                  first line is 0, the second line is 1, and so on).
	     * @return The text string contained in the specified line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineText = function (lineIndex /*int*/) {
	        return this._lineText;
	    };
	    /**
	     * Given a character index, returns the length of the paragraph containing
	     * the given character. The length is relative to the first character in the
	     * paragraph(as returned by <code>getFirstCharInParagraph()</code>), not to
	     * the character index passed in.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return Returns the number of characters in the paragraph.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getParagraphLength = function (charIndex /*int*/) {
	        return this._paragraphLength;
	    };
	    /**
	     * Returns a TextFormat object that contains formatting information for the
	     * range of text that the <code>beginIndex</code> and <code>endIndex</code>
	     * parameters specify. Only properties that are common to the entire text
	     * specified are set in the resulting TextFormat object. Any property that is
	     * <i>mixed</i>, meaning that it has different values at different points in
	     * the text, has a value of <code>null</code>.
	     *
	     * <p>If you do not specify values for these parameters, this method is
	     * applied to all the text in the text field. </p>
	     *
	     * <p>The following table describes three possible usages:</p>
	     *
	     * @return The TextFormat object that represents the formatting properties
	     *         for the specified text.
	     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	     *                    specified is out of range.
	     */
	    TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = -1; }
	        if (endIndex === void 0) { endIndex = -1; }
	        return this._textFormat;
	    };
	    /**
	     * Replaces the current selection with the contents of the <code>value</code>
	     * parameter. The text is inserted at the position of the current selection,
	     * using the current default character format and default paragraph format.
	     * The text is not treated as HTML.
	     *
	     * <p>You can use the <code>replaceSelectedText()</code> method to insert and
	     * delete text without disrupting the character and paragraph formatting of
	     * the rest of the text.</p>
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * @param value The string to replace the currently selected text.
	     * @throws Error This method cannot be used on a text field with a style
	     *               sheet.
	     */
	    TextField.prototype.replaceSelectedText = function (value) {
	    };
	    /**
	     * Replaces the range of characters that the <code>beginIndex</code> and
	     * <code>endIndex</code> parameters specify with the contents of the
	     * <code>newText</code> parameter. As designed, the text from
	     * <code>beginIndex</code> to <code>endIndex-1</code> is replaced.
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * @param beginIndex The zero-based index value for the start position of the
	     *                   replacement range.
	     * @param endIndex   The zero-based index position of the first character
	     *                   after the desired text span.
	     * @param newText    The text to use to replace the specified range of
	     *                   characters.
	     * @throws Error This method cannot be used on a text field with a style
	     *               sheet.
	     */
	    TextField.prototype.replaceText = function (beginIndex /*int*/, endIndex /*int*/, newText) {
	    };
	    /**
	     * Sets as selected the text designated by the index values of the first and
	     * last characters, which are specified with the <code>beginIndex</code> and
	     * <code>endIndex</code> parameters. If the two parameter values are the
	     * same, this method sets the insertion point, as if you set the
	     * <code>caretIndex</code> property.
	     *
	     * @param beginIndex The zero-based index value of the first character in the
	     *                   selection(for example, the first character is 0, the
	     *                   second character is 1, and so on).
	     * @param endIndex   The zero-based index value of the last character in the
	     *                   selection.
	     */
	    TextField.prototype.setSelection = function (beginIndex /*int*/, endIndex /*int*/) {
	    };
	    /**
	     * Applies the text formatting that the <code>format</code> parameter
	     * specifies to the specified text in a text field. The value of
	     * <code>format</code> must be a TextFormat object that specifies the desired
	     * text formatting changes. Only the non-null properties of
	     * <code>format</code> are applied to the text field. Any property of
	     * <code>format</code> that is set to <code>null</code> is not applied. By
	     * default, all of the properties of a newly created TextFormat object are
	     * set to <code>null</code>.
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * <p>The <code>setTextFormat()</code> method changes the text formatting
	     * applied to a range of characters or to the entire body of text in a text
	     * field. To apply the properties of format to all text in the text field, do
	     * not specify values for <code>beginIndex</code> and <code>endIndex</code>.
	     * To apply the properties of the format to a range of text, specify values
	     * for the <code>beginIndex</code> and the <code>endIndex</code> parameters.
	     * You can use the <code>length</code> property to determine the index
	     * values.</p>
	     *
	     * <p>The two types of formatting information in a TextFormat object are
	     * character level formatting and paragraph level formatting. Each character
	     * in a text field can have its own character formatting settings, such as
	     * font name, font size, bold, and italic.</p>
	     *
	     * <p>For paragraphs, the first character of the paragraph is examined for
	     * the paragraph formatting settings for the entire paragraph. Examples of
	     * paragraph formatting settings are left margin, right margin, and
	     * indentation.</p>
	     *
	     * <p>Any text inserted manually by the user, or replaced by the
	     * <code>replaceSelectedText()</code> method, receives the default text field
	     * formatting for new text, and not the formatting specified for the text
	     * insertion point. To set the default formatting for new text, use
	     * <code>defaultTextFormat</code>.</p>
	     *
	     * @param format A TextFormat object that contains character and paragraph
	     *               formatting information.
	     * @throws Error      This method cannot be used on a text field with a style
	     *                    sheet.
	     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	     *                    specified is out of range.
	     */
	    TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = -1; }
	        if (endIndex === void 0) { endIndex = -1; }
	    };
	    /**
	     * Returns true if an embedded font is available with the specified
	     * <code>fontName</code> and <code>fontStyle</code> where
	     * <code>Font.fontType</code> is <code>flash.text.FontType.EMBEDDED</code>.
	     * Starting with Flash Player 10, two kinds of embedded fonts can appear in a
	     * SWF file. Normal embedded fonts are only used with TextField objects. CFF
	     * embedded fonts are only used with the flash.text.engine classes. The two
	     * types are distinguished by the <code>fontType</code> property of the
	     * <code>Font</code> class, as returned by the <code>enumerateFonts()</code>
	     * function.
	     *
	     * <p>TextField cannot use a font of type <code>EMBEDDED_CFF</code>. If
	     * <code>embedFonts</code> is set to <code>true</code> and the only font
	     * available at run time with the specified name and style is of type
	     * <code>EMBEDDED_CFF</code>, Flash Player fails to render the text, as if no
	     * embedded font were available with the specified name and style.</p>
	     *
	     * <p>If both <code>EMBEDDED</code> and <code>EMBEDDED_CFF</code> fonts are
	     * available with the same name and style, the <code>EMBEDDED</code> font is
	     * selected and text renders with the <code>EMBEDDED</code> font.</p>
	     *
	     * @param fontName  The name of the embedded font to check.
	     * @param fontStyle Specifies the font style to check. Use
	     *                  <code>flash.text.FontStyle</code>
	     * @return <code>true</code> if a compatible embedded font is available,
	     *         otherwise <code>false</code>.
	     * @throws ArgumentError The <code>fontStyle</code> specified is not a member
	     *                       of <code>flash.text.FontStyle</code>.
	     */
	    TextField.isFontCompatible = function (fontName, fontStyle) {
	        return false;
	    };
	    TextField.prototype.clone = function () {
	        var newInstance = (TextField._textFields.length) ? TextField._textFields.pop() : new TextField();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    TextField.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.textWidth = this._textWidth;
	        newInstance.textHeight = this._textHeight;
	        newInstance.textFormat = this._textFormat;
	        //newInstance.textColor = this._textColor;
	        newInstance.text = this._text;
	    };
	    TextField._textFields = new Array();
	    TextField.assetType = "[asset TextField]";
	    return TextField;
	}(Sprite_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextField;


/***/ },
/* 282 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFieldType class is an enumeration of constant values used in setting the
	 * <code>type</code> property of the TextField class.
	 *
	 * @see away.entities.TextField#type
	 */
	var TextFieldType = (function () {
	    function TextFieldType() {
	    }
	    /**
	     * Used to specify a <code>dynamic</code> TextField.
	     */
	    TextFieldType.DYNAMIC = "dynamic";
	    /**
	     * Used to specify an <code>input</code> TextField.
	     */
	    TextFieldType.INPUT = "input";
	    /**
	     * Used to specify an <code>static</code> TextField.
	     */
	    TextFieldType.STATIC = "input";
	    return TextFieldType;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextFieldType;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var HierarchicalProperties_1 = __webpack_require__(49);
	var ColorTransform_1 = __webpack_require__(46);
	var FrameScriptManager_1 = __webpack_require__(72);
	var Timeline = (function () {
	    function Timeline() {
	        this._functions = [];
	        this._update_indices = [];
	        this.numKeyFrames = 0;
	        this.keyframe_indices = [];
	        this._potentialPrototypes = [];
	        this._labels = {};
	        this._framescripts = {};
	        this._framescripts_translated = {};
	        //cache functions
	        this._functions[1] = this.update_mtx_all;
	        this._functions[2] = this.update_colortransform;
	        this._functions[3] = this.update_masks;
	        this._functions[4] = this.update_name;
	        this._functions[5] = this.update_button_name;
	        this._functions[6] = this.update_visibility;
	        this._functions[11] = this.update_mtx_scale_rot;
	        this._functions[12] = this.update_mtx_pos;
	        this._functions[200] = this.enable_maskmode;
	        this._functions[201] = this.remove_masks;
	    }
	    Timeline.prototype.init = function () {
	        if ((this.frame_command_indices == null) || (this.frame_recipe == null) || (this.keyframe_durations == null))
	            return;
	        this.keyframe_firstframes = [];
	        this.keyframe_constructframes = [];
	        var frame_cnt = 0;
	        var ic = 0;
	        var ic2 = 0;
	        var keyframe_cnt = 0;
	        var last_construct_frame = 0;
	        for (ic = 0; ic < this.numKeyFrames; ic++) {
	            var duration = this.keyframe_durations[(ic)];
	            if (this.frame_recipe[ic] & 1)
	                last_construct_frame = keyframe_cnt;
	            this.keyframe_firstframes[keyframe_cnt] = frame_cnt;
	            this.keyframe_constructframes[keyframe_cnt++] = last_construct_frame;
	            for (ic2 = 0; ic2 < duration; ic2++)
	                this.keyframe_indices[frame_cnt++] = ic;
	        }
	    };
	    Timeline.prototype.get_framescript = function (keyframe_index) {
	        if (this._framescripts[keyframe_index] == null)
	            return "";
	        if (typeof this._framescripts[keyframe_index] == "string")
	            return this._framescripts[keyframe_index];
	        else {
	            throw new Error("Framescript is already translated to Function!!!");
	        }
	    };
	    Timeline.prototype.add_framescript = function (value, keyframe_index) {
	        if (FrameScriptManager_1.default.frameScriptDebug) {
	            // if we are in debug mode, we try to extract the function name from the first line of framescript code,
	            // and check if this function is available on the object that is set as frameScriptDebug
	            // try to get the functions name (it should be the first line as comment)
	            var functionname = value.split(/[\r\n]+/g)[0].split("//")[1];
	            if (FrameScriptManager_1.default.frameScriptDebug[functionname]) {
	                this._framescripts[keyframe_index] = FrameScriptManager_1.default.frameScriptDebug[functionname];
	                this._framescripts_translated[keyframe_index] = true;
	                return;
	            }
	            else {
	                throw new Error("Framescript could not be found on FrameScriptManager.frameScriptDebug.\n the Object set as FrameScriptmanager.frameScriptDebug should contain a function with the name '" + functionname + "' !!!");
	            }
	        }
	        this._framescripts[keyframe_index] = value;
	    };
	    Timeline.prototype.regexIndexOf = function (str, regex, startpos) {
	        var indexOf = str.substring(startpos || 0).search(regex);
	        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
	    };
	    Timeline.prototype.add_script_for_postcontruct = function (target_mc, keyframe_idx, scriptPass1) {
	        if (scriptPass1 === void 0) { scriptPass1 = false; }
	        if (this._framescripts[keyframe_idx] != null) {
	            if (this._framescripts_translated[keyframe_idx] == null) {
	                this._framescripts[keyframe_idx] = target_mc.adapter.evalScript(this._framescripts[keyframe_idx]);
	                this._framescripts_translated[keyframe_idx] = true;
	            }
	            if (scriptPass1)
	                FrameScriptManager_1.default.add_script_to_queue(target_mc, this._framescripts[keyframe_idx]);
	            else
	                FrameScriptManager_1.default.add_script_to_queue_pass2(target_mc, this._framescripts[keyframe_idx]);
	        }
	    };
	    Object.defineProperty(Timeline.prototype, "numFrames", {
	        get: function () {
	            return this.keyframe_indices.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timeline.prototype.getPotentialChildPrototype = function (id) {
	        return this._potentialPrototypes[id];
	    };
	    Timeline.prototype.getKeyframeIndexForFrameIndex = function (frame_index) {
	        return this.keyframe_indices[frame_index];
	    };
	    Timeline.prototype.getPotentialChildInstance = function (id) {
	        var this_clone = this._potentialPrototypes[id].clone();
	        this_clone.name = "";
	        return this_clone;
	    };
	    Timeline.prototype.registerPotentialChild = function (prototype) {
	        var id = this._potentialPrototypes.length;
	        this._potentialPrototypes[id] = prototype;
	    };
	    Timeline.prototype.jumpToLabel = function (target_mc, label) {
	        var key_frame_index = this._labels[label];
	        if (key_frame_index >= 0)
	            target_mc.currentFrameIndex = this.keyframe_firstframes[key_frame_index];
	    };
	    Timeline.prototype.gotoFrame = function (target_mc, value, skip_script) {
	        if (skip_script === void 0) { skip_script = false; }
	        var current_keyframe_idx = target_mc.constructedKeyFrameIndex;
	        var target_keyframe_idx = this.keyframe_indices[value];
	        if (current_keyframe_idx == target_keyframe_idx)
	            return;
	        if (current_keyframe_idx + 1 == target_keyframe_idx) {
	            this.constructNextFrame(target_mc, !skip_script, true);
	            return;
	        }
	        var break_frame_idx = this.keyframe_constructframes[target_keyframe_idx];
	        //we now have 3 index to keyframes: current_keyframe_idx / target_keyframe_idx / break_frame_idx
	        var jump_forward = (target_keyframe_idx > current_keyframe_idx);
	        var jump_gap = (break_frame_idx > current_keyframe_idx);
	        // in case we jump forward, but not jump a gap, we start at current_keyframe_idx + 1
	        // in case we jump back or we jump a gap, we want to start constructing at BreakFrame
	        var start_construct_idx = (jump_forward && !jump_gap) ? current_keyframe_idx + 1 : break_frame_idx;
	        var i;
	        var k;
	        if (jump_gap)
	            for (i = target_mc.numChildren - 1; i >= 0; i--)
	                if (target_mc._children[i]._depthID < 0)
	                    target_mc.removeChildAt(i);
	        //if we jump back, we want to reset all objects (but not the timelines of the mcs)
	        if (!jump_forward)
	            target_mc.resetSessionIDs();
	        // in other cases, we want to collect the current objects to compare state of targetframe with state of currentframe
	        var depth_sessionIDs = target_mc.getSessionIDDepths();
	        //pass1: only apply add/remove commands into depth_sessionIDs.
	        this.pass1(start_construct_idx, target_keyframe_idx, depth_sessionIDs);
	        // check what childs are alive on both frames.
	        // childs that are not alive anymore get removed and unregistered
	        // childs that are alive on both frames have their properties reset if we are jumping back
	        var child;
	        for (i = target_mc.numChildren - 1; i >= 0; i--) {
	            child = target_mc._children[i];
	            if (child._depthID < 0) {
	                if (depth_sessionIDs[child._depthID] != child._sessionID) {
	                    target_mc.removeChildAt(i);
	                }
	                else if (!jump_forward) {
	                    if (child.adapter) {
	                        if (!child.adapter.isBlockedByScript()) {
	                            child.transform.clearMatrix3D();
	                            child.transform.clearColorTransform();
	                            //this.name="";
	                            child.masks = null;
	                            child.maskMode = false;
	                        }
	                        if (!child.adapter.isVisibilityByScript()) {
	                            child.visible = true;
	                        }
	                    }
	                }
	            }
	        }
	        // now we need to addchild the objects that were added before targetframe first
	        // than we can add the script of the targetframe
	        // than we can addchild objects added on targetframe
	        for (var key in depth_sessionIDs) {
	            child = target_mc.getPotentialChildInstance(this.add_child_stream[depth_sessionIDs[key] * 2]);
	            if (child._sessionID == -1)
	                target_mc._addTimelineChildAt(child, Number(key), depth_sessionIDs[key]);
	        }
	        if (!skip_script && this.keyframe_firstframes[target_keyframe_idx] == value)
	            this.add_script_for_postcontruct(target_mc, target_keyframe_idx, true);
	        //pass2: apply update commands for objects on stage (only if they are not blocked by script)
	        this.pass2(target_mc);
	        target_mc.constructedKeyFrameIndex = target_keyframe_idx;
	    };
	    Timeline.prototype.pass1 = function (start_construct_idx, target_keyframe_idx, depth_sessionIDs) {
	        var i;
	        var k;
	        this._update_indices.length = 0; // store a list of updatecommand_indices, so we dont have to read frame_recipe again
	        var update_cnt = 0;
	        var start_index;
	        var end_index;
	        for (k = start_construct_idx; k <= target_keyframe_idx; k++) {
	            var frame_command_idx = this.frame_command_indices[k];
	            var frame_recipe = this.frame_recipe[k];
	            if (frame_recipe & 2) {
	                // remove childs
	                start_index = this.command_index_stream[frame_command_idx];
	                end_index = start_index + this.command_length_stream[frame_command_idx++];
	                for (i = start_index; i < end_index; i++)
	                    delete depth_sessionIDs[this.remove_child_stream[i] - 16383];
	            }
	            if (frame_recipe & 4) {
	                start_index = this.command_index_stream[frame_command_idx];
	                end_index = start_index + this.command_length_stream[frame_command_idx++];
	                // apply add commands in reversed order to have script exeucted in correct order.
	                // this could be changed in exporter
	                for (i = end_index - 1; i >= start_index; i--)
	                    depth_sessionIDs[this.add_child_stream[i * 2 + 1] - 16383] = i;
	            }
	            if (frame_recipe & 8)
	                this._update_indices[update_cnt++] = frame_command_idx; // execute update command later
	        }
	    };
	    Timeline.prototype.pass2 = function (target_mc) {
	        var k;
	        var len = this._update_indices.length;
	        for (k = 0; k < len; k++)
	            this.update_childs(target_mc, this._update_indices[k]);
	    };
	    Timeline.prototype.constructNextFrame = function (target_mc, queueScript, scriptPass1) {
	        if (queueScript === void 0) { queueScript = true; }
	        if (scriptPass1 === void 0) { scriptPass1 = false; }
	        var frameIndex = target_mc.currentFrameIndex;
	        var new_keyFrameIndex = this.keyframe_indices[frameIndex];
	        if (queueScript && this.keyframe_firstframes[new_keyFrameIndex] == frameIndex)
	            this.add_script_for_postcontruct(target_mc, new_keyFrameIndex, scriptPass1);
	        if (target_mc.constructedKeyFrameIndex != new_keyFrameIndex) {
	            target_mc.constructedKeyFrameIndex = new_keyFrameIndex;
	            var frame_command_idx = this.frame_command_indices[new_keyFrameIndex];
	            var frame_recipe = this.frame_recipe[new_keyFrameIndex];
	            if (frame_recipe & 1) {
	                for (var i = target_mc.numChildren - 1; i >= 0; i--)
	                    if (target_mc._children[i]._depthID < 0)
	                        target_mc.removeChildAt(i);
	            }
	            else if (frame_recipe & 2) {
	                this.remove_childs_continous(target_mc, frame_command_idx++);
	            }
	            if (frame_recipe & 4)
	                this.add_childs_continous(target_mc, frame_command_idx++);
	            if (frame_recipe & 8)
	                this.update_childs(target_mc, frame_command_idx++);
	        }
	    };
	    Timeline.prototype.remove_childs_continous = function (sourceMovieClip, frame_command_idx) {
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        for (var i = start_index; i < end_index; i++)
	            sourceMovieClip.removeChildAt(sourceMovieClip.getDepthIndexInternal(this.remove_child_stream[i] - 16383));
	    };
	    // used to add childs when jumping between frames
	    Timeline.prototype.add_childs_continous = function (sourceMovieClip, frame_command_idx) {
	        // apply add commands in reversed order to have script exeucted in correct order.
	        // this could be changed in exporter
	        var idx;
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        for (var i = end_index - 1; i >= start_index; i--) {
	            idx = i * 2;
	            sourceMovieClip._addTimelineChildAt(sourceMovieClip.getPotentialChildInstance(this.add_child_stream[idx]), this.add_child_stream[idx + 1] - 16383, i);
	        }
	    };
	    Timeline.prototype.update_childs = function (target_mc, frame_command_idx) {
	        var p;
	        var props_start_idx;
	        var props_end_index;
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        var child;
	        for (var i = start_index; i < end_index; i++) {
	            child = target_mc.getChildAtSessionID(this.update_child_stream[i]);
	            if (child) {
	                // check if the child is active + not blocked by script
	                this._blocked = Boolean(child.adapter && child.adapter.isBlockedByScript());
	                props_start_idx = this.update_child_props_indices_stream[i];
	                props_end_index = props_start_idx + this.update_child_props_length_stream[i];
	                for (p = props_start_idx; p < props_end_index; p++)
	                    this._functions[this.property_type_stream[p]].call(this, child, target_mc, this.property_index_stream[p]);
	            }
	        }
	    };
	    Timeline.prototype.update_mtx_all = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 6;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[0] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[1] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[4] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[5] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[12] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[13] = this.properties_stream_f32_mtx_all[i];
	        child.transform.invalidateComponents();
	    };
	    Timeline.prototype.update_colortransform = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 8;
	        var new_ct = child.transform.colorTransform || (child.transform.colorTransform = new ColorTransform_1.default());
	        new_ct.redMultiplier = this.properties_stream_f32_ct[i++];
	        new_ct.greenMultiplier = this.properties_stream_f32_ct[i++];
	        new_ct.blueMultiplier = this.properties_stream_f32_ct[i++];
	        new_ct.alphaMultiplier = this.properties_stream_f32_ct[i++];
	        new_ct.redOffset = this.properties_stream_f32_ct[i++];
	        new_ct.greenOffset = this.properties_stream_f32_ct[i++];
	        new_ct.blueOffset = this.properties_stream_f32_ct[i++];
	        new_ct.alphaOffset = this.properties_stream_f32_ct[i];
	        child.transform.invalidateColorTransform();
	    };
	    Timeline.prototype.update_masks = function (child, target_mc, i) {
	        // an object could have multiple groups of masks, in case a graphic clip was merged into the timeline
	        // this is not implmeented in the runtime yet
	        // for now, a second mask-groupd would overwrite the first one
	        var mask;
	        var masks = new Array();
	        var numMasks = this.properties_stream_int[i++];
	        //mask may not exist if a goto command moves the playhead to a point in the timeline after
	        //one of the masks in a mask array has already been removed. Therefore a check is needed.
	        for (var m = 0; m < numMasks; m++)
	            if ((mask = target_mc.getChildAtSessionID(this.properties_stream_int[i++])))
	                masks.push(mask);
	        child.masks = masks;
	    };
	    Timeline.prototype.update_name = function (child, target_mc, i) {
	        child.name = this.properties_stream_strings[i];
	        target_mc.adapter.registerScriptObject(child);
	    };
	    Timeline.prototype.update_button_name = function (target, sourceMovieClip, i) {
	        target.name = this.properties_stream_strings[i];
	        // todo: creating the buttonlistenrs later should also be done, but for icycle i dont think this will cause problems
	        target.addButtonListeners();
	        sourceMovieClip.adapter.registerScriptObject(target);
	    };
	    Timeline.prototype.update_visibility = function (child, target_mc, i) {
	        if (!child.adapter || !child.adapter.isVisibilityByScript())
	            child.visible = Boolean(i);
	    };
	    Timeline.prototype.update_mtx_scale_rot = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 4;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[0] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[1] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[4] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[5] = this.properties_stream_f32_mtx_scale_rot[i];
	        child.transform.invalidateComponents();
	        child.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.SCENE_TRANSFORM);
	    };
	    Timeline.prototype.update_mtx_pos = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 2;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[12] = this.properties_stream_f32_mtx_pos[i++];
	        new_matrix.rawData[13] = this.properties_stream_f32_mtx_pos[i];
	        child.transform.invalidatePosition();
	    };
	    Timeline.prototype.enable_maskmode = function (child, target_mc, i) {
	        child.maskMode = true;
	    };
	    Timeline.prototype.remove_masks = function (child, target_mc, i) {
	        child.masks = null;
	    };
	    return Timeline;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Timeline;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorTransform_1 = __webpack_require__(46);
	var HierarchicalProperties_1 = __webpack_require__(49);
	var FrameScriptManager_1 = __webpack_require__(72);
	// also contains global AS2 gunctions
	var AS2SymbolAdapter = (function () {
	    function AS2SymbolAdapter(adaptee, view) {
	        this.__quality = "high";
	        this._adaptee = adaptee;
	        this._view = view;
	        this._blockedByScript = false;
	        if (AS2SymbolAdapter.REFERENCE_TIME === -1)
	            AS2SymbolAdapter.REFERENCE_TIME = new Date().getTime();
	    }
	    AS2SymbolAdapter.prototype.isBlockedByScript = function () { return this._blockedByScript; };
	    AS2SymbolAdapter.prototype.isVisibilityByScript = function () { return this._visibilityByScript; };
	    AS2SymbolAdapter.prototype.freeFromScript = function () { this._blockedByScript = false; this._visibilityByScript = false; };
	    AS2SymbolAdapter.prototype.dispose = function () {
	        this._adaptee = null;
	        this._view = null;
	    };
	    AS2SymbolAdapter.prototype.getVersion = function () {
	        return 0;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "adaptee", {
	        get: function () {
	            return this._adaptee;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_height", {
	        get: function () {
	            return this._adaptee.height;
	        },
	        set: function (value) {
	            this._adaptee.height = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_name", {
	        get: function () {
	            return this._adaptee.name;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_rotation", {
	        get: function () {
	            return this._adaptee.rotationZ;
	        },
	        set: function (value) {
	            this._adaptee.rotationZ = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_x", {
	        get: function () {
	            return this._adaptee.x;
	        },
	        set: function (value) {
	            this._adaptee.x = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_xmouse", {
	        get: function () {
	            return this._view.getLocalMouseX(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_y", {
	        get: function () {
	            return this._adaptee.y;
	        },
	        set: function (value) {
	            this._adaptee.y = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_ymouse", {
	        get: function () {
	            return this._view.getLocalMouseY(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_xscale", {
	        get: function () {
	            return this._adaptee.scaleX * 100;
	        },
	        set: function (value) {
	            this._adaptee.scaleX = value / 100;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_yscale", {
	        get: function () {
	            return this._adaptee.scaleY * 100;
	        },
	        set: function (value) {
	            this._adaptee.scaleY = value / 100;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_visible", {
	        get: function () {
	            return this._adaptee.visible;
	        },
	        set: function (value) {
	            this._adaptee.visible = value;
	            this._visibilityByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_width", {
	        get: function () {
	            return this._adaptee.width;
	        },
	        set: function (value) {
	            this._adaptee.width = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_touchpoints", {
	        get: function () {
	            return this._view.getLocalTouchPoints(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.getDepth = function () {
	        return this._adaptee.z;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_quality", {
	        // just assure consistency for scripts, doesn't actually effect rendering.
	        get: function () {
	            return this.__quality;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "quality", {
	        set: function (value) {
	            this.__quality = value;
	            // this._blockedByScript=true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.trace = function (message) {
	        console.log(message);
	    };
	    // may need proper high-def timer mechanism
	    AS2SymbolAdapter.prototype.getTimer = function () {
	        return new Date().getTime() - AS2SymbolAdapter.REFERENCE_TIME;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_alpha", {
	        get: function () {
	            return this.adaptee.transform.colorTransform ? (this.adaptee.transform.colorTransform.alphaMultiplier * 100) : 100;
	        },
	        set: function (value) {
	            if (!this.adaptee.transform.colorTransform)
	                this.adaptee.transform.colorTransform = new ColorTransform_1.default();
	            this.adaptee.transform.colorTransform.alphaMultiplier = value / 100;
	            this.adaptee.pInvalidateHierarchicalProperties(HierarchicalProperties_1.default.COLOR_TRANSFORM);
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_url", {
	        get: function () {
	            return document.URL;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_global", {
	        get: function () {
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_level0", {
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.clearInterval = function (handle) {
	        FrameScriptManager_1.default.clearInterval(handle); //window.clearInterval(handle);
	        return;
	    };
	    AS2SymbolAdapter.prototype.setInterval = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var scope;
	        var func;
	        if (typeof (args[0]) == "function") {
	            scope = this;
	            func = args[0];
	        }
	        else {
	            //remove scope variable from args
	            scope = args.shift();
	            //reformat function string to actual function variable in the scope
	            func = scope[args[0]];
	        }
	        //wrap function to maintain scope
	        args[0] = function () { func.apply(scope, arguments); };
	        return FrameScriptManager_1.default.setInterval(args[0]); // window.setInterval.apply(window, args);
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_level10301", {
	        // temporary:
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_root", {
	        get: function () {
	            if (!this.__root) {
	                var p = this._parent;
	                // parents are always MovieClips
	                this.__root = p ? p._root : this;
	            }
	            return this.__root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.random = function (range) {
	        return Math.floor(Math.random() * range);
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_parent", {
	        get: function () {
	            var parent = this.adaptee.parent;
	            return parent ? parent.adapter : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.REFERENCE_TIME = -1;
	    return AS2SymbolAdapter;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2SymbolAdapter;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(1);
	var AssetBase_1 = __webpack_require__(24);
	var AS2MCSoundProps = (function (_super) {
	    __extends(AS2MCSoundProps, _super);
	    function AS2MCSoundProps() {
	        _super.call(this);
	        this._volume = 1;
	        this._pan = 1;
	        this._changeEvent = new AssetEvent_1.default(AssetEvent_1.default.INVALIDATE, this);
	    }
	    AS2MCSoundProps.prototype.dispose = function () {
	        this._audio = null;
	        this._changeEvent = null;
	    };
	    Object.defineProperty(AS2MCSoundProps.prototype, "volume", {
	        get: function () {
	            return this._volume;
	        },
	        set: function (value) {
	            if (this._volume != value) {
	                this._volume = value;
	                this.dispatchEvent(this._changeEvent);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MCSoundProps.prototype, "pan", {
	        get: function () {
	            return this._pan;
	        },
	        set: function (value) {
	            if (this._pan != value) {
	                this._pan = value;
	                this.dispatchEvent(this._changeEvent);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MCSoundProps.prototype, "audio", {
	        get: function () {
	            return this._audio;
	        },
	        set: function (value) {
	            if (this._audio)
	                this._audio.stop();
	            this._audio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AS2MCSoundProps;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2MCSoundProps;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AS2SymbolAdapter_1 = __webpack_require__(284);
	var TextField_1 = __webpack_require__(281);
	var AS2TextFieldAdapter = (function (_super) {
	    __extends(AS2TextFieldAdapter, _super);
	    function AS2TextFieldAdapter(adaptee, view) {
	        // create an empty text field if none is passed
	        _super.call(this, adaptee || new TextField_1.default(), view);
	    }
	    AS2TextFieldAdapter.prototype.clone = function (newAdaptee) {
	        return new AS2TextFieldAdapter(newAdaptee, this._view);
	    };
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "textColor", {
	        get: function () {
	            return this.adaptee.textColor;
	        },
	        set: function (value) {
	            this.adaptee.textColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "embedFonts", {
	        get: function () {
	            return this._embedFonts;
	        },
	        set: function (value) {
	            this._embedFonts = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "text", {
	        get: function () {
	            return this.adaptee.text;
	        },
	        set: function (value) {
	            this.adaptee.text = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AS2TextFieldAdapter;
	}(AS2SymbolAdapter_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2TextFieldAdapter;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var TesselatedFontTable_1 = __webpack_require__(288);
	/**
	 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
	 *
	 *
	 * @see away.base.TriangleElements
	 * @see away.entities.Sprite
	 *
	 * @class away.base.GraphicBase
	 */
	var Font = (function (_super) {
	    __extends(Font, _super);
	    //TODO test shader picking
	    //		public get shaderPickingDetails():boolean
	    //		{
	    //
	    //			return this.sourceEntity.shaderPickingDetails;
	    //		}
	    /**
	     * Creates a new TesselatedFont object
	     */
	    function Font() {
	        _super.call(this);
	        this._font_styles = new Array();
	    }
	    Object.defineProperty(Font.prototype, "font_styles", {
	        get: function () {
	            return this._font_styles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Font.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Font.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Font.prototype.dispose = function () {
	    };
	    /**
	     *Get a font-table for a specific name, or create one if it does not exists.
	     */
	    Font.prototype.get_font_table = function (style_name) {
	        var len = this._font_styles.length;
	        for (var i = 0; i < len; ++i) {
	            if (this._font_styles[i].name == style_name)
	                return this._font_styles[i];
	        }
	        var font_style = new TesselatedFontTable_1.default();
	        font_style.name = style_name;
	        this._font_styles.push(font_style);
	        return font_style;
	    };
	    Font.assetType = "[asset Font]";
	    return Font;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Font;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	var TesselatedFontChar_1 = __webpack_require__(289);
	/**
	 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
	 *
	 *
	 * @see away.base.TriangleElements
	 * @see away.entities.Sprite
	 *
	 * @class away.base.GraphicBase
	 */
	var TesselatedFontTable = (function (_super) {
	    __extends(TesselatedFontTable, _super);
	    //TODO test shader picking
	    //		public get shaderPickingDetails():boolean
	    //		{
	    //
	    //			return this.sourceEntity.shaderPickingDetails;
	    //		}
	    /**
	     * Creates a new TesselatedFont object
	     */
	    function TesselatedFontTable() {
	        _super.call(this);
	        this._font_chars = new Array();
	        this._font_chars_dic = new Object();
	        this._ascent = 0;
	        this._descent = 0;
	    }
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.dispose = function () {
	    };
	    Object.defineProperty(TesselatedFontTable.prototype, "ascent", {
	        get: function () {
	            return this._ascent;
	        },
	        set: function (value) {
	            this._ascent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "descent", {
	        get: function () {
	            return this._descent;
	        },
	        set: function (value) {
	            this._descent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "offset_x", {
	        get: function () {
	            return this._offset_x;
	        },
	        set: function (value) {
	            this._offset_x = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "offset_y", {
	        get: function () {
	            return this._offset_y;
	        },
	        set: function (value) {
	            this._offset_y = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TesselatedFontTable.prototype.get_font_chars = function () {
	        return this._font_chars;
	    };
	    TesselatedFontTable.prototype.get_font_em_size = function () {
	        return this._font_em_size;
	    };
	    TesselatedFontTable.prototype.set_whitespace_width = function (value) {
	        this._whitespace_width = value;
	    };
	    TesselatedFontTable.prototype.get_whitespace_width = function () {
	        return this._whitespace_width;
	    };
	    TesselatedFontTable.prototype.set_font_em_size = function (font_em_size) {
	        this._font_em_size = font_em_size;
	    };
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.getChar = function (name) {
	        return this._font_chars_dic[name];
	    };
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.setChar = function (name, elements, char_width) {
	        var tesselated_font_char = new TesselatedFontChar_1.default(elements);
	        tesselated_font_char.char_width = char_width;
	        elements.name = name;
	        this._font_chars.push(tesselated_font_char);
	        this._font_chars_dic[name] = tesselated_font_char;
	    };
	    return TesselatedFontTable;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TesselatedFontTable;


/***/ },
/* 289 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFormat class represents character formatting information. Use the
	 * TextFormat class to create specific text formatting for text fields. You
	 * can apply text formatting to both static and dynamic text fields. The
	 * properties of the TextFormat class apply to device and embedded fonts.
	 * However, for embedded fonts, bold and italic text actually require specific
	 * fonts. If you want to display bold or italic text with an embedded font,
	 * you need to embed the bold and italic variations of that font.
	 *
	 * <p> You must use the constructor <code>new TextFormat()</code> to create a
	 * TextFormat object before setting its properties. When you apply a
	 * TextFormat object to a text field using the
	 * <code>TextField.defaultTextFormat</code> property or the
	 * <code>TextField.setTextFormat()</code> method, only its defined properties
	 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
	 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
	 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
	 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
	 * by default because if you don't provide values for the properties, Flash
	 * Player uses its own default formatting. The default formatting that Flash
	 * Player uses for each property(if property's value is <code>null</code>) is
	 * as follows:</p>
	 *
	 * <p>The default formatting for each property is also described in each
	 * property description.</p>
	 */
	var TesselatedFontChar = (function () {
	    function TesselatedFontChar(elements) {
	        /**
	         * the char_codes that this geom has kerning set for
	         */
	        this.kerningCharCodes = new Array();
	        /**
	         * the kerning values per char_code
	         */
	        this.kerningValues = new Array();
	        this.elements = elements;
	    }
	    return TesselatedFontChar;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TesselatedFontChar;


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(24);
	/**
	 * The TextFormat class represents character formatting information. Use the
	 * TextFormat class to create specific text formatting for text fields. You
	 * can apply text formatting to both static and dynamic text fields. The
	 * properties of the TextFormat class apply to device and embedded fonts.
	 * However, for embedded fonts, bold and italic text actually require specific
	 * fonts. If you want to display bold or italic text with an embedded font,
	 * you need to embed the bold and italic variations of that font.
	 *
	 * <p> You must use the constructor <code>new TextFormat()</code> to create a
	 * TextFormat object before setting its properties. When you apply a
	 * TextFormat object to a text field using the
	 * <code>TextField.defaultTextFormat</code> property or the
	 * <code>TextField.setTextFormat()</code> method, only its defined properties
	 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
	 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
	 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
	 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
	 * by default because if you don't provide values for the properties, Flash
	 * Player uses its own default formatting. The default formatting that Flash
	 * Player uses for each property(if property's value is <code>null</code>) is
	 * as follows:</p>
	 *
	 * <p>The default formatting for each property is also described in each
	 * property description.</p>
	 */
	var TextFormat = (function (_super) {
	    __extends(TextFormat, _super);
	    /**
	     * Creates a TextFormat object with the specified properties. You can then
	     * change the properties of the TextFormat object to change the formatting of
	     * text fields.
	     *
	     * <p>Any parameter may be set to <code>null</code> to indicate that it is
	     * not defined. All of the parameters are optional; any omitted parameters
	     * are treated as <code>null</code>.</p>
	     *
	     * @param font        The name of a font for text as a string.
	     * @param size        An integer that indicates the size in pixels.
	     * @param color       The color of text using this text format. A number
	     *                    containing three 8-bit RGB components; for example,
	     *                    0xFF0000 is red, and 0x00FF00 is green.
	     * @param bold        A Boolean value that indicates whether the text is
	     *                    boldface.
	     * @param italic      A Boolean value that indicates whether the text is
	     *                    italicized.
	     * @param underline   A Boolean value that indicates whether the text is
	     *                    underlined.
	     * @param url         The URL to which the text in this text format
	     *                    hyperlinks. If <code>url</code> is an empty string, the
	     *                    text does not have a hyperlink.
	     * @param target      The target window where the hyperlink is displayed. If
	     *                    the target window is an empty string, the text is
	     *                    displayed in the default target window
	     *                    <code>_self</code>. If the <code>url</code> parameter
	     *                    is set to an empty string or to the value
	     *                    <code>null</code>, you can get or set this property,
	     *                    but the property will have no effect.
	     * @param align       The alignment of the paragraph, as a TextFormatAlign
	     *                    value.
	     * @param leftMargin  Indicates the left margin of the paragraph, in pixels.
	     * @param rightMargin Indicates the right margin of the paragraph, in pixels.
	     * @param indent      An integer that indicates the indentation from the left
	     *                    margin to the first character in the paragraph.
	     * @param leading     A number that indicates the amount of leading vertical
	     *                    space between lines.
	     */
	    function TextFormat(font, size, color, bold, italic, underline, url, link_target, align, leftMargin, rightMargin, indent, leading) {
	        if (font === void 0) { font = "Times New Roman"; }
	        if (size === void 0) { size = 12; }
	        if (color === void 0) { color = 0x000000; }
	        if (bold === void 0) { bold = false; }
	        if (italic === void 0) { italic = false; }
	        if (underline === void 0) { underline = false; }
	        if (url === void 0) { url = ""; }
	        if (link_target === void 0) { link_target = ""; }
	        if (align === void 0) { align = "left"; }
	        if (leftMargin === void 0) { leftMargin = 0; }
	        if (rightMargin === void 0) { rightMargin = 0; }
	        if (indent === void 0) { indent = 0; }
	        if (leading === void 0) { leading = 0; }
	        _super.call(this);
	        /**
	         * Specifies custom tab stops as an array of non-negative integers. Each tab
	         * stop is specified in pixels. If custom tab stops are not specified
	         * (<code>null</code>), the default tab stop is 4(average character width).
	         */
	        //todo: not used with in tesselated-font-table yet
	        this.tabStops = new Array();
	        this.font_name = font;
	        this.size = size;
	        this.bold = bold;
	        this.italic = italic;
	        this.underline = underline;
	        this.url = url;
	        this.link_target = link_target;
	        this.align = align;
	        this.leftMargin = leftMargin;
	        this.rightMargin = rightMargin;
	        this.indent = indent;
	        this.leading = leading;
	    }
	    Object.defineProperty(TextFormat.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return TextFormat.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextFormat.assetType = "[asset TextFormat]";
	    return TextFormat;
	}(AssetBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextFormat;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AWD3Utils_1 = __webpack_require__(292);
	var AWDBlock = (function () {
	    function AWDBlock(this_id, this_type) {
	        this.type = this_type;
	        this.id = this_id;
	        this.state = AWD3Utils_1.default.BLOCKSTATE_FINALIZE;
	        this.dependencies_data = Array();
	        this.dependencies_urls = Array();
	        if (this_type == 83) {
	            this.loaded_dependencies = Array(6);
	        }
	        this.loaded_dependencies_cnt = 0;
	    }
	    AWDBlock.prototype.dispose = function () {
	        this.id = null;
	        this.bytes = null;
	        this.errorMessages = null;
	        this.uvsForVertexAnimation = null;
	    };
	    AWDBlock.prototype.addError = function (errorMsg) {
	        if (!this.errorMessages)
	            this.errorMessages = new Array();
	        this.errorMessages.push(errorMsg);
	    };
	    return AWDBlock;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AWDBlock;


/***/ },
/* 292 */
/***/ function(module, exports) {

	"use strict";
	var AWD3Utils = (function () {
	    function AWD3Utils() {
	    }
	    AWD3Utils.BLOCKSTATE_FINALIZE = 0;
	    AWD3Utils.BLOCKSTATE_INVALID = 1;
	    AWD3Utils.BLOCKSTATE_LOAD_DEPENDENICES = 2;
	    AWD3Utils.BLOCKSTATE_NO_ASSET = 3;
	    AWD3Utils.COMPRESSIONMODE_LZMA = "lzma";
	    AWD3Utils.UNCOMPRESSED = 0;
	    AWD3Utils.DEFLATE = 1;
	    AWD3Utils.LZMA = 2;
	    AWD3Utils.INT8 = 1;
	    AWD3Utils.INT16 = 2;
	    AWD3Utils.INT32 = 3;
	    AWD3Utils.UINT8 = 4;
	    AWD3Utils.UINT16 = 5;
	    AWD3Utils.UINT32 = 6;
	    AWD3Utils.FLOAT32 = 7;
	    AWD3Utils.FLOAT64 = 8;
	    AWD3Utils.BOOL = 21;
	    AWD3Utils.COLOR = 22;
	    AWD3Utils.BADDR = 23;
	    AWD3Utils.AWDSTRING = 31;
	    AWD3Utils.AWDBYTEARRAY = 32;
	    AWD3Utils.VECTOR2x1 = 41;
	    AWD3Utils.VECTOR3x1 = 42;
	    AWD3Utils.VECTOR4x1 = 43;
	    AWD3Utils.MTX3x2 = 44;
	    AWD3Utils.MTX3x3 = 45;
	    AWD3Utils.MTX4x3 = 46;
	    AWD3Utils.MTX4x4 = 47;
	    return AWD3Utils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AWD3Utils;


/***/ }
/******/ ]);